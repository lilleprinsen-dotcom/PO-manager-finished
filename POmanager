<?php

namespace LPR\Allocator;

/*
 * Overview:
 * - Settings/helpers/constants for allocator options and meta keys.
 * - ETA tracking, PO allocation queues, and FIFO/VIP allocation engines.
 * - Admin UI (metaboxes, reports, quick PO drafts) and cron/Action Scheduler jobs.
 * - Helper utilities for backorder math, PO indexing, and quick-add workflows.
 */

if ( ! defined( __NAMESPACE__ . '\VERSION' ) ) {
        define( __NAMESPACE__ . '\VERSION', '0.1.0-b1' );
}
if ( ! defined( __NAMESPACE__ . '\OPTION_KEY' ) ) {
        define( __NAMESPACE__ . '\OPTION_KEY', 'lpr_allocator_settings' );
}
if ( ! defined( __NAMESPACE__ . '\AUTO_ALLOCATOR_STATE_OPTION' ) ) {
        define( __NAMESPACE__ . '\AUTO_ALLOCATOR_STATE_OPTION', 'lpr_allocator_auto_alloc_state' );
}
if ( ! defined( __NAMESPACE__ . '\DB_VERSION_OPTION' ) ) {
        define( __NAMESPACE__ . '\DB_VERSION_OPTION', 'lpr_allocator_db_version' );
}
if ( ! defined( __NAMESPACE__ . '\ADMIN_MENU_SLUG' ) ) {
        define( __NAMESPACE__ . '\ADMIN_MENU_SLUG', 'lpr-backorder-allocator' );
}

/**
 * Meta key constants (guarded).
 */
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ) {
        define( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA', '_lpr_line_eta' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ) {
        define( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS', 'lpr_allocations' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION' ) ) {
        define( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION', '_lpr_force_allocation' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT' ) ) {
        define( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT', '_lpr_alloc_qty_snapshot' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_META_REQUESTED_DELIVERY' ) ) {
        define( __NAMESPACE__ . '\ORDER_META_REQUESTED_DELIVERY', '_lpr_requested_delivery_date' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_META_LAST_ETA_EMAIL' ) ) {
        define( __NAMESPACE__ . '\ORDER_META_LAST_ETA_EMAIL', '_lpr_last_eta_email' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_UNALLOCATED_POOL' ) ) {
        define( __NAMESPACE__ . '\PRODUCT_META_UNALLOCATED_POOL', '_lpr_unallocated_pool' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ) {
        define( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY', '_lpr_next_extra_qty' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ) {
        define( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA', '_lpr_next_extra_eta' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS' ) ) {
        define( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS', '_lpr_incoming_po_details' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL' ) ) {
        define( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL', '_lpr_incoming_po_total' );
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_frontend_incoming_enabled' ) ) {
        /**
         * Toggle for storefront incoming PO notices.
         */
        function lpr_allocator_frontend_incoming_enabled(): bool {
                if ( ! class_exists( __NAMESPACE__ . '\Settings' ) ) {
                        return false;
                }

                $settings = Settings::get();

                return ! empty( $settings['frontend_extra_pool'] );
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_is_incoming_request' ) ) {
        /**
         * Detect the public /incoming path while avoiding other pages.
         */
        function lpr_allocator_is_incoming_request(): bool {
                $requested_path = isset( $_SERVER['REQUEST_URI'] ) ? (string) $_SERVER['REQUEST_URI'] : '';
                $path           = trim( (string) wp_parse_url( $requested_path, PHP_URL_PATH ), '/' );
                $home_path      = trim( (string) wp_parse_url( home_url( '/' ), PHP_URL_PATH ), '/' );
                if ( '' !== $home_path && 0 === strpos( $path, $home_path ) ) {
                        $path = trim( substr( $path, strlen( $home_path ) ), '/' );
                }

                if ( 0 === strpos( $path, 'index.php/' ) ) {
                        $path = trim( substr( $path, strlen( 'index.php/' ) ), '/' );
                }

                return 'incoming' === $path;
        }
}

if ( ! class_exists( __NAMESPACE__ . '\Settings' ) ) {
	/**
	 * Settings storage & helpers.
	 */
        class Settings {

                /**
                 * Default settings.
                 *
                 * @return array
                 */
                public static function defaults(): array {
                        return array(
                                'order_statuses'        => array( 'processing', 'on-hold' ),
                                'inform_customer_eta'   => false,
                                'frontend_extra_pool'   => false,
                                'frontend_notice_emoji' => true,
                                'frontend_notice_template'      => __( '%qty% units expected (ETA %eta%)', 'lpr-backorder-allocator' ),
                                'frontend_notice_color'         => '#2f855a',
                                'frontend_cart_notice_template' => __( 'Next free stock: %qty% units expected (ETA %eta%)', 'lpr-backorder-allocator' ),
                                'frontend_refresh_interval'     => 900,
                                'backorder_index_interval'      => 21600,
                                'auto_allocation_interval'      => 0,
                                'brand_logo_url'        => '',
                                'brand_primary_color'   => '#1a1a1a',
                                'brand_support_email'   => '',
                                'brand_support_phone'   => '',
                                'email_footer_text_no'  => '',
                                'eta_email_subject'     => __( 'Your order ETA has been updated', 'lpr-backorder-allocator' ),
                                'eta_email_intro'       => __( 'Weâ€™ve updated the expected arrival for the items below:', 'lpr-backorder-allocator' ),
                                'email_eta_disclaimer'  => __( 'All dates are estimates; delays can occur.', 'lpr-backorder-allocator' ),
                                'email_progress_heading'           => __( 'Order progress', 'lpr-backorder-allocator' ),
                                'email_progress_subheading'        => __( 'A quick view of where your order stands.', 'lpr-backorder-allocator' ),
                                'email_progress_complete_label'    => __( '%complete%% complete', 'lpr-backorder-allocator' ),
                                'email_status_label_order_placed'  => __( 'Order placed', 'lpr-backorder-allocator' ),
                                'email_status_label_po_allocated'  => __( 'PO allocated', 'lpr-backorder-allocator' ),
                                'email_status_label_eta_received'  => __( 'ETA received', 'lpr-backorder-allocator' ),
                                'email_status_label_delivery'      => __( 'Estimated delivery', 'lpr-backorder-allocator' ),
                                'email_status_done_label'          => __( 'Completed', 'lpr-backorder-allocator' ),
                                'email_status_pending_label'       => __( 'Pending', 'lpr-backorder-allocator' ),
                                'email_updated_heading'            => __( 'Updated items', 'lpr-backorder-allocator' ),
                                'email_overview_heading'           => __( 'Backordered items', 'lpr-backorder-allocator' ),
                                'email_table_heading_item'         => __( 'Item', 'lpr-backorder-allocator' ),
                                'email_table_heading_previous'     => __( 'Previous', 'lpr-backorder-allocator' ),
                                'email_table_heading_new_eta'      => __( 'New ETA', 'lpr-backorder-allocator' ),
                                'email_unallocated_label'          => __( 'Unallocated', 'lpr-backorder-allocator' ),
                                'incoming_mobile_users'            => array(),
                        );
                }

		/**
		 * Option key.
		 */
		public static function key(): string {
			return OPTION_KEY;
		}

                /**
                 * Get merged settings with defaults applied.
                 */
                public static function get(): array {
                        $stored = get_option( self::key(), array() );
                        if ( ! is_array( $stored ) ) {
                                $stored = array();
                        }
                        $settings = array_replace( self::defaults(), $stored );

                        return $settings;
                }

		/**
		 * Update settings. Ensures autoload = no on first write.
		 *
		 * @param array $raw
		 * @return bool
		 */
		public static function update( array $raw ): bool {
			$san = self::sanitize( $raw );

			$exists = get_option( self::key(), null );
			if ( null === $exists ) {
				return add_option( self::key(), $san, '', 'no' );
			}
			return update_option( self::key(), $san, false );
		}

		/**
		 * Sanitize settings.
		 *
		 * @param array $raw
		 * @return array
		 */
                public static function sanitize( array $raw ): array {
                        $defaults = self::defaults();

			// Order statuses: store as bare slugs (e.g., 'processing').
			$statuses = array();
			if ( ! empty( $raw['order_statuses'] ) && is_array( $raw['order_statuses'] ) ) {
				foreach ( $raw['order_statuses'] as $st ) {
					$st          = sanitize_key( $st );
					$st          = preg_replace( '/^wc-/', '', $st );
					$statuses[]  = $st;
				}
				$statuses = array_values( array_unique( $statuses ) );
			} else {
				$statuses = $defaults['order_statuses'];
			}

                        $inform = ! empty( $raw['inform_customer_eta'] );
                        $front  = ! empty( $raw['frontend_extra_pool'] );
                        $emoji  = isset( $raw['frontend_notice_emoji'] ) ? (bool) $raw['frontend_notice_emoji'] : $defaults['frontend_notice_emoji'];

                        $notice_tpl = isset( $raw['frontend_notice_template'] ) ? wp_kses_post( $raw['frontend_notice_template'] ) : '';
                        if ( '' === trim( $notice_tpl ) ) {
                                $notice_tpl = $defaults['frontend_notice_template'];
                        }

                        $cart_notice_tpl = isset( $raw['frontend_cart_notice_template'] ) ? wp_kses_post( $raw['frontend_cart_notice_template'] ) : '';
                        if ( '' === trim( $cart_notice_tpl ) ) {
                                $cart_notice_tpl = $defaults['frontend_cart_notice_template'];
                        }

                        $notice_color = isset( $raw['frontend_notice_color'] ) ? sanitize_hex_color( $raw['frontend_notice_color'] ) : '';
                        if ( empty( $notice_color ) ) {
                                $notice_color = $defaults['frontend_notice_color'];
                        }

                        $allowed_intervals = array( 300, 900, 1800, 3600, 7200 );
                        $interval         = isset( $raw['frontend_refresh_interval'] ) ? (int) $raw['frontend_refresh_interval'] : $defaults['frontend_refresh_interval'];
                        if ( ! in_array( $interval, $allowed_intervals, true ) ) {
                                $interval = $defaults['frontend_refresh_interval'];
                        }

                        $allowed_index_intervals = array( 0, 3600, 10800, 21600, 43200 );
                        $index_interval          = isset( $raw['backorder_index_interval'] ) ? (int) $raw['backorder_index_interval'] : $defaults['backorder_index_interval'];
                        if ( ! in_array( $index_interval, $allowed_index_intervals, true ) ) {
                                $index_interval = $defaults['backorder_index_interval'];
                        }

                        $mobile_users = array();
                        $raw_users    = $raw['incoming_mobile_users'] ?? array();
                        if ( is_string( $raw_users ) ) {
                                $raw_users = preg_split( '/\r?\n/', $raw_users ) ?: array();
                        }
                        if ( is_array( $raw_users ) ) {
                                foreach ( $raw_users as $entry ) {
                                        $user = '';
                                        $pin  = '';

                                        if ( is_array( $entry ) ) {
                                                $user = isset( $entry['user'] ) ? (string) $entry['user'] : '';
                                                $pin  = isset( $entry['pin'] ) ? (string) $entry['pin'] : '';
                                        } elseif ( is_string( $entry ) ) {
                                                $entry = trim( $entry );
                                                if ( '' === $entry ) {
                                                        continue;
                                                }
                                                if ( false !== strpos( $entry, ':' ) ) {
                                                        list( $user, $pin ) = array_pad( explode( ':', $entry, 2 ), 2, '' );
                                                } else {
                                                        $user = $entry;
                                                }
                                        }

                                        $user = sanitize_text_field( $user );
                                        $pin  = preg_replace( '/[^0-9]/', '', (string) $pin );
                                        if ( '' === $user || strlen( $pin ) !== 4 ) {
                                                continue;
                                        }

                                        $key                 = strtolower( $user );
                                        $mobile_users[ $key ] = array(
                                                'user' => $user,
                                                'pin'  => $pin,
                                        );
                                }
                        }

                        $allowed_alloc_intervals = array( 0, 900, 1800, 3600, 7200, 14400 );
                        $alloc_interval          = isset( $raw['auto_allocation_interval'] ) ? (int) $raw['auto_allocation_interval'] : $defaults['auto_allocation_interval'];
                        if ( ! in_array( $alloc_interval, $allowed_alloc_intervals, true ) ) {
                                $alloc_interval = $defaults['auto_allocation_interval'];
                        }

                        $logo   = isset( $raw['brand_logo_url'] ) ? esc_url_raw( $raw['brand_logo_url'] ) : '';
                        $color  = isset( $raw['brand_primary_color'] ) ? sanitize_hex_color( $raw['brand_primary_color'] ) : '';
                        if ( empty( $color ) ) {
                                $color = $defaults['brand_primary_color'];
			}

                        $email  = isset( $raw['brand_support_email'] ) ? sanitize_email( $raw['brand_support_email'] ) : '';
                        $phone  = isset( $raw['brand_support_phone'] ) ? sanitize_text_field( $raw['brand_support_phone'] ) : '';
                        $footer = isset( $raw['email_footer_text_no'] ) ? wp_kses_post( $raw['email_footer_text_no'] ) : '';

                        $eta_subject = isset( $raw['eta_email_subject'] ) ? sanitize_text_field( $raw['eta_email_subject'] ) : '';
                        if ( '' === trim( $eta_subject ) ) {
                                $eta_subject = $defaults['eta_email_subject'];
                        }

                        $eta_intro = isset( $raw['eta_email_intro'] ) ? wp_kses_post( $raw['eta_email_intro'] ) : '';
                        if ( '' === trim( $eta_intro ) ) {
                                $eta_intro = $defaults['eta_email_intro'];
                        }

                        $eta_disclaimer = isset( $raw['email_eta_disclaimer'] ) ? wp_kses_post( $raw['email_eta_disclaimer'] ) : '';
                        if ( '' === trim( $eta_disclaimer ) ) {
                                $eta_disclaimer = $defaults['email_eta_disclaimer'];
                        }

                        $progress_heading        = isset( $raw['email_progress_heading'] ) ? sanitize_text_field( $raw['email_progress_heading'] ) : '';
                        $progress_subheading     = isset( $raw['email_progress_subheading'] ) ? sanitize_text_field( $raw['email_progress_subheading'] ) : '';
                        $progress_complete_label = isset( $raw['email_progress_complete_label'] ) ? sanitize_text_field( $raw['email_progress_complete_label'] ) : '';
                        $status_order_placed     = isset( $raw['email_status_label_order_placed'] ) ? sanitize_text_field( $raw['email_status_label_order_placed'] ) : '';
                        $status_po_allocated     = isset( $raw['email_status_label_po_allocated'] ) ? sanitize_text_field( $raw['email_status_label_po_allocated'] ) : '';
                        $status_eta_received     = isset( $raw['email_status_label_eta_received'] ) ? sanitize_text_field( $raw['email_status_label_eta_received'] ) : '';
                        $status_delivery         = isset( $raw['email_status_label_delivery'] ) ? sanitize_text_field( $raw['email_status_label_delivery'] ) : '';
                        $status_done_label       = isset( $raw['email_status_done_label'] ) ? sanitize_text_field( $raw['email_status_done_label'] ) : '';
                        $status_pending_label    = isset( $raw['email_status_pending_label'] ) ? sanitize_text_field( $raw['email_status_pending_label'] ) : '';
                        $updated_heading         = isset( $raw['email_updated_heading'] ) ? sanitize_text_field( $raw['email_updated_heading'] ) : '';
                        $overview_heading        = isset( $raw['email_overview_heading'] ) ? sanitize_text_field( $raw['email_overview_heading'] ) : '';
                        $th_item                 = isset( $raw['email_table_heading_item'] ) ? sanitize_text_field( $raw['email_table_heading_item'] ) : '';
                        $th_prev                 = isset( $raw['email_table_heading_previous'] ) ? sanitize_text_field( $raw['email_table_heading_previous'] ) : '';
                        $th_new                  = isset( $raw['email_table_heading_new_eta'] ) ? sanitize_text_field( $raw['email_table_heading_new_eta'] ) : '';
                        $unallocated_label       = isset( $raw['email_unallocated_label'] ) ? sanitize_text_field( $raw['email_unallocated_label'] ) : '';

                        return array(
                                'order_statuses'        => $statuses,
                                'inform_customer_eta'   => (bool) $inform,
                                'frontend_extra_pool'   => (bool) $front,
                                'frontend_notice_emoji' => (bool) $emoji,
                                'frontend_notice_template' => $notice_tpl,
                                'frontend_notice_color'    => $notice_color,
                                'frontend_cart_notice_template' => $cart_notice_tpl,
                                'frontend_refresh_interval' => (int) $interval,
                                'backorder_index_interval' => (int) $index_interval,
                                'auto_allocation_interval' => (int) $alloc_interval,
                                'brand_logo_url'        => $logo,
                                'brand_primary_color'   => $color,
                                'brand_support_email'   => $email,
                                'brand_support_phone'   => $phone,
                                'email_footer_text_no'  => $footer,
                                'eta_email_subject'     => $eta_subject,
                                'eta_email_intro'       => $eta_intro,
                                'email_eta_disclaimer'  => $eta_disclaimer,
                                'email_progress_heading'        => '' === trim( $progress_heading ) ? $defaults['email_progress_heading'] : $progress_heading,
                                'email_progress_subheading'     => '' === trim( $progress_subheading ) ? $defaults['email_progress_subheading'] : $progress_subheading,
                                'email_progress_complete_label' => '' === trim( $progress_complete_label ) ? $defaults['email_progress_complete_label'] : $progress_complete_label,
                                'email_status_label_order_placed' => '' === trim( $status_order_placed ) ? $defaults['email_status_label_order_placed'] : $status_order_placed,
                                'email_status_label_po_allocated' => '' === trim( $status_po_allocated ) ? $defaults['email_status_label_po_allocated'] : $status_po_allocated,
                                'email_status_label_eta_received' => '' === trim( $status_eta_received ) ? $defaults['email_status_label_eta_received'] : $status_eta_received,
                                'email_status_label_delivery'     => '' === trim( $status_delivery ) ? $defaults['email_status_label_delivery'] : $status_delivery,
                                'email_status_done_label'         => '' === trim( $status_done_label ) ? $defaults['email_status_done_label'] : $status_done_label,
                                'email_status_pending_label'      => '' === trim( $status_pending_label ) ? $defaults['email_status_pending_label'] : $status_pending_label,
                                'email_updated_heading'           => '' === trim( $updated_heading ) ? $defaults['email_updated_heading'] : $updated_heading,
                                'email_overview_heading'          => '' === trim( $overview_heading ) ? $defaults['email_overview_heading'] : $overview_heading,
                                'email_table_heading_item'        => '' === trim( $th_item ) ? $defaults['email_table_heading_item'] : $th_item,
                                'email_table_heading_previous'    => '' === trim( $th_prev ) ? $defaults['email_table_heading_previous'] : $th_prev,
                                'email_table_heading_new_eta'     => '' === trim( $th_new ) ? $defaults['email_table_heading_new_eta'] : $th_new,
                                'email_unallocated_label'         => '' === trim( $unallocated_label ) ? $defaults['email_unallocated_label'] : $unallocated_label,
                                'incoming_mobile_users'           => array_values( $mobile_users ),
                        );
                }

                /**
                 * Retrieve incoming mobile login map keyed by lowercase username.
                 */
                public static function mobile_user_map(): array {
                        $settings = self::get();
                        $map      = array();
                        foreach ( (array) ( $settings['incoming_mobile_users'] ?? array() ) as $row ) {
                                if ( empty( $row['user'] ) || empty( $row['pin'] ) ) {
                                        continue;
                                }
                                $map[ strtolower( (string) $row['user'] ) ] = array(
                                        'user' => sanitize_text_field( (string) $row['user'] ),
                                        'pin'  => preg_replace( '/[^0-9]/', '', (string) $row['pin'] ),
                                );
                        }

                        return $map;
                }
        }
}

if ( ! class_exists( __NAMESPACE__ . '\Installer' ) ) {
	/**
	 * Versioned installer (admin_init). Prepares options and version markers.
	 */
	class Installer {
		public static function init(): void {
			add_action( 'admin_init', array( __CLASS__, 'maybe_install' ) );
		}

		public static function maybe_install(): void {
			// Ensure settings option exists with autoload=no.
			$existing = get_option( Settings::key(), null );
			if ( null === $existing ) {
				add_option( Settings::key(), Settings::defaults(), '', 'no' );
			}

			// Ensure a DB version flag exists (no schema work in Batch 1).
			if ( null === get_option( DB_VERSION_OPTION, null ) ) {
				add_option( DB_VERSION_OPTION, '0', '', 'no' );
			}
		}
	}
	Installer::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Admin_Settings_Tab' ) ) {
	/**
	 * WooCommerce -> Settings -> Backorders tab.
	 */
        class Admin_Settings_Tab {

		const TAB_ID = 'lpr_backorders';

                public static function init(): void {
                        add_filter( 'woocommerce_settings_tabs_array', array( __CLASS__, 'register_tab' ), 50 );
                        add_action( 'woocommerce_settings_tabs_' . self::TAB_ID, array( __CLASS__, 'render' ) );
                        add_action( 'woocommerce_update_options_' . self::TAB_ID, array( __CLASS__, 'save_general' ) );
                        add_action( 'woocommerce_settings_save_' . self::TAB_ID, array( __CLASS__, 'save_general' ) );
                        add_action( 'admin_post_lpr_allocator_force_auto_allocation', array( __CLASS__, 'handle_force_auto_allocation' ) );
                        add_action( 'woocommerce_admin_field_lpr_po_index_rebuild', array( __CLASS__, 'render_po_index_rebuild_field' ) );
                        add_action( 'admin_post_lpr_allocator_force_po_index_rebuild', array( __CLASS__, 'handle_force_po_index_rebuild' ) );
                }

		/**
		 * Add custom tab.
		 */
		public static function register_tab( array $tabs ): array {
			if ( current_user_can( 'manage_woocommerce' ) ) {
				$tabs[ self::TAB_ID ] = __( 'Backorders', 'lpr-backorder-allocator' );
			}
			return $tabs;
		}

                /**
                 * Build general (non-email) fields array for WC settings renderer.
                 */
                protected static function get_general_fields( array $settings ): array {
                        // Build order status options with bare keys (strip 'wc-').
                        $wc_statuses = function_exists( 'wc_get_order_statuses' ) ? wc_get_order_statuses() : array();
                        $status_opts = array();
                        foreach ( $wc_statuses as $key => $label ) {
                                $bare               = preg_replace( '/^wc-/', '', $key );
                                $status_opts[ $bare ] = $label;
                        }

                        $defaults = Settings::defaults();

                        return array(
                                array(
                                        'title' => __( 'Backorder Allocator Settings', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'Configure allocator behavior and storefront notices. Allocation never adjusts stock.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_main',
                                ),

                                array(
                                        'title'    => __( 'Order statuses to include', 'lpr-backorder-allocator' ),
                                        'desc'     => __( 'Orders in these statuses are considered for allocation and reports.', 'lpr-backorder-allocator' ),
                                        'id'       => 'lpr_allocator_order_statuses',
                                        'type'     => 'multiselect',
                                        'class'    => 'wc-enhanced-select',
                                        'options'  => $status_opts,
                                        'default'  => Settings::defaults()['order_statuses'],
                                ),

				array(
				'title'   => __( 'Automatic PO allocation', 'lpr-backorder-allocator' ),
				'desc'    => __( 'Run the PO allocator on all open POs at this cadence. Uses the same logic as the Allocate button.', 'lpr-backorder-allocator' ),
				'id'      => 'lpr_allocator_auto_allocation_interval',
				'type'    => 'select',
				'options' => array(
				0     => __( 'Disabled', 'lpr-backorder-allocator' ),
				900   => __( 'Every 15 minutes', 'lpr-backorder-allocator' ),
				1800  => __( 'Every 30 minutes', 'lpr-backorder-allocator' ),
				3600  => __( 'Every hour', 'lpr-backorder-allocator' ),
				7200  => __( 'Every 2 hours', 'lpr-backorder-allocator' ),
				14400 => __( 'Every 4 hours', 'lpr-backorder-allocator' ),
				),
				'default' => 0,
				),
				
                                array(
                                'title' => __( 'Auto allocation status', 'lpr-backorder-allocator' ),
                                'type'  => 'title',
                                'desc'  => self::render_auto_allocation_status(),
                                'id'    => 'lpr_allocator_auto_allocation_status',
),

                                array(
                                        'title'   => __( 'Backorder index rebuild', 'lpr-backorder-allocator' ),
                                        'desc'    => __( 'Rebuild the cached backordered products index on this cadence. You can also trigger an immediate rebuild from the Backordered Products page.', 'lpr-backorder-allocator' ),
                                        'id'      => 'lpr_allocator_backorder_index_interval',
                                        'type'    => 'select',
                                        'options' => array(
                                                0      => __( 'Manual only', 'lpr-backorder-allocator' ),
                                                3600   => __( 'Every hour', 'lpr-backorder-allocator' ),
                                                10800  => __( 'Every 3 hours', 'lpr-backorder-allocator' ),
                                                21600  => __( 'Every 6 hours', 'lpr-backorder-allocator' ),
                                                43200  => __( 'Every 12 hours', 'lpr-backorder-allocator' ),
                                        ),
                                        'default' => Settings::defaults()['backorder_index_interval'],
                                ),

                                array(
                                        'title' => __( 'PO allocation index', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'If a purchase order shows incorrect allocated quantities, rebuild its allocation index from order items.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_po_index',
                                ),

                                array(
                                        'title' => __( 'Force PO index rebuild', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_po_index_rebuild',
                                        'type'  => 'lpr_po_index_rebuild',
                                        'desc'  => __( 'Enter a PO ID and force the allocator to rescan orders for its allocations.', 'lpr-backorder-allocator' ),
                                ),

                                array(
                                        'title' => __( 'Incoming PIN access', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => sprintf(
                                                /* translators: %s: link to the /incoming mobile dashboard */
                                                __( 'Secure the /incoming mobile dashboard with per-user 4-digit PINs. Launch: %s', 'lpr-backorder-allocator' ),
                                                sprintf( '<a href="%1$s" target="_blank" rel="noopener">%1$s</a>', esc_url( home_url( '/incoming' ) ) )
                                        ),
                                        'id'    => 'lpr_allocator_section_incoming_mobile',
                                ),

                                array(
                                        'title'       => __( 'Mobile usernames & PINs', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Enter one per line using username:1234. PINs must be 4 digits.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_incoming_mobile_users',
                                        'type'        => 'textarea',
                                        'css'         => 'min-width: 400px; height: 120px;',
                                        'placeholder' => "receiver:1234\nmanager:9876",
                                        'default'     => '',
                                ),

                                array(
                                        'type' => 'sectionend',
                                        'id'   => 'lpr_allocator_section_incoming_mobile',
                                ),

                                array(
                                        'type'  => 'sectionend',
                                        'id'    => 'lpr_allocator_section_main',
                                ),

                                array(
                                        'title' => __( 'Storefront notices', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => sprintf(
                                                /* translators: %s: sample incoming supply notice shown on product pages */
                                                __( 'Displays incoming supply on product pages (example: %s).', 'lpr-backorder-allocator' ),
                                                sprintf(
                                                        /* translators: 1: quantity, 2: ETA date */
                                                        _n( '%1$d unit expected (ETA %2$s)', '%1$d units expected (ETA %2$s)', 1, 'lpr-backorder-allocator' ),
                                                        1,
                                                        lpr_allocator_format_store_date( '2025-12-07' )
                                                )
                                        ),
                                        'id'    => 'lpr_allocator_section_frontend',
                                ),

                                array(
                                        'title'   => __( 'Show incoming supply notice', 'lpr-backorder-allocator' ),
                                        'desc'    => __( 'Append a notice for incoming POs to products on backorder.', 'lpr-backorder-allocator' ),
                                        'id'      => 'lpr_allocator_frontend_extra_pool',
                                        'type'    => 'checkbox',
                                        'default' => 'no',
                                ),

                                array(
                                        'title'   => __( 'Show factory emoji', 'lpr-backorder-allocator' ),
                                        'desc'    => __( 'Prefix the product page notice with a ðŸ­ emoji.', 'lpr-backorder-allocator' ),
                                        'id'      => 'lpr_allocator_frontend_notice_emoji',
                                        'type'    => 'checkbox',
                                        'default' => 'yes',
                                ),

                                array(
                                        'title'       => __( 'Product page notice text', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Use %qty% and %eta% placeholders. Example: "%qty% units expected (ETA %eta%)"', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_frontend_notice_template',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 400px;',
                                        'placeholder' => $defaults['frontend_notice_template'],
                                        'default'     => $defaults['frontend_notice_template'],
                                ),

                                array(
                                        'title'       => __( 'Product page notice color', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Hex color applied to the incoming stock notice.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_frontend_notice_color',
                                        'type'        => 'text',
                                        'css'         => 'width: 140px;',
                                        'placeholder' => $defaults['frontend_notice_color'],
                                        'default'     => $defaults['frontend_notice_color'],
                                ),

                                array(
                                        'title'       => __( 'Cart notice text', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Shown under cart line items. Use %qty% and %eta% placeholders.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_frontend_cart_notice_template',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 400px;',
                                        'placeholder' => $defaults['frontend_cart_notice_template'],
                                        'default'     => $defaults['frontend_cart_notice_template'],
                                ),

                                array(
                                        'title'   => __( 'Storefront refresh interval', 'lpr-backorder-allocator' ),
                                        'desc'    => __( 'How often to refresh incoming supply data on product pages.', 'lpr-backorder-allocator' ),
                                        'id'      => 'lpr_allocator_frontend_refresh_interval',
                                        'type'    => 'select',
                                        'options' => array(
                                                300  => __( 'Every 5 minutes', 'lpr-backorder-allocator' ),
                                                900  => __( 'Every 15 minutes', 'lpr-backorder-allocator' ),
                                                1800 => __( 'Every 30 minutes', 'lpr-backorder-allocator' ),
                                                3600 => __( 'Every hour', 'lpr-backorder-allocator' ),
                                                7200 => __( 'Every 2 hours', 'lpr-backorder-allocator' ),
                                        ),
                                        'default' => Settings::defaults()['frontend_refresh_interval'],
                                ),

                                array(
                                        'type' => 'sectionend',
                                        'id'   => 'lpr_allocator_section_frontend',
                                ),
                        );
                }

                /**
                 * Build email-focused fields array for the dedicated admin page.
                 */
                public static function get_email_fields( array $settings ): array {
                        $defaults = Settings::defaults();

                        return array(
                                array(
                                        'title' => __( 'Email notifications', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'Control the trigger, copy, and branding for all customer emails.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_email_main',
                                ),

                                array(
                                        'title'   => __( 'Inform customer of updated ETA', 'lpr-backorder-allocator' ),
                                        'desc'    => __( 'Send branded email when an orderâ€™s ETA changes.', 'lpr-backorder-allocator' ),
                                        'id'      => 'lpr_allocator_inform_customer_eta',
                                        'type'    => 'checkbox',
                                        'default' => 'no',
                                ),

                                array(
                                        'title'       => __( 'ETA email subject', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Use %order_number% or %customer_name% placeholders.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_eta_email_subject',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 400px;',
                                        'placeholder' => $defaults['eta_email_subject'],
                                        'default'     => $defaults['eta_email_subject'],
                                ),

                                array(
                                        'title'       => __( 'ETA email intro', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Shown above the ETA table. Use %order_number% or %customer_name% placeholders.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_eta_email_intro',
                                        'type'        => 'textarea',
                                        'css'         => 'min-width: 400px; height: 80px;',
                                        'placeholder' => $defaults['eta_email_intro'],
                                        'default'     => $defaults['eta_email_intro'],
                                ),

                                array(
                                        'title'       => __( 'Date disclaimer', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Shown below ETA details to remind customers that dates are estimates and delays can occur.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_eta_disclaimer',
                                        'type'        => 'textarea',
                                        'css'         => 'min-width: 400px; height: 60px;',
                                        'placeholder' => $defaults['email_eta_disclaimer'],
                                        'default'     => $defaults['email_eta_disclaimer'],
                                ),

                                array(
                                        'title' => __( 'Email copy', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'Control the customer-facing text used in ETA updates.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_email_copy',
                                ),

                                array(
                                        'title'       => __( 'Progress heading', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_progress_heading',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 360px;',
                                        'placeholder' => $defaults['email_progress_heading'],
                                        'default'     => $defaults['email_progress_heading'],
                                ),

                                array(
                                        'title'       => __( 'Progress subheading', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_progress_subheading',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 360px;',
                                        'placeholder' => $defaults['email_progress_subheading'],
                                        'default'     => $defaults['email_progress_subheading'],
                                ),

                                array(
                                        'title'       => __( 'Progress ring label', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Use %complete% to inject the completion percentage.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_progress_complete_label',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 360px;',
                                        'placeholder' => $defaults['email_progress_complete_label'],
                                        'default'     => $defaults['email_progress_complete_label'],
                                ),

                                array(
                                        'title'       => __( 'Status labels', 'lpr-backorder-allocator' ),
                                        'type'        => 'title',
                                        'desc'        => __( 'Editable text for each step shown in the progress wheel.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_section_email_status_labels',
                                ),

                                array(
                                        'title'       => __( 'Order placed', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_label_order_placed',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_label_order_placed'],
                                        'default'     => $defaults['email_status_label_order_placed'],
                                ),

                                array(
                                        'title'       => __( 'PO allocated', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_label_po_allocated',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_label_po_allocated'],
                                        'default'     => $defaults['email_status_label_po_allocated'],
                                ),

                                array(
                                        'title'       => __( 'ETA received', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_label_eta_received',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_label_eta_received'],
                                        'default'     => $defaults['email_status_label_eta_received'],
                                ),

                                array(
                                        'title'       => __( 'Estimated delivery', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_label_delivery',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_label_delivery'],
                                        'default'     => $defaults['email_status_label_delivery'],
                                ),

                                array(
                                        'title'       => __( 'Completed label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_done_label',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_done_label'],
                                        'default'     => $defaults['email_status_done_label'],
                                ),

                                array(
                                        'title'       => __( 'Pending label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_status_pending_label',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_status_pending_label'],
                                        'default'     => $defaults['email_status_pending_label'],
                                ),

                                array(
                                        'type' => 'sectionend',
                                        'id'   => 'lpr_allocator_section_email_status_labels',
                                ),

                                array(
                                        'title' => __( 'Email tables', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'Adjust the headings shown above ETA updates.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_email_tables',
                                ),

                                array(
                                        'title'       => __( 'Updated items heading', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_updated_heading',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_updated_heading'],
                                        'default'     => $defaults['email_updated_heading'],
                                ),

                                array(
                                        'title'       => __( 'Backordered items heading', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_overview_heading',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_overview_heading'],
                                        'default'     => $defaults['email_overview_heading'],
                                ),

                                array(
                                        'title'       => __( 'Item column label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_table_heading_item',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_table_heading_item'],
                                        'default'     => $defaults['email_table_heading_item'],
                                ),

                                array(
                                        'title'       => __( 'Previous ETA label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_table_heading_previous',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_table_heading_previous'],
                                        'default'     => $defaults['email_table_heading_previous'],
                                ),

                                array(
                                        'title'       => __( 'New ETA label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_table_heading_new_eta',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_table_heading_new_eta'],
                                        'default'     => $defaults['email_table_heading_new_eta'],
                                ),

                                array(
                                        'title'       => __( 'Unallocated label', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_unallocated_label',
                                        'type'        => 'text',
                                        'placeholder' => $defaults['email_unallocated_label'],
                                        'default'     => $defaults['email_unallocated_label'],
                                ),

                                array(
                                        'type' => 'sectionend',
                                        'id'   => 'lpr_allocator_section_email_tables',
                                ),

                                array(
                                        'title' => __( 'Branding', 'lpr-backorder-allocator' ),
                                        'type'  => 'title',
                                        'desc'  => __( 'Used for branded emails and admin displays.', 'lpr-backorder-allocator' ),
                                        'id'    => 'lpr_allocator_section_brand',
                                ),

                                array(
                                        'title'       => __( 'Brand logo URL', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Absolute URL to a logo image.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_brand_logo_url',
                                        'type'        => 'text',
                                        'css'         => 'min-width: 400px;',
                                        'placeholder' => 'https://example.com/logo.png',
                                        'default'     => '',
                                ),

                                array(
                                        'title'       => __( 'Primary color', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Hex color used in branded emails.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_brand_primary_color',
                                        'type'        => 'text',
                                        'css'         => 'width: 140px;',
                                        'placeholder' => '#1a1a1a',
                                        'default'     => '#1a1a1a',
                                ),

                                array(
                                        'title'       => __( 'Support email', 'lpr-backorder-allocator' ),
                                        'desc'        => __( 'Shown in email headers and footer details.', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_brand_support_email',
                                        'type'        => 'text',
                                        'placeholder' => 'support@example.com',
                                        'default'     => '',
                                ),

                                array(
                                        'title'       => __( 'Support phone', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_brand_support_phone',
                                        'type'        => 'text',
                                        'placeholder' => '+46 70 123 45 67',
                                        'default'     => '',
                                ),

                                array(
                                        'title'       => __( 'Email footer text', 'lpr-backorder-allocator' ),
                                        'id'          => 'lpr_allocator_email_footer_text_no',
                                        'type'        => 'textarea',
                                        'css'         => 'min-width: 400px; height: 100px;',
                                        'placeholder' => __( 'Thank you for your order. Contact us if you have any questions.', 'lpr-backorder-allocator' ),
                                        'default'     => '',
                                ),

                                array(
                                        'type'  => 'sectionend',
                                        'id'    => 'lpr_allocator_section_brand',
                                ),
                        );
                }

		/**
		 * Provide field values to WC renderer from our single option via pre_option_*.
		 */
                public static function prime_field_values( array $settings ): void {
                        $map = array(
                                'lpr_allocator_order_statuses'             => (array) $settings['order_statuses'],
                                'lpr_allocator_inform_customer_eta'        => $settings['inform_customer_eta'] ? 'yes' : 'no',
                                'lpr_allocator_frontend_extra_pool'        => $settings['frontend_extra_pool'] ? 'yes' : 'no',
                                'lpr_allocator_frontend_notice_emoji'      => $settings['frontend_notice_emoji'] ? 'yes' : 'no',
                                'lpr_allocator_frontend_notice_template'   => (string) $settings['frontend_notice_template'],
                                'lpr_allocator_frontend_notice_color'      => (string) $settings['frontend_notice_color'],
                                'lpr_allocator_frontend_cart_notice_template' => (string) $settings['frontend_cart_notice_template'],
                                'lpr_allocator_frontend_refresh_interval'  => (int) $settings['frontend_refresh_interval'],
                                'lpr_allocator_backorder_index_interval'   => (int) $settings['backorder_index_interval'],
                                'lpr_allocator_auto_allocation_interval'   => (int) $settings['auto_allocation_interval'],
                                'lpr_allocator_incoming_mobile_users'      => self::format_mobile_users_field( (array) ( $settings['incoming_mobile_users'] ?? array() ) ),
                                'lpr_allocator_brand_logo_url'             => (string) $settings['brand_logo_url'],
                                'lpr_allocator_brand_primary_color'        => (string) $settings['brand_primary_color'],
                                'lpr_allocator_brand_support_email'        => (string) $settings['brand_support_email'],
                                'lpr_allocator_brand_support_phone'        => (string) $settings['brand_support_phone'],
                                'lpr_allocator_email_footer_text_no'       => (string) $settings['email_footer_text_no'],
                                'lpr_allocator_eta_email_subject'          => (string) $settings['eta_email_subject'],
                                'lpr_allocator_eta_email_intro'            => (string) $settings['eta_email_intro'],
                                'lpr_allocator_email_eta_disclaimer'       => (string) $settings['email_eta_disclaimer'],
                                'lpr_allocator_email_progress_heading'     => (string) $settings['email_progress_heading'],
                                'lpr_allocator_email_progress_subheading'  => (string) $settings['email_progress_subheading'],
                                'lpr_allocator_email_progress_complete_label' => (string) $settings['email_progress_complete_label'],
                                'lpr_allocator_email_status_label_order_placed' => (string) $settings['email_status_label_order_placed'],
                                'lpr_allocator_email_status_label_po_allocated' => (string) $settings['email_status_label_po_allocated'],
                                'lpr_allocator_email_status_label_eta_received' => (string) $settings['email_status_label_eta_received'],
                                'lpr_allocator_email_status_label_delivery' => (string) $settings['email_status_label_delivery'],
                                'lpr_allocator_email_status_done_label'    => (string) $settings['email_status_done_label'],
                                'lpr_allocator_email_status_pending_label' => (string) $settings['email_status_pending_label'],
                                'lpr_allocator_email_updated_heading'      => (string) $settings['email_updated_heading'],
                                'lpr_allocator_email_overview_heading'     => (string) $settings['email_overview_heading'],
                                'lpr_allocator_email_table_heading_item'   => (string) $settings['email_table_heading_item'],
                                'lpr_allocator_email_table_heading_previous' => (string) $settings['email_table_heading_previous'],
                                'lpr_allocator_email_table_heading_new_eta' => (string) $settings['email_table_heading_new_eta'],
                                'lpr_allocator_email_unallocated_label'    => (string) $settings['email_unallocated_label'],
                          );

                        foreach ( $map as $opt => $val ) {
                                add_filter(
                                        'pre_option_' . $opt,
                                        static function () use ( $val ) {
                                                return $val;
                                        }
                                );
                        }
                }

                /**
                 * Convert stored mobile user rows into textarea-friendly lines.
                 */
		protected static function format_mobile_users_field( array $users ): string {
		$lines = array();
		foreach ( $users as $row ) {
		$user = isset( $row['user'] ) ? trim( (string) $row['user'] ) : '';
		$pin  = isset( $row['pin'] ) ? trim( (string) $row['pin'] ) : '';
		if ( '' === $user || '' === $pin ) {
		continue;
		}
		$lines[] = $user . ':' . $pin;
		}
		
		return implode( "\n", $lines );
		}
		
		/**
		 * Build HTML for the auto allocator status block.
		 */
                protected static function render_auto_allocation_status(): string {
                if ( ! class_exists( __NAMESPACE__ . '\\Auto_PO_Allocator' ) ) {
                return esc_html__( 'Auto allocation status is unavailable.', 'lpr-backorder-allocator' );
                }

                $snapshot    = Auto_PO_Allocator::get_status_snapshot();
                $unfinished  = isset( $snapshot['unfinished_jobs'] ) && is_array( $snapshot['unfinished_jobs'] ) ? $snapshot['unfinished_jobs'] : array();
                $last_finish = Auto_PO_Allocator::format_datetime( isset( $snapshot['last_finished_at'] ) ? (string) $snapshot['last_finished_at'] : '' );
                $last_full   = Auto_PO_Allocator::format_datetime( isset( $snapshot['last_full_reallocation'] ) ? (string) $snapshot['last_full_reallocation'] : '' );

                $force_state = isset( $_GET['lpr_force_auto_allocation'] ) ? sanitize_key( wp_unslash( $_GET['lpr_force_auto_allocation'] ) ) : '';
                $force_total = isset( $_GET['lpr_force_auto_allocation_total'] ) ? (int) $_GET['lpr_force_auto_allocation_total'] : 0;

                $notice = '';
                if ( 'queued' === $force_state && $force_total > 0 ) {
                        $notice = sprintf(
                                /* translators: 1: number of queued POs, 2: batch size, 3: interval in seconds */
                                __( 'Queued %1$d open POs for reallocation in batches of %2$d every %3$d seconds.', 'lpr-backorder-allocator' ),
                                $force_total,
                                Auto_PO_Allocator::BATCH_SIZE,
                                Auto_PO_Allocator::BATCH_SPACING_SECONDS
                        );
                } elseif ( 'none' === $force_state ) {
                        $notice = __( 'No open POs were found to reallocate.', 'lpr-backorder-allocator' );
                }

                $options = '';
                if ( empty( $unfinished ) ) {
                $options .= '<option>' . esc_html__( 'No unfinished jobs', 'lpr-backorder-allocator' ) . '</option>';
                } else {
		foreach ( $unfinished as $job ) {
		$job_id    = isset( $job['id'] ) && '' !== trim( (string) $job['id'] ) ? (string) $job['id'] : __( 'Unknown job', 'lpr-backorder-allocator' );
		$started   = Auto_PO_Allocator::format_datetime( isset( $job['started_at'] ) ? (string) $job['started_at'] : '' );
		$page      = isset( $job['page'] ) ? (int) $job['page'] : 1;
		$processed = isset( $job['processed'] ) ? (int) $job['processed'] : 0;
		$options  .= '<option>' . esc_html( sprintf( __( 'Job %1$s â€” started %2$s (page %3$d, processed %4$d)', 'lpr-backorder-allocator' ), $job_id, $started, $page, $processed ) ) . '</option>';
		}
		}

                $dropdown = '<select disabled="disabled" style="min-width:260px;">' . $options . '</select>';

                $html  = '';
                if ( '' !== $notice ) {
                        $html .= '<div class="notice notice-success inline"><p>' . esc_html( $notice ) . '</p></div>';
                }

                $html .= '<p><strong>' . esc_html__( 'Last job finished', 'lpr-backorder-allocator' ) . '</strong>: ' . esc_html( $last_finish ) . '</p>';
                $html .= '<p><strong>' . esc_html__( 'Last full reallocation', 'lpr-backorder-allocator' ) . '</strong>: ' . esc_html( $last_full ) . '</p>';
                $html .= '<p><strong>' . esc_html__( 'Unfinished jobs', 'lpr-backorder-allocator' ) . '</strong><br />' . $dropdown . '</p>';

                $force_url   = wp_nonce_url(
                        add_query_arg(
                                array(
                                        'action' => 'lpr_allocator_force_auto_allocation',
                                ),
                                admin_url( 'admin-post.php' )
                        ),
                        'lpr_allocator_force_auto_allocation'
                );
                $open_count  = Auto_PO_Allocator::get_open_po_count();
                $button_copy = sprintf( __( 'Force reallocation now (%d open POs)', 'lpr-backorder-allocator' ), $open_count );
                $html       .= '<p><a href="' . esc_url( $force_url ) . '" class="button">' . esc_html( $button_copy ) . '</a>';
                $html       .= '<span style="margin-left:8px;opacity:.8;">' . esc_html( sprintf( __( 'Schedules all open POs immediately in batches of %1$d every %2$d seconds.', 'lpr-backorder-allocator' ), Auto_PO_Allocator::BATCH_SIZE, Auto_PO_Allocator::BATCH_SPACING_SECONDS ) ) . '</span></p>';

                return wp_kses_post( $html );
}

                /**
                 * Render the custom force PO index rebuild field.
                 */
                public static function render_po_index_rebuild_field( array $field ): void {
                        $po_id      = isset( $_GET['po_id'] ) ? absint( wp_unslash( $_GET['po_id'] ) ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $redirect   = admin_url( 'admin.php?page=wc-settings&tab=' . self::TAB_ID );
                        $action_url = wp_nonce_url(
                                add_query_arg(
                                        array(
                                                'action'   => 'lpr_allocator_force_po_index_rebuild',
                                                'redirect' => rawurlencode( $redirect ),
                                        ),
                                        admin_url( 'admin-post.php' )
                                ),
                                'lpr_allocator_force_po_index_rebuild'
                        );

                        ?>
                        <tr valign="top">
                                <th scope="row" class="titledesc">
                                        <label for="lpr-po-index-po-id"><?php echo esc_html( $field['title'] ); ?></label>
                                </th>
                                <td class="forminp">
                                        <fieldset>
                                                <legend class="screen-reader-text"><span><?php echo esc_html( $field['title'] ); ?></span></legend>
                                                <p class="description"><?php echo esc_html( $field['desc'] ); ?></p>
                                                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                                                        <input type="number" min="1" class="small-text" id="lpr-po-index-po-id" value="<?php echo $po_id ? esc_attr( $po_id ) : ''; ?>" />
                                                        <button type="button" class="button" id="lpr-po-index-rebuild-btn"><?php echo esc_html__( 'Rebuild index', 'lpr-backorder-allocator' ); ?></button>
                                                </div>
                                                <p class="description" style="margin-top:4px;">
                                                        <?php esc_html_e( 'This scans order items for allocations and refreshes the PO index without changing quantities.', 'lpr-backorder-allocator' ); ?>
                                                </p>
                                        </fieldset>
                                        <script>
                                                (function(){
                                                        var btn = document.getElementById('lpr-po-index-rebuild-btn');
                                                        var input = document.getElementById('lpr-po-index-po-id');
                                                        if(!btn || !input){return;}
                                                        var base = '<?php echo esc_js( $action_url ); ?>';
                                                        btn.addEventListener('click', function(){
                                                                var val = parseInt(input.value, 10) || 0;
                                                                var target = base;
                                                                if(val > 0){
                                                                        target += '&po_id=' + encodeURIComponent(val);
                                                                }
                                                                window.location.href = target;
                                                        });
                                                })();
                                        </script>
                                </td>
                        </tr>
                        <?php
                }

                public static function handle_force_auto_allocation(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
                        }

                        $nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( ! wp_verify_nonce( $nonce, 'lpr_allocator_force_auto_allocation' ) ) {
                                wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
                        }

                        $redirect = admin_url( 'admin.php?page=wc-settings&tab=' . self::TAB_ID );
                        $status   = 'none';
                        $total    = 0;

                        if ( class_exists( __NAMESPACE__ . '\\Auto_PO_Allocator' ) ) {
                                $result = Auto_PO_Allocator::force_reallocate_open_pos();
                                $total  = isset( $result['total'] ) ? max( 0, (int) $result['total'] ) : 0;
                                $status = $total > 0 ? 'queued' : 'none';

                                Auto_PO_Allocator::maybe_schedule( true );
                        }

                        $redirect = add_query_arg(
                                array(
                                        'lpr_force_auto_allocation'       => $status,
                                        'lpr_force_auto_allocation_total' => $total,
                                ),
                                $redirect
                        );

                        wp_safe_redirect( $redirect );
                        exit;
                }

                /**
                 * Handle requests to rebuild a PO allocation index from settings.
                 */
                public static function handle_force_po_index_rebuild(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
                        }

                        $nonce = isset( $_REQUEST['_wpnonce'] ) ? (string) $_REQUEST['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        if ( ! wp_verify_nonce( $nonce, 'lpr_allocator_force_po_index_rebuild' ) ) {
                                wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
                        }

                        $po_id    = isset( $_REQUEST['po_id'] ) ? absint( wp_unslash( $_REQUEST['po_id'] ) ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $redirect = isset( $_REQUEST['redirect'] ) ? rawurldecode( (string) wp_unslash( $_REQUEST['redirect'] ) ) : admin_url( 'admin.php?page=wc-settings&tab=' . self::TAB_ID ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $redirect = wp_validate_redirect( $redirect, admin_url( 'admin.php?page=wc-settings&tab=' . self::TAB_ID ) );

                        $status = 'invalid';
                        $count  = 0;

                        if ( $po_id > 0 ) {
                                if (
                                        function_exists( __NAMESPACE__ . '\\lpr_allocator_rebuild_po_alloc_index' )
                                        && function_exists( __NAMESPACE__ . '\\lpr_allocator_store_po_alloc_index' )
                                        && function_exists( __NAMESPACE__ . '\\lpr_allocator_normalize_po_alloc_index' )
                                ) {
                                        $rebuilt = lpr_allocator_normalize_po_alloc_index( lpr_allocator_rebuild_po_alloc_index( $po_id ) );
                                        $count   = count( $rebuilt );
                                        lpr_allocator_store_po_alloc_index( $po_id, $rebuilt );
                                        $status = $count > 0 ? 'rebuilt' : 'cleared';
                                } else {
                                        $status = 'missing';
                                }
                        }

                        $redirect = add_query_arg(
                                array(
                                        'lpr_po_index_rebuild'  => $status,
                                        'po_id'                 => $po_id,
                                        'po_index_row_count'    => $count,
                                ),
                                $redirect
                        );

                        wp_safe_redirect( $redirect );
                        exit;
                }

                /**
                 * Render settings tab.
                 */
                public static function render(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
                        if ( ! function_exists( 'woocommerce_admin_fields' ) ) {
                                return;
                        }
                        $status   = isset( $_GET['lpr_po_index_rebuild'] ) ? sanitize_key( wp_unslash( $_GET['lpr_po_index_rebuild'] ) ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $po_id    = isset( $_GET['po_id'] ) ? absint( wp_unslash( $_GET['po_id'] ) ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $row_cnt  = isset( $_GET['po_index_row_count'] ) ? max( 0, (int) $_GET['po_index_row_count'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( '' !== $status ) {
                                $message = '';
                                $class   = 'updated';

                                if ( 'rebuilt' === $status ) {
                                        $message = sprintf( __( 'Rebuilt the allocation index for PO #%1$d (%2$d linked order items).', 'lpr-backorder-allocator' ), $po_id, $row_cnt );
                                } elseif ( 'cleared' === $status ) {
                                        $message = sprintf( __( 'Cleared the allocation index for PO #%1$d because no allocations were found on orders.', 'lpr-backorder-allocator' ), $po_id );
                                } elseif ( 'missing' === $status ) {
                                        $class   = 'notice-warning';
                                        $message = __( 'Allocator index tools are unavailable in this environment.', 'lpr-backorder-allocator' );
                                } else {
                                        $class   = 'notice-warning';
                                        $message = __( 'Enter a valid PO ID to rebuild its allocation index.', 'lpr-backorder-allocator' );
                                }

                                if ( '' !== $message ) {
                                        echo '<div class="notice ' . esc_attr( $class ) . ' is-dismissible"><p>' . esc_html( $message ) . '</p></div>';
                                }
                        }
                        $settings = Settings::get();
                        self::prime_field_values( $settings );

                        $fields = self::get_general_fields( $settings );
                        woocommerce_admin_fields( $fields );
                }

                /**
                 * Save handler for general settings: collect POST, sanitize, and persist in a single option (autoload=no).
                 */
                public static function save_general(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			if ( function_exists( 'check_admin_referer' ) ) {
				// WooCommerce settings form nonce.
				check_admin_referer( 'woocommerce-settings' );
			}

                        $settings        = Settings::get();
                        $posted_statuses = isset( $_POST['lpr_allocator_order_statuses'] ) ? (array) wp_unslash( $_POST['lpr_allocator_order_statuses'] ) : array();

                        $raw = $settings;
                        $raw['order_statuses']              = $posted_statuses;
                        $raw['frontend_extra_pool']         = ! empty( $_POST['lpr_allocator_frontend_extra_pool'] );
                        $raw['frontend_notice_emoji']       = ! empty( $_POST['lpr_allocator_frontend_notice_emoji'] );
                        $raw['frontend_notice_template']    = isset( $_POST['lpr_allocator_frontend_notice_template'] ) ? (string) wp_unslash( $_POST['lpr_allocator_frontend_notice_template'] ) : $settings['frontend_notice_template'];
                        $raw['frontend_notice_color']       = isset( $_POST['lpr_allocator_frontend_notice_color'] ) ? (string) wp_unslash( $_POST['lpr_allocator_frontend_notice_color'] ) : $settings['frontend_notice_color'];
                        $raw['frontend_cart_notice_template'] = isset( $_POST['lpr_allocator_frontend_cart_notice_template'] ) ? (string) wp_unslash( $_POST['lpr_allocator_frontend_cart_notice_template'] ) : $settings['frontend_cart_notice_template'];
                        $raw['frontend_refresh_interval']   = isset( $_POST['lpr_allocator_frontend_refresh_interval'] ) ? (int) $_POST['lpr_allocator_frontend_refresh_interval'] : $settings['frontend_refresh_interval'];
                        $raw['backorder_index_interval']    = isset( $_POST['lpr_allocator_backorder_index_interval'] ) ? (int) $_POST['lpr_allocator_backorder_index_interval'] : $settings['backorder_index_interval'];
                        $raw['auto_allocation_interval']    = isset( $_POST['lpr_allocator_auto_allocation_interval'] ) ? (int) $_POST['lpr_allocator_auto_allocation_interval'] : $settings['auto_allocation_interval'];
                        $raw['incoming_mobile_users']       = isset( $_POST['lpr_allocator_incoming_mobile_users'] ) ? (string) wp_unslash( $_POST['lpr_allocator_incoming_mobile_users'] ) : $settings['incoming_mobile_users'];

                        Settings::update( $raw );

                        if ( class_exists( __NAMESPACE__ . '\Backorder_Indexer' ) ) {
                                Backorder_Indexer::reset_schedule();
                        }

                        if ( class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                Incoming_Stock_Indexer::reset_schedule();
                        }

                        if ( class_exists( __NAMESPACE__ . '\Auto_PO_Allocator' ) ) {
                                Auto_PO_Allocator::reset_schedule();
                        }

                        if ( class_exists( '\WC_Admin_Settings' ) ) {
                                \WC_Admin_Settings::add_message( __( 'Backorder Allocator settings saved.', 'lpr-backorder-allocator' ) );
                        }
                }

                /**
                 * Save handler for dedicated email settings page.
                 */
                public static function save_email(): bool {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return false;
                        }
                        if ( function_exists( 'check_admin_referer' ) ) {
                                check_admin_referer( 'lpr_email_settings', 'lpr_email_settings_nonce' );
                        }

                        $settings = Settings::get();
                        $raw      = $settings;

                        $raw['inform_customer_eta']           = ! empty( $_POST['lpr_allocator_inform_customer_eta'] );
                        $raw['eta_email_subject']             = isset( $_POST['lpr_allocator_eta_email_subject'] ) ? (string) wp_unslash( $_POST['lpr_allocator_eta_email_subject'] ) : $settings['eta_email_subject'];
                        $raw['eta_email_intro']               = isset( $_POST['lpr_allocator_eta_email_intro'] ) ? (string) wp_unslash( $_POST['lpr_allocator_eta_email_intro'] ) : $settings['eta_email_intro'];
                        $raw['email_eta_disclaimer']          = isset( $_POST['lpr_allocator_email_eta_disclaimer'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_eta_disclaimer'] ) : $settings['email_eta_disclaimer'];
                        $raw['email_progress_heading']        = isset( $_POST['lpr_allocator_email_progress_heading'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_progress_heading'] ) : $settings['email_progress_heading'];
                        $raw['email_progress_subheading']     = isset( $_POST['lpr_allocator_email_progress_subheading'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_progress_subheading'] ) : $settings['email_progress_subheading'];
                        $raw['email_progress_complete_label'] = isset( $_POST['lpr_allocator_email_progress_complete_label'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_progress_complete_label'] ) : $settings['email_progress_complete_label'];
                        $raw['email_status_label_order_placed'] = isset( $_POST['lpr_allocator_email_status_label_order_placed'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_label_order_placed'] ) : $settings['email_status_label_order_placed'];
                        $raw['email_status_label_po_allocated'] = isset( $_POST['lpr_allocator_email_status_label_po_allocated'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_label_po_allocated'] ) : $settings['email_status_label_po_allocated'];
                        $raw['email_status_label_eta_received'] = isset( $_POST['lpr_allocator_email_status_label_eta_received'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_label_eta_received'] ) : $settings['email_status_label_eta_received'];
                        $raw['email_status_label_delivery']     = isset( $_POST['lpr_allocator_email_status_label_delivery'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_label_delivery'] ) : $settings['email_status_label_delivery'];
                        $raw['email_status_done_label']         = isset( $_POST['lpr_allocator_email_status_done_label'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_done_label'] ) : $settings['email_status_done_label'];
                        $raw['email_status_pending_label']      = isset( $_POST['lpr_allocator_email_status_pending_label'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_status_pending_label'] ) : $settings['email_status_pending_label'];
                        $raw['email_updated_heading']           = isset( $_POST['lpr_allocator_email_updated_heading'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_updated_heading'] ) : $settings['email_updated_heading'];
                        $raw['email_overview_heading']          = isset( $_POST['lpr_allocator_email_overview_heading'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_overview_heading'] ) : $settings['email_overview_heading'];
                        $raw['email_table_heading_item']        = isset( $_POST['lpr_allocator_email_table_heading_item'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_table_heading_item'] ) : $settings['email_table_heading_item'];
                        $raw['email_table_heading_previous']    = isset( $_POST['lpr_allocator_email_table_heading_previous'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_table_heading_previous'] ) : $settings['email_table_heading_previous'];
                        $raw['email_table_heading_new_eta']     = isset( $_POST['lpr_allocator_email_table_heading_new_eta'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_table_heading_new_eta'] ) : $settings['email_table_heading_new_eta'];
                        $raw['email_unallocated_label']         = isset( $_POST['lpr_allocator_email_unallocated_label'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_unallocated_label'] ) : $settings['email_unallocated_label'];

                        $raw['brand_logo_url']       = isset( $_POST['lpr_allocator_brand_logo_url'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_logo_url'] ) : $settings['brand_logo_url'];
                        $raw['brand_primary_color']  = isset( $_POST['lpr_allocator_brand_primary_color'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_primary_color'] ) : $settings['brand_primary_color'];
                        $raw['brand_support_email']  = isset( $_POST['lpr_allocator_brand_support_email'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_support_email'] ) : $settings['brand_support_email'];
                        $raw['brand_support_phone']  = isset( $_POST['lpr_allocator_brand_support_phone'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_support_phone'] ) : $settings['brand_support_phone'];
                        $raw['email_footer_text_no'] = isset( $_POST['lpr_allocator_email_footer_text_no'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_footer_text_no'] ) : $settings['email_footer_text_no'];

                        return Settings::update( $raw );
                }
        }
        Admin_Settings_Tab::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Email_Settings_Page' ) ) {
        /**
         * Dedicated admin page for allocator email copy, branding, and colors.
         */
        class Email_Settings_Page {

                const SLUG = 'lpr-email-settings';

                public static function init(): void {
                        add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
                        add_action( 'wp_ajax_lpr_bulk_eta_email', array( __CLASS__, 'ajax_bulk_eta_email' ) );
                }

                public static function register_page(): void {
                        add_submenu_page(
                                ADMIN_MENU_SLUG,
                                __( 'Email Settings', 'lpr-backorder-allocator' ),
                                __( 'Email Settings', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                self::SLUG,
                                array( __CLASS__, 'render' ),
                                4
                        );
                }

                protected static function handle_save(): bool {
                        if ( 'POST' !== $_SERVER['REQUEST_METHOD'] ) {
                                return false;
                        }
                        if ( empty( $_POST['lpr_email_settings_nonce'] ) ) {
                                return false;
                        }

                        $saved = Admin_Settings_Tab::save_email();

                        if ( class_exists( '\WC_Admin_Settings' ) ) {
                                if ( $saved ) {
                                        \WC_Admin_Settings::add_message( __( 'Email settings saved.', 'lpr-backorder-allocator' ) );
                                } else {
                                        \WC_Admin_Settings::add_error( __( 'Email settings could not be saved.', 'lpr-backorder-allocator' ) );
                                }
                        }

                        return $saved;
                }

                /**
                 * Collect orders with backordered lines for bulk ETA emails.
                 */
                protected static function collect_backorder_orders(): array {
                        if ( ! class_exists( __NAMESPACE__ . '\Backorder_Order_Indexer' ) ) {
                                return array();
                        }

                        $idx    = Backorder_Order_Indexer::get_index( false );
                        $rows   = isset( $idx['rows'] ) && is_array( $idx['rows'] ) ? $idx['rows'] : array();
                        $orders = array();

                        foreach ( $rows as $row ) {
                                $order_id = isset( $row['order_id'] ) ? (int) $row['order_id'] : 0;
                                if ( $order_id <= 0 ) {
                                        continue;
                                }

                                $is_backorder_line = ! empty( $row['is_backorder_line'] );
                                $qty_backordered   = isset( $row['qty_backordered'] ) ? (int) $row['qty_backordered'] : 0;
                                $product_name      = isset( $row['product'] ) ? (string) $row['product'] : '';
                                $item_key          = isset( $row['item_id'] ) ? (string) $row['item_id'] : ( $product_name ?: (string) $order_id );
                                $qty_ordered       = isset( $row['qty_ordered'] ) ? (int) $row['qty_ordered'] : 0;

                                if ( ! isset( $orders[ $order_id ] ) ) {
                                        $orders[ $order_id ] = array(
                                                'order_id'             => $order_id,
                                                'order_number'         => isset( $row['order_number'] ) ? (string) $row['order_number'] : (string) $order_id,
                                                'status'               => isset( $row['status'] ) ? (string) $row['status'] : '',
                                                'order_date'           => isset( $row['order_date'] ) ? (string) $row['order_date'] : '',
                                                'customer'             => isset( $row['customer'] ) ? (string) $row['customer'] : '',
                                                'customer_email'       => isset( $row['customer_email'] ) ? sanitize_email( (string) $row['customer_email'] ) : '',
                                                'latest_eta'           => '',
                                                'latest_eta_ts'        => 0,
                                                'backordered_qty'      => 0,
                                                'backordered_products' => array(),
                                                'all_products'         => array(),
                                                'product_search'       => '',
                                                'eta_email_sent'       => ! empty( $row['eta_email_sent'] ),
                                        );
                                }

                                $orders[ $order_id ]['eta_email_sent'] = ( $orders[ $order_id ]['eta_email_sent'] ?? false ) || ! empty( $row['eta_email_sent'] );

                                if ( $product_name ) {
                                        $orders[ $order_id ]['all_products'][ $item_key ] = array(
                                                'name'            => $product_name,
                                                'qty'             => $qty_ordered,
                                                'backordered_qty' => $qty_backordered,
                                                'is_backorder'    => $is_backorder_line,
                                        );
                                }

                                if ( $is_backorder_line ) {
                                        $orders[ $order_id ]['backordered_qty'] += $qty_backordered;

                                        if ( $product_name ) {
                                                $orders[ $order_id ]['backordered_products'][ $item_key ] = array(
                                                        'name' => $product_name,
                                                        'qty'  => $qty_backordered,
                                                );
                                        }

                                        if ( ! empty( $row['eta'] ) ) {
                                                $eta    = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                                $eta_ts = 0;
                                                if ( $eta ) {
                                                        $eta_obj = lpr_allocator_parse_date( $eta );
                                                        $eta_ts  = $eta_obj ? $eta_obj->getTimestamp() : 0;
                                                }

                                                if ( $eta_ts > ( $orders[ $order_id ]['latest_eta_ts'] ?? 0 ) ) {
                                                        $orders[ $order_id ]['latest_eta']    = $eta;
                                                        $orders[ $order_id ]['latest_eta_ts'] = $eta_ts;
                                                }
                                        }
                                }
                        }

                        $orders = array_filter(
                                $orders,
                                static function ( $order ) {
                                        return ! empty( $order['backordered_products'] );
                                }
                        );

                        foreach ( $orders as &$order ) {
                                $order['all_products']         = array_values( $order['all_products'] );
                                $order['backordered_products'] = array_values( $order['backordered_products'] );
                                $names                         = array_map(
                                        static function ( $product_row ) {
                                                return isset( $product_row['name'] ) ? (string) $product_row['name'] : '';
                                        },
                                        $order['all_products']
                                );
                                $order['product_search'] = strtolower( implode( ' ', $names ) );
                        }
                        unset( $order );

                        uasort(
                                $orders,
                                static function ( $a, $b ) {
                                        return ( $a['order_id'] ?? 0 ) <=> ( $b['order_id'] ?? 0 );
                                }
                        );

                        return array_values( $orders );
                }

                /**
                 * AJAX: bulk-send ETA emails for selected backorder orders.
                 */
                public static function ajax_bulk_eta_email(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        check_ajax_referer( 'lpr_bulk_eta_email' );

                        $order_id = isset( $_POST['order_id'] ) ? absint( $_POST['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( $order_id <= 0 ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid order.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                wp_send_json_error( array( 'message' => __( 'Order not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                ETA::update_line_eta( $order_id );
                                $order = wc_get_order( $order_id );
                        }

                        if ( ! class_exists( __NAMESPACE__ . '\Order_Allocations_Metabox' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Email sender unavailable.', 'lpr-backorder-allocator' ) ) );
                        }

                        $rows = Order_Allocations_Metabox::build_eta_email_rows( $order );
                        if ( empty( $rows ) ) {
                                wp_send_json_error( array( 'message' => __( 'No backordered items to email.', 'lpr-backorder-allocator' ) ) );
                        }

                        $sent = class_exists( __NAMESPACE__ . '\ETA' ) ? ETA::send_eta_email( $order, array(), false, $rows ) : false;

                        if ( ! $sent ) {
                                wp_send_json_error( array( 'message' => __( 'Unable to send the ETA email.', 'lpr-backorder-allocator' ) ) );
                        }

                        $label = method_exists( $order, 'get_order_number' ) ? (string) $order->get_order_number() : (string) $order_id;

                        wp_send_json_success( array( 'message' => sprintf( __( 'ETA email sent for order %s.', 'lpr-backorder-allocator' ), $label ) ) );
                }

                public static function render(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }
                        if ( ! function_exists( 'woocommerce_admin_fields' ) ) {
                                return;
                        }

                        self::handle_save();

                        $settings = Settings::get();
                        Admin_Settings_Tab::prime_field_values( $settings );

                        $fields = Admin_Settings_Tab::get_email_fields( $settings );

                        echo '<div class="wrap">';
                        echo '<h1>' . esc_html__( 'Email Settings', 'lpr-backorder-allocator' ) . '</h1>';
                        echo '<form method="post" action="">';
                        wp_nonce_field( 'lpr_email_settings', 'lpr_email_settings_nonce' );
                        woocommerce_admin_fields( $fields );
                        submit_button( __( 'Save Email Settings', 'lpr-backorder-allocator' ) );

                        $preview_nonce = wp_create_nonce( 'lpr_email_preview' );
                        $bulk_nonce    = wp_create_nonce( 'lpr_bulk_eta_email' );
                        $bulk_orders   = self::collect_backorder_orders();
                        echo '<p><button type="button" class="button" id="lpr-email-preview">' . esc_html__( 'Preview notification email', 'lpr-backorder-allocator' ) . '</button> <span class="description">' . esc_html__( 'Opens a preview of all allocator emails without sending them.', 'lpr-backorder-allocator' ) . '</span></p>';

                        echo '<details class="lpr-bulk-eta" style="margin-top:16px;">';
                        echo '<summary><strong>' . esc_html__( 'Send updated ETA emails to backordered orders', 'lpr-backorder-allocator' ) . '</strong></summary>';
                        echo '<div style="margin-top:10px;">';
                        if ( empty( $bulk_orders ) ) {
                                echo '<p style="margin:6px 0;">' . esc_html__( 'No backordered orders are available to email right now.', 'lpr-backorder-allocator' ) . '</p>';
                        } else {
                                echo '<p style="margin:6px 0;">' . esc_html__( 'Select the orders that should receive the updated ETA email. Emails will be sent sequentially with a short pause between each send.', 'lpr-backorder-allocator' ) . '</p>';
                                echo '<div class="lpr-bulk-eta-search">';
                                echo '<label class="screen-reader-text" for="lpr-bulk-eta-search">' . esc_html__( 'Search products', 'lpr-backorder-allocator' ) . '</label>';
                                echo '<input type="search" id="lpr-bulk-eta-search" class="regular-text" placeholder="' . esc_attr__( 'Search productsâ€¦', 'lpr-backorder-allocator' ) . '" />';
                                echo '</div>';
                                echo '<div class="lpr-bulk-eta-table-wrap">';
                                echo '<table class="widefat striped lpr-bulk-eta-table">';
                                echo '<thead><tr>';
                                echo '<th class="lpr-col-select">' . esc_html__( 'Email', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Order', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Customer', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Status', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Order date', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Backordered products', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'All products', 'lpr-backorder-allocator' ) . '</th>';
                                echo '<th>' . esc_html__( 'Latest ETA', 'lpr-backorder-allocator' ) . '</th>';
                                echo '</tr></thead><tbody>';

                                foreach ( $bulk_orders as $order_row ) {
                                        $order_id  = isset( $order_row['order_id'] ) ? (int) $order_row['order_id'] : 0;
                                        $order_no  = isset( $order_row['order_number'] ) ? (string) $order_row['order_number'] : (string) $order_id;
                                        $customer  = isset( $order_row['customer'] ) ? (string) $order_row['customer'] : '';
                                        $status    = isset( $order_row['status'] ) ? (string) $order_row['status'] : '';
                                        $order_date = isset( $order_row['order_date'] ) ? (string) $order_row['order_date'] : '';
                                        $eta_label = '';
                                        if ( ! empty( $order_row['latest_eta'] ) ) {
                                                $eta_label = lpr_allocator_format_store_date( (string) $order_row['latest_eta'] );
                                        }

                                        $label = '#' . $order_no;
                                        if ( $customer ) {
                                                $label .= ' â€” ' . $customer;
                                        }

                                        $backordered_products = isset( $order_row['backordered_products'] ) && is_array( $order_row['backordered_products'] ) ? $order_row['backordered_products'] : array();
                                        $all_products         = isset( $order_row['all_products'] ) && is_array( $order_row['all_products'] ) ? $order_row['all_products'] : array();
                                        $product_search       = isset( $order_row['product_search'] ) ? (string) $order_row['product_search'] : '';
                                        $backordered_badges   = '';

                                        foreach ( $backordered_products as $product_row ) {
                                                $prod_name = isset( $product_row['name'] ) ? (string) $product_row['name'] : '';
                                                $prod_qty  = isset( $product_row['qty'] ) ? (int) $product_row['qty'] : 0;
                                                $backordered_badges .= '<span class="lpr-eta-pill"><span class="lpr-eta-pill__name">' . esc_html( $prod_name ) . '</span><span class="lpr-eta-badge">' . esc_html__( 'Backordered', 'lpr-backorder-allocator' ) . '</span><span class="lpr-eta-pill__qty">Ã—' . esc_html( (string) $prod_qty ) . '</span></span>';
                                        }

                                        if ( '' === $backordered_badges ) {
                                                $backordered_badges = '<span class="lpr-eta-empty">' . esc_html__( 'â€”', 'lpr-backorder-allocator' ) . '</span>';
                                        }

                                        $all_products_list = '';
                                        if ( empty( $all_products ) ) {
                                                $all_products_list = '<span class="lpr-eta-empty">' . esc_html__( 'â€”', 'lpr-backorder-allocator' ) . '</span>';
                                        } else {
                                                $items = '';
                                                foreach ( $all_products as $product_row ) {
                                                        $prod_name  = isset( $product_row['name'] ) ? (string) $product_row['name'] : '';
                                                        $prod_qty   = isset( $product_row['qty'] ) ? (int) $product_row['qty'] : 0;
                                                        $is_back    = ! empty( $product_row['is_backorder'] );
                                                        $badge_text = $is_back ? '<span class="lpr-eta-badge">' . esc_html__( 'Backordered', 'lpr-backorder-allocator' ) . '</span>' : '';
                                                        $items     .= '<li><span class="lpr-eta-product-name">' . esc_html( $prod_name ) . '</span> <span class="lpr-eta-qty">Ã—' . esc_html( (string) $prod_qty ) . '</span> ' . $badge_text . '</li>';
                                                }

                                                $all_products_list = '<details class="lpr-eta-all-products"><summary>' . esc_html__( 'Show products', 'lpr-backorder-allocator' ) . ' (' . count( $all_products ) . ')</summary><ul>' . $items . '</ul></details>';
                                        }

                                        $has_eta_email = ! empty( $order_row['eta_email_sent'] );
                                        $eta_icon      = $has_eta_email ? '<span class="lpr-eta-check" title="' . esc_attr__( 'ETA email sent previously', 'lpr-backorder-allocator' ) . '">&#10003;</span>' : '<span class="lpr-eta-check lpr-eta-check--muted" title="' . esc_attr__( 'No ETA email sent yet', 'lpr-backorder-allocator' ) . '">â€”</span>';

                                        echo '<tr class="lpr-eta-order-row" data-products="' . esc_attr( $product_search ) . '">';
                                        echo '<td class="lpr-col-select"><label class="screen-reader-text" for="lpr-eta-order-' . esc_attr( (string) $order_id ) . '">' . esc_html__( 'Email order', 'lpr-backorder-allocator' ) . '</label><input type="checkbox" id="lpr-eta-order-' . esc_attr( (string) $order_id ) . '" class="lpr-eta-bulk-order" value="' . esc_attr( (string) $order_id ) . '" data-order-label="' . esc_attr( $label ) . '" /></td>';
                                        echo '<td><strong>#' . esc_html( $order_no ) . '</strong></td>';
                                        echo '<td>' . esc_html( $customer ?: __( 'Guest', 'lpr-backorder-allocator' ) ) . ' ' . $eta_icon . '</td>';
                                        echo '<td>' . esc_html( $status ?: __( 'Unknown', 'lpr-backorder-allocator' ) ) . '</td>';
                                        echo '<td>' . esc_html( $order_date ?: __( 'â€”', 'lpr-backorder-allocator' ) ) . '</td>';
                                        echo '<td>' . $backordered_badges . '</td>';
                                        echo '<td>' . $all_products_list . '</td>';
                                        echo '<td>' . esc_html( $eta_label ?: __( 'Not set', 'lpr-backorder-allocator' ) ) . '</td>';
                                        echo '</tr>';
                                }

                                echo '</tbody></table>';
                                echo '</div>';
                                echo '<div id="lpr-bulk-eta-empty" class="description" style="display:none;margin-top:6px;">' . esc_html__( 'No orders match this search.', 'lpr-backorder-allocator' ) . '</div>';
                                echo '<p style="margin:10px 0 0;"><button type="button" class="button button-primary" id="lpr-bulk-eta-send" data-nonce="' . esc_attr( $bulk_nonce ) . '">' . esc_html__( 'Send selected ETA emails', 'lpr-backorder-allocator' ) . '</button> <span class="description">' . esc_html__( 'Sends emails one-by-one with a short delay to avoid spam flags.', 'lpr-backorder-allocator' ) . '</span></p>';
                                echo '<div id="lpr-bulk-eta-status" style="margin:8px 0 0;color:#555;"></div>';
                        }
                        echo '</div>';
                        echo '</details>';
                        echo '</form>';
                        echo '<div id="lpr-email-preview-wrap" style="display:none;"></div>';
                        ?>
                        <script>
                        (function($){
                                if(!document.getElementById('lpr-email-preview-style')){
                                        var css = '.lpr-vip-overlay{position:fixed;z-index:100000;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;padding:20px;}.lpr-vip-modal{background:#fff;max-width:820px;width:100%;border-radius:6px;box-shadow:0 10px 40px rgba(0,0,0,.25);overflow:hidden;}.lpr-vip-modal header{padding:14px 16px;border-bottom:1px solid #eee;display:flex;justify-content:space-between;align-items:center;}.lpr-vip-modal .lpr-vip-body{max-height:60vh;overflow:auto;padding:16px;}';
                                        css += '.lpr-bulk-eta-table-wrap{max-height:320px;overflow:auto;border:1px solid #ddd;background:#fff;margin-top:8px;}';
                                        css += '.lpr-bulk-eta-table td,.lpr-bulk-eta-table th{vertical-align:top;}';
                                        css += '.lpr-col-select{width:70px;}';
                                        css += '.lpr-eta-badge{display:inline-block;background:#eef4ff;color:#1d4ed8;border-radius:10px;padding:2px 8px;font-size:11px;font-weight:600;}';
                                        css += '.lpr-eta-pill{display:inline-flex;align-items:center;gap:6px;background:#f7f7f7;border:1px solid #e2e8f0;border-radius:12px;padding:4px 8px;margin:2px 4px 4px 0;font-size:12px;}';
                                        css += '.lpr-eta-pill__qty,.lpr-eta-qty{color:#555;font-size:12px;}';
                                        css += '.lpr-eta-all-products summary{cursor:pointer;font-weight:600;}';
                                        css += '.lpr-eta-all-products ul{margin:6px 0 0;padding-left:18px;}';
                                        css += '.lpr-eta-product-name{font-weight:600;}';
                                        css += '.lpr-eta-check{color:#16a34a;font-weight:700;margin-left:4px;}';
                                        css += '.lpr-eta-check--muted{color:#9ca3af;}';
                                        css += '.lpr-eta-empty{color:#999;}';
                                        css += '.lpr-bulk-eta-search{margin:6px 0;}';
                                        $('head').append('<style id="lpr-email-preview-style">'+css+'</style>');
                                }
                                var $search = $('#lpr-bulk-eta-search');
                                var $orderRows = $('.lpr-eta-order-row');
                                function filterBulkOrders(){
                                        var term = ($search.val() || '').toString().toLowerCase().trim();
                                        var visible = 0;
                                        $orderRows.each(function(){
                                                var $row = $(this);
                                                var hay = ($row.data('products') || '').toString();
                                                var match = !term || hay.indexOf(term) !== -1;
                                                if(match){
                                                        $row.show();
                                                        visible++;
                                                }else{
                                                        $row.hide();
                                                        $row.find('.lpr-eta-bulk-order').prop('checked', false);
                                                }
                                        });
                                        $('#lpr-bulk-eta-empty').toggle(visible === 0);
                                }
                                if($search.length){
                                        filterBulkOrders();
                                        $search.on('input', filterBulkOrders);
                                }
                                function showEmailPreview(html){
                                        var $wrap = $('#lpr-email-preview-wrap');
                                        $wrap.html('<div class="lpr-vip-overlay"><div class="lpr-vip-modal" style="max-width:680px;"><header><h3><?php echo esc_js( __( 'Email preview', 'lpr-backorder-allocator' ) ); ?></h3><a href="#" class="lpr-email-close">&times;</a></header><div class="lpr-vip-body">'+html+'</div></div></div>');
                                        $wrap.show();
                                }
                                $(document).on('click','#lpr-email-preview',function(e){
                                        e.preventDefault();
                                        var $btn = $(this);
                                        $btn.prop('disabled', true);
                                        $.post(ajaxurl,{action:'lpr_allocator_email_preview',_wpnonce:'<?php echo esc_js( $preview_nonce ); ?>'},function(resp){
                                                if(resp && resp.success && resp.data && resp.data.html){
                                                        showEmailPreview(resp.data.html);
                                                }else if(resp && resp.data && resp.data.message){
                                                        window.alert(resp.data.message);
                                                }
                                        }).fail(function(){
                                                window.alert('<?php echo esc_js( __( 'Unable to load email preview.', 'lpr-backorder-allocator' ) ); ?>');
                                        }).always(function(){
                                                $btn.prop('disabled', false);
                                        });
                                });
                                $(document).on('click','#lpr-bulk-eta-send',function(e){
                                        e.preventDefault();
                                        var $btn = $(this);
                                        var nonce = $btn.data('nonce');
                                        var $status = $('#lpr-bulk-eta-status');
                                        var $selected = $('.lpr-eta-bulk-order:checked');

                                        if(!nonce){
                                                return;
                                        }

                                        if($selected.length === 0){
                                                window.alert('<?php echo esc_js( __( 'Select at least one order to email.', 'lpr-backorder-allocator' ) ); ?>');
                                                return;
                                        }

                                        var queue = $selected.map(function(){
                                                return {
                                                        id: $(this).val(),
                                                        label: $(this).data('orderLabel') || '#' + $(this).val()
                                                };
                                        }).get();

                                        $status.empty();
                                        $btn.prop('disabled', true);
                                        var delayMs = 2500;

                                        function sendNext(idx){
                                                if(idx >= queue.length){
                                                        $status.append('<div><?php echo esc_js( __( 'Finished sending selected ETA emails.', 'lpr-backorder-allocator' ) ); ?></div>');
                                                        $btn.prop('disabled', false);
                                                        return;
                                                }

                                                var current = queue[idx];
                                                $status.append('<div>'+current.label+': <?php echo esc_js( __( 'Sending...', 'lpr-backorder-allocator' ) ); ?></div>');

                                                $.post(ajaxurl,{action:'lpr_bulk_eta_email',order_id:current.id,_wpnonce:nonce},function(resp){
                                                        if(resp && resp.success){
                                                                var msg = resp.data && resp.data.message ? resp.data.message : '<?php echo esc_js( __( 'ETA email sent.', 'lpr-backorder-allocator' ) ); ?>';
                                                                $status.append('<div>'+current.label+': '+msg+'</div>');
                                                        }else{
                                                                var err = (resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to send the ETA email.', 'lpr-backorder-allocator' ) ); ?>';
                                                                $status.append('<div>'+current.label+': '+err+'</div>');
                                                        }
                                                }).fail(function(){
                                                        $status.append('<div>'+current.label+': <?php echo esc_js( __( 'Unable to send the ETA email.', 'lpr-backorder-allocator' ) ); ?></div>');
                                                }).always(function(){
                                                        setTimeout(function(){
                                                                sendNext(idx+1);
                                                        }, delayMs);
                                                });
                                        }

                                        sendNext(0);
                                });
                                $(document).on('click','.lpr-email-close',function(e){
                                        e.preventDefault();
                                        $('#lpr-email-preview-wrap').hide().empty();
                                });
                        })(jQuery);
                        </script>
                        <?php
                        echo '</div>';
                }
        }
        Email_Settings_Page::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Email_Notification_Preview' ) ) {
        /**
         * AJAX email preview helper for admin users.
         */
        class Email_Notification_Preview {

                public static function init(): void {
                        add_action( 'wp_ajax_lpr_allocator_email_preview', array( __CLASS__, 'ajax_preview' ) );
                }

                public static function ajax_preview(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        check_ajax_referer( 'lpr_email_preview' );

                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
                        $html     = self::build_preview_html( $settings );

                        wp_send_json_success( array( 'html' => $html ) );
                }

                /**
                 * Build a sample of all outgoing allocator emails.
                 */
                protected static function build_preview_html( array $settings ): string {
                        $sample_rows = array(
                                array(
                                        'name' => __( 'Sample product A', 'lpr-backorder-allocator' ),
                                        'prev' => lpr_allocator_format_store_date( gmdate( 'd-m-Y', strtotime( '+7 days' ) ) ),
                                        'new'  => lpr_allocator_format_store_date( gmdate( 'd-m-Y', strtotime( '+4 days' ) ) ),
                                ),
                                array(
                                        'name' => __( 'Sample product B', 'lpr-backorder-allocator' ),
                                        'prev' => lpr_allocator_format_store_date( gmdate( 'd-m-Y', strtotime( '+15 days' ) ) ),
                                        'new'  => lpr_allocator_format_store_date( gmdate( 'd-m-Y', strtotime( '+11 days' ) ) ),
                                ),
                        );

                        $tokens = array(
                                '%order_number%'  => '12345',
                                '%customer_name%' => __( 'Customer', 'lpr-backorder-allocator' ),
                        );

                        $subject         = __( 'Your order ETA has been updated', 'lpr-backorder-allocator' );
                        $body            = '';
                        $sample_overview = $sample_rows;
                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                $compiled = ETA::build_eta_email_content( $sample_rows, $settings, $tokens, $sample_overview );
                                $subject  = $compiled['subject'] ?? $subject;
                                $body     = $compiled['body'] ?? '';
                        }

                        if ( '' === $body ) {
                                $fallback = ETA::build_eta_email_content( $sample_rows, Settings::defaults(), $tokens, $sample_overview );
                                $subject  = $fallback['subject'];
                                $body     = $fallback['body'];
                        }

                        return '<p><strong>' . esc_html__( 'Subject', 'lpr-backorder-allocator' ) . '</strong>: ' . esc_html( $subject ) . '</p>' . $body;
                }
        }
        Email_Notification_Preview::init();
}


/* SELF-CHECK:
- Added namespaced constants for all required meta keys; guarded with defined().
- Implemented Settings class with option key `lpr_allocator_settings`, defaults (order_statuses ['processing','on-hold'], inform_customer_eta=false, frontend_extra_pool=false, branding fields incl. brand_primary_color '#1a1a1a', email_footer_text_no), getter merges defaults, update() enforces autoload=no on first write.
- Created Installer (admin_init) to seed options and DB version flag; no frontend hooks.
- Registered WooCommerce Settings tab "Backorders" (admin-only). Rendering via woocommerce_admin_fields; values sourced from our single option using pre_option_* filters. Save handler compiles/sanitizes into single option; no stock writes; no wildcard meta queries.
- All declarations are guarded; HPOS/CRUD safe; no frontend impact due to early admin/cron bail.
*/
namespace LPR\Allocator;

if ( ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Storefront' ) ) {
        /**
         * Surface incoming PO availability on the storefront availability text.
         */
        class Incoming_Stock_Storefront {

                /**
                 * Prevent duplicate hooks when the plugin is loaded more than once.
                 *
                 * @var bool
                 */
                private static $bootstrapped = false;

                public static function init(): void {
                        if ( self::$bootstrapped ) {
                                return;
                        }

                        self::$bootstrapped = true;

                        if ( ! self::is_enabled() ) {
                                return;
                        }

                        // Ensure we do not enqueue the filters multiple times if init runs twice.
                        if ( ! has_filter( 'woocommerce_get_availability_text', array( __CLASS__, 'append_incoming_notice' ) ) ) {
                                add_filter( 'woocommerce_get_availability_text', array( __CLASS__, 'append_incoming_notice' ), 25, 2 );
                        }

                        if ( ! has_filter( 'woocommerce_get_availability', array( __CLASS__, 'inject_notice_into_availability' ) ) ) {
                                add_filter( 'woocommerce_get_availability', array( __CLASS__, 'inject_notice_into_availability' ), 25, 2 );
                        }

                        // Surface a dedicated notice block directly below the short description on single product pages (tested with Flatsome).
                        if ( ! has_action( 'woocommerce_single_product_summary', array( __CLASS__, 'output_above_price' ) ) ) {
                                add_action( 'woocommerce_single_product_summary', array( __CLASS__, 'output_above_price' ), 21 );
                        }
                }

                /**
                 * Whether storefront notices should be active.
                 */
                protected static function is_enabled(): bool {
                        if ( wp_doing_cron() ) {
                                return false;
                        }

                        if ( is_admin() && ! wp_doing_ajax() ) {
                                return false;
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_frontend_incoming_enabled' ) ) {
                                return lpr_allocator_frontend_incoming_enabled();
                        }

                        return false;
                }

                /**
                 * Append incoming PO availability to the stock availability message.
                 *
                 * @param string      $text     Existing availability text.
                 * @param \WC_Product $product  Product instance.
                 */
                public static function append_incoming_notice( string $text, $product ): string {
                        $notice = self::notice_for_product( $product, 'frontend_notice_template', 'frontend_notice_emoji', 'frontend_notice_template' );

                        if ( '' === $notice ) {
                                return $text;
                        }

                        return $text ? trim( $text . '<br />' . $notice ) : $notice;
                }

                /**
                 * Inject incoming notice for contexts that use the availability array (blocks).
                 *
                 * @param array       $availability Existing availability payload.
                 * @param \WC_Product $product      Product instance.
                 * @return array
                 */
                public static function inject_notice_into_availability( array $availability, $product ): array {
                        $notice = self::notice_for_product( $product, 'frontend_notice_template', 'frontend_notice_emoji', 'frontend_notice_template' );

                        if ( '' === $notice ) {
                                return $availability;
                        }

                        $availability['availability'] = $availability['availability']
                                ? trim( $availability['availability'] . '<br />' . $notice )
                                : $notice;

                        return $availability;
                }

                /**
                 * Output a standalone incoming stock notice below the short description area.
                 */
                public static function output_above_price(): void {
                        global $product;

                        $notice = self::notice_for_product( $product, 'frontend_notice_template', 'frontend_notice_emoji', 'frontend_notice_template' );

                        if ( '' === $notice ) {
                                return;
                        }

                        echo '<div class="lpr-incoming-single-product" style="margin-bottom:10px;">' . $notice . '</div>';
                }

                /**
                 * Replace placeholders in a custom template and fallback to defaults if needed.
                 */
                public static function build_notice_text( int $qty, string $eta_text, string $template = '', string $fallback_template = '' ): string {
                        $template = '' !== trim( $template ) ? $template : $fallback_template;

                        $rendered = '' !== trim( $template ) ? self::render_template( $template, $qty, $eta_text ) : '';
                        if ( '' !== $rendered ) {
                                return $rendered;
                        }

                        return self::default_notice( $qty, $eta_text );
                }

                /**
                 * Apply quantity/ETA tokens to a template string.
                 */
                protected static function render_template( string $template, int $qty, string $eta_text ): string {
                        $replacements = array(
                                '%qty%' => (string) $qty,
                                '%eta%' => $eta_text,
                                '(qty)' => (string) $qty,
                                '(eta)' => $eta_text,
                        );

                        $rendered = strtr( $template, $replacements );
                        $rendered = trim( $rendered );

                        return '' === $rendered ? '' : wp_kses_post( $rendered );
                }

                /**
                 * Default notice used when no template is supplied.
                 */
                protected static function default_notice( int $qty, string $eta_text ): string {
                        return sprintf(
                                /* translators: 1: quantity, 2: ETA date */
                                _n( '%1$d unit expected (ETA %2$s)', '%1$d units expected (ETA %2$s)', $qty, 'lpr-backorder-allocator' ),
                                $qty,
                                $eta_text
                        );
                }

                /**
                 * Build a fully formatted notice for a given product.
                 *
                 * @param \WC_Product $product
                 * @param string      $template_key     Settings array key containing the template to use.
                 * @param string      $emoji_flag_key   Settings array key containing the emoji flag.
                 * @param string      $fallback_tpl_key Defaults key to use when template is empty.
                 * @return string
                 */
                protected static function notice_for_product( $product, string $template_key, string $emoji_flag_key, string $fallback_tpl_key ): string {
                        if ( ! self::is_enabled() ) {
                                return '';
                        }

                        if ( ! $product instanceof \WC_Product ) {
                                return '';
                        }

                        $product_id = (int) $product->get_id();
                        if ( $product_id <= 0 ) {
                                return '';
                        }

                        // Do not show incoming ETA when the product is already in stock.
                        if ( 'instock' === $product->get_stock_status() ) {
                                return '';
                        }

                        $qty = (int) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty', true );
                        if ( $qty <= 0 ) {
                                return '';
                        }

                        $eta = trim( (string) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta', true ) );
                        if ( '' === $eta ) {
                                return '';
                        }

                        $settings  = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : Settings::defaults();
                        $defaults  = Settings::defaults();
                        $use_emoji = isset( $settings[ $emoji_flag_key ] ) ? (bool) $settings[ $emoji_flag_key ] : $defaults[ $emoji_flag_key ];
                        $notice    = self::build_notice_text(
                                $qty,
                                $eta,
                                $settings[ $template_key ] ?? '',
                                $defaults[ $fallback_tpl_key ]
                        );
                        $color     = isset( $settings['frontend_notice_color'] ) ? sanitize_hex_color( $settings['frontend_notice_color'] ) : $defaults['frontend_notice_color'];
                        if ( empty( $color ) ) {
                                $color = $defaults['frontend_notice_color'];
                        }

                        if ( '' === $notice ) {
                                return '';
                        }

                        $notice = ( $use_emoji ? 'ðŸ­ ' : '' ) . $notice;

                        return sprintf( '<span class="lpr-incoming-notice" style="color:%s;">%s</span>', esc_attr( $color ), $notice );
                }
        }
        Incoming_Stock_Storefront::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Cart' ) ) {
        /**
         * Show incoming availability notices on cart line items.
         */
        class Incoming_Stock_Cart {

                /**
                 * Prevent duplicate hooks.
                 *
                 * @var bool
                 */
                private static $bootstrapped = false;

                public static function init(): void {
                        if ( self::$bootstrapped ) {
                                return;
                        }

                        self::$bootstrapped = true;

                        if ( ! self::is_enabled() ) {
                                return;
                        }

                        add_action( 'woocommerce_after_cart_item_name', array( __CLASS__, 'render_notice' ), 15, 2 );
                }

                /**
                 * Ensure notices only run on the storefront.
                 */
                protected static function is_enabled(): bool {
                        if ( wp_doing_cron() ) {
                                return false;
                        }

                        if ( is_admin() && ! wp_doing_ajax() ) {
                                return false;
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_frontend_incoming_enabled' ) ) {
                                return lpr_allocator_frontend_incoming_enabled();
                        }

                        return false;
                }

                /**
                 * Output the incoming stock notice under cart item names.
                 *
                 * @param array            $cart_item
                 * @param string|int       $cart_item_key
                 */
                public static function render_notice( array $cart_item, $cart_item_key ): void { // phpcs:ignore VariableAnalysis.CodeAnalysis.VariableAnalysis.UnusedVariable
                        if ( ! self::is_enabled() ) {
                                return;
                        }

                        $product = $cart_item['data'] ?? null;
                        if ( ! $product instanceof \WC_Product ) {
                                return;
                        }

                        $product_id = (int) $product->get_id();
                        if ( $product_id <= 0 ) {
                                return;
                        }

                        $qty = (int) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty', true );
                        if ( $qty <= 0 ) {
                                return;
                        }

                        $eta = trim( (string) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta', true ) );
                        if ( '' === $eta ) {
                                return;
                        }

                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
                        $defaults = Settings::defaults();
                        $notice   = Incoming_Stock_Storefront::build_notice_text(
                                $qty,
                                $eta,
                                $settings['frontend_cart_notice_template'] ?? '',
                                $defaults['frontend_cart_notice_template']
                        );

                        if ( '' === $notice ) {
                                return;
                        }

                        echo '<div class="lpr-incoming-cart-notice">' . $notice . '</div>';
                }
        }
        Incoming_Stock_Cart::init();
}

if ( ! is_admin() && ! wp_doing_cron() && ! lpr_allocator_is_incoming_request() ) {
        return;
}

if ( ! class_exists( __NAMESPACE__ . '\\Supplier_PO_Print_PDF' ) ) {
        /**
         * Adds a print-friendly PDF view for Supplier PO edit screens.
         */
        class Supplier_PO_Print_PDF {

                public static function init(): void {
                        add_action( 'add_meta_boxes', array( __CLASS__, 'add_metabox' ) );
                        add_action( 'admin_footer', array( __CLASS__, 'render_footer_assets' ) );
                }

                public static function add_metabox(): void {
                        add_meta_box(
                                'lpr_po_print_pdf',
                                __( 'Print PO PDF', 'lpr-backorder-allocator' ),
                                array( __CLASS__, 'render_metabox' ),
                                defined( __NAMESPACE__ . '\\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                'side',
                                'high'
                        );
                }

                public static function render_metabox( \WP_Post $post ): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }
                        ?>
                        <p><?php echo esc_html__( 'Create a print-ready PDF using the details currently on screen (including unsaved changes).', 'lpr-backorder-allocator' ); ?></p>
                        <p><button type="button" class="button button-primary" id="lpr-po-print-pdf" data-po-id="<?php echo esc_attr( (string) $post->ID ); ?>"><?php echo esc_html__( 'Print PO as PDF', 'lpr-backorder-allocator' ); ?></button></p>
                        <?php
                }

                public static function render_footer_assets(): void {
                        if ( ! self::is_po_screen() ) {
                                return;
                        }
                        ?>
                        <style id="lpr-po-print-styles" type="text/css">
                                /* Reserve namespace for print preview window */
                        </style>
                        <div id="lpr-po-print-root" aria-hidden="true" style="display:none;"></div>
                        <script>
                                (function($){
                                        function escapeHtml(str){
                                                return (str || '').toString()
                                                        .replace(/&/g, '&amp;')
                                                        .replace(/</g, '&lt;')
                                                        .replace(/>/g, '&gt;')
                                                        .replace(/"/g, '&quot;')
                                                        .replace(/'/g, '&#039;');
                                        }

                                        function parseQty(val){
                                                const num = parseInt(val, 10);
                                                return Number.isFinite(num) ? num : 0;
                                        }

                                        function collectLines(){
                                                const lines = [];
                                                $('#lpr-po-lines-table tbody tr').each(function(){
                                                        const $row = $(this);
                                                        const product = ($row.find('select.lpr-product-select option:selected').text() || '').trim();
                                                        const qtyIncoming = parseQty($row.find('input[name*="[qty_ordered]"]').val());
                                                        const qtyAllocated = parseQty($row.find('input[name*="[qty_allocated]"]').val());
                                                        const qtyReceived = parseQty($row.find('input[name*="[qty_received]"]').val());
                                                        const etaOverride = ($row.find('input[name*="[eta_override]"]').val() || '').trim();
                                                        const qtyStock = Math.max(0, qtyIncoming - qtyAllocated);

                                                        if (product || qtyIncoming || qtyAllocated || qtyReceived || etaOverride) {
                                                                lines.push({
                                                                        product,
                                                                        qtyIncoming,
                                                                        qtyAllocated,
                                                                        qtyStock,
                                                                        etaOverride,
                                                                        qtyReceived
                                                                });
                                                        }
                                                });
                                                return lines;
                                        }

                                        function collectHeader(){
                                                return {
                                                        title: ($('#title').val() || '').trim() || '<?php echo esc_js( __( 'Supplier Purchase Order', 'lpr-backorder-allocator' ) ); ?>',
                                                        supplier: ($('#lpr_supplier_name').val() || '').trim(),
                                                        poNumber: ($('#lpr_po_number').val() || '').trim(),
                                                        eta: ($('#lpr_eta_date').val() || '').trim(),
                                                        note: ($('#lpr_po_note').val() || '').trim(),
                                                        status: ($('#lpr_po_status option:selected').text() || '').trim()
                                                };
                                        }

                                        function renderPrintable(data){
                                                const lineRows = data.lines.map(function(line){
                                                        return '<tr>' +
                                                                '<td>'+ escapeHtml(line.product || '<?php echo esc_js( __( 'Product', 'lpr-backorder-allocator' ) ); ?>') +'</td>' +
                                                                '<td class="num">'+ line.qtyIncoming +'</td>' +
                                                                '<td class="num">'+ line.qtyAllocated +'</td>' +
                                                                '<td class="num">'+ line.qtyStock +'</td>' +
                                                                '<td>'+ escapeHtml(line.etaOverride) +'</td>' +
                                                                '<td class="num">'+ line.qtyReceived +'</td>' +
                                                        '</tr>';
                                                }).join('');

                                                const noteBlock = data.note ? '<div class="lpr-po-print-note"><strong><?php echo esc_js( __( 'Note', 'lpr-backorder-allocator' ) ); ?>:</strong><p>'+ escapeHtml(data.note) +'</p></div>' : '';
                                                const linesHtml = lineRows || '<tr><td class="empty" colspan="6"><?php echo esc_js( __( 'No PO lines available.', 'lpr-backorder-allocator' ) ); ?></td></tr>';

                                                return `<!doctype html>
                                                <html>
                                                <head>
                                                <meta charset="utf-8">
                                                <title>${escapeHtml(data.title)}</title>
                                                <style>
                                                        @page { size: A4; margin: 14mm; }
                                                        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #111; margin: 0; padding: 0; background: #f5f5f7; }
                                                        .lpr-po-print-shell { max-width: 210mm; margin: 0 auto; padding: 18px 20px 28px; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.08); }
                                                        .lpr-po-print-header { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-bottom: 14px; }
                                                        .lpr-po-print-header .item { padding: 10px 12px; background: #f3f6fb; border: 1px solid #d8e2f1; border-radius: 6px; }
                                                        .lpr-po-print-header .label { font-size: 12px; text-transform: uppercase; letter-spacing: 0.6px; color: #4a5a6a; margin-bottom: 4px; }
                                                        .lpr-po-print-header .value { font-size: 15px; font-weight: 600; color: #1d1d1f; word-break: break-word; }
                                                        h1 { margin: 0 0 12px; font-size: 24px; letter-spacing: -0.02em; color: #111; }
                                                        .lpr-po-summary { display: flex; flex-wrap: wrap; gap: 12px; margin: 10px 0 6px; }
                                                        .lpr-po-summary .pill { padding: 10px 14px; background: #f0f7ff; border: 1px solid #d0e4ff; border-radius: 999px; font-weight: 600; color: #0b5394; }
                                                        .lpr-po-print-note { margin: 12px 0 6px; padding: 10px 12px; background: #fff7e6; border: 1px solid #f4d9a8; border-radius: 6px; }
                                                        .lpr-po-print-note p { margin: 6px 0 0; white-space: pre-wrap; }
                                                        table { width: 100%; border-collapse: collapse; margin-top: 14px; }
                                                        table th { text-align: left; background: #0b5394; color: #fff; padding: 10px 8px; font-size: 13px; letter-spacing: 0.3px; }
                                                        table td { padding: 9px 8px; border-bottom: 1px solid #e2e8f0; font-size: 13px; }
                                                        table td.num { text-align: right; font-variant-numeric: tabular-nums; }
                                                        table td.empty { text-align: center; color: #555; font-style: italic; }
                                                        .lpr-po-totals { margin-top: 14px; display: flex; gap: 12px; flex-wrap: wrap; }
                                                        .lpr-po-totals .card { flex: 1 1 180px; background: #0b5394; color: #fff; padding: 12px 14px; border-radius: 8px; }
                                                        .lpr-po-totals .card .label { font-size: 12px; text-transform: uppercase; letter-spacing: 0.6px; opacity: 0.9; margin-bottom: 4px; }
                                                        .lpr-po-totals .card .value { font-size: 20px; font-weight: 700; letter-spacing: 0.4px; }
                                                        .lpr-po-footer { margin-top: 14px; font-size: 12px; color: #555; text-align: right; }
                                                        @media print {
                                                                body { background: #fff; }
                                                                .lpr-po-print-shell { box-shadow: none; }
                                                        }
                                                </style>
                                                </head>
                                                <body>
                                                        <div class="lpr-po-print-shell">
                                                                <h1>${escapeHtml(data.title)}</h1>
                                                                <div class="lpr-po-print-header">
                                                                        <div class="item"><div class="label"><?php echo esc_js( __( 'Supplier', 'lpr-backorder-allocator' ) ); ?></div><div class="value">${escapeHtml(data.supplier || '<?php echo esc_js( __( 'Not set', 'lpr-backorder-allocator' ) ); ?>')}</div></div>
                                                                        <div class="item"><div class="label"><?php echo esc_js( __( 'PO Number', 'lpr-backorder-allocator' ) ); ?></div><div class="value">${escapeHtml(data.poNumber || '<?php echo esc_js( __( 'Not set', 'lpr-backorder-allocator' ) ); ?>')}</div></div>
                                                                        <div class="item"><div class="label"><?php echo esc_js( __( 'ETA', 'lpr-backorder-allocator' ) ); ?></div><div class="value">${escapeHtml(data.eta || '<?php echo esc_js( __( 'Not provided', 'lpr-backorder-allocator' ) ); ?>')}</div></div>
                                                                        <div class="item"><div class="label"><?php echo esc_js( __( 'Status', 'lpr-backorder-allocator' ) ); ?></div><div class="value">${escapeHtml(data.status || '<?php echo esc_js( __( 'Open', 'lpr-backorder-allocator' ) ); ?>')}</div></div>
                                                                </div>

                                                                <div class="lpr-po-summary">
                                                                        <div class="pill">${escapeHtml('<?php echo esc_js( __( 'Total incoming', 'lpr-backorder-allocator' ) ); ?>')}: ${data.totalIncoming}</div>
                                                                </div>

                                                                ${noteBlock}

                                                                <table>
                                                                        <thead>
                                                                                <tr>
                                                                                        <th><?php echo esc_js( __( 'Product line', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                        <th><?php echo esc_js( __( 'Incoming', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                        <th><?php echo esc_js( __( 'Allocated to orders', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                        <th><?php echo esc_js( __( 'For stock', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                        <th><?php echo esc_js( __( 'ETA Override', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                        <th><?php echo esc_js( __( 'Received', 'lpr-backorder-allocator' ) ); ?></th>
                                                                                </tr>
                                                                        </thead>
                                                                        <tbody>${linesHtml}</tbody>
                                                                </table>

                                                                <div class="lpr-po-totals">
                                                                        <div class="card">
                                                                                <div class="label"><?php echo esc_js( __( 'Total incoming', 'lpr-backorder-allocator' ) ); ?></div>
                                                                                <div class="value">${data.totalIncoming}</div>
                                                                        </div>
                                                                </div>

                                                                <div class="lpr-po-footer"><?php echo esc_js( __( 'Generated from the current admin PO screen', 'lpr-backorder-allocator' ) ); ?> â€” ${escapeHtml(data.generatedOn)}</div>
                                                        </div>
                                                </body>
                                                </html>`;
                                        }

                                        function openPrint(){
                                                const header = collectHeader();
                                                const lines = collectLines();
                                                const totalIncoming = lines.reduce(function(sum, line){ return sum + line.qtyIncoming; }, 0);
                                                const html = renderPrintable({
                                                        ...header,
                                                        lines,
                                                        totalIncoming,
                                                        generatedOn: new Date().toLocaleString()
                                                });

                                                const win = window.open('', 'lprPoPrint', 'width=900,height=1050');
                                                if (!win) {
                                                        alert('<?php echo esc_js( __( 'Please allow popups to view the printable PO.', 'lpr-backorder-allocator' ) ); ?>');
                                                        return;
                                                }

                                                win.document.open();
                                                win.document.write(html);
                                                win.document.close();
                                                win.focus();
                                                win.print();
                                        }

                                        $(document).on('click', '#lpr-po-print-pdf', function(e){
                                                e.preventDefault();
                                                openPrint();
                                        });
                                })(jQuery);
                        </script>
                        <?php
                }

                protected static function is_po_screen(): bool {
                        $screen = function_exists( 'get_current_screen' ) ? get_current_screen() : null;
                        if ( ! $screen || ! isset( $screen->post_type ) ) {
                                return false;
                        }
                        $post_type = defined( __NAMESPACE__ . '\\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
                        return $screen->post_type === $post_type;
                }
        }
        Supplier_PO_Print_PDF::init();
}

/**
 * Constants for Supplier PO CPT and meta keys (guarded).
 */
if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ) {
	define( __NAMESPACE__ . '\CPT_SUPPLIER_PO', 'supplier_po' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ) {
	define( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME', '_lpr_supplier_name' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ) {
        define( __NAMESPACE__ . '\PO_META_PO_NUMBER', '_lpr_po_number' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ) {
        define( __NAMESPACE__ . '\PO_META_ETA_DATE', '_lpr_eta_date' ); // d-m-Y
}
if ( ! defined( __NAMESPACE__ . '\PO_META_NOTE' ) ) {
        define( __NAMESPACE__ . '\PO_META_NOTE', '_lpr_po_note' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_LINES' ) ) {
        define( __NAMESPACE__ . '\PO_META_LINES', '_lpr_po_lines' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_ALLOC_INDEX' ) ) {
        // Stores [{order_id,int,item_id,int}] used to reconstitute allocations safely.
        define( __NAMESPACE__ . '\PO_META_ALLOC_INDEX', '_lpr_po_alloc_index' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_ALLOC_INDEX_BUILT_AT' ) ) {
        define( __NAMESPACE__ . '\PO_META_ALLOC_INDEX_BUILT_AT', '_lpr_po_alloc_index_built_at' );
}
if ( ! defined( __NAMESPACE__ . '\PO_ALLOC_INDEX_REFRESH_TTL' ) ) {
        define( __NAMESPACE__ . '\PO_ALLOC_INDEX_REFRESH_TTL', 600 ); // 10 minutes.
}
if ( ! defined( __NAMESPACE__ . '\PO_META_RECEIPTS' ) ) {
        define( __NAMESPACE__ . '\PO_META_RECEIPTS', '_lpr_po_receipts' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_OPEN' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_OPEN', 'open' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_PARTIAL' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_PARTIAL', 'partial' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_CLOSED', 'closed' );
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_sanitize_ymd' ) ) {
        /**
         * Sanitize a date string to d-m-Y or empty.
         *
         * @param string $val
         * @return string
         */
        function lpr_allocator_sanitize_ymd( $val ): string {
                $val = trim( (string) $val );
                if ( '' === $val ) {
                        return '';
                }

                $tz = function_exists( 'wp_timezone' ) ? wp_timezone() : new \DateTimeZone( 'UTC' );

                $d_two_digit = \DateTimeImmutable::createFromFormat( '!d-m-y', $val, $tz );
                if ( $d_two_digit && $d_two_digit->format( 'd-m-y' ) === $val ) {
                        return $d_two_digit->format( 'd-m-Y' );
                }

                $d_four_digit = \DateTimeImmutable::createFromFormat( '!d-m-Y', $val, $tz );
                if ( $d_four_digit && $d_four_digit->format( 'd-m-Y' ) === $val ) {
                        return $d_four_digit->format( 'd-m-Y' );
                }

                // Accept legacy Y-m-d values and normalize to d-m-Y.
                $legacy = \DateTimeImmutable::createFromFormat( '!Y-m-d', $val, $tz );
                if ( $legacy && $legacy->format( 'Y-m-d' ) === $val ) {
                        return $legacy->format( 'd-m-Y' );
                }

                return '';
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_parse_date' ) ) {
        /**
         * Parse common date strings (d-m-Y and legacy Y-m-d with optional time) in the site timezone.
         * Returns a DateTimeImmutable or null when parsing fails.
         *
         * @param string $value
         * @return \DateTimeImmutable|null
         */
        function lpr_allocator_parse_date( string $value ): ?\DateTimeImmutable {
                $value = trim( $value );
                if ( '' === $value ) {
                        return null;
                }

                // Normalize separators and force day-month-year ordering for ambiguous inputs
                // such as "10-12-2025". Some environments interpret those as month-day-year,
                // which would turn 10 December into 12 October. We standardize the pieces to
                // avoid that drift before attempting to parse.
                $value = str_replace( array( '/', '.' ), '-', $value );

                if ( preg_match( '/^(\d{1,2})-(\d{1,2})-(\d{2,4})$/', $value, $parts ) ) {
                        $day   = str_pad( $parts[1], 2, '0', STR_PAD_LEFT );
                        $month = str_pad( $parts[2], 2, '0', STR_PAD_LEFT );
                        $year  = (int) $parts[3];

                        // Assume 2000-based dates for 2-digit years to maintain existing behavior.
                        if ( $year < 100 ) {
                                $year += 2000;
                        }

                        $value = sprintf( '%s-%s-%04d', $day, $month, $year );
                }

                $tz      = function_exists( 'wp_timezone' ) ? wp_timezone() : new \DateTimeZone( 'UTC' );
                $formats = array( '!d-m-Y H:i:s', '!d-m-Y H:i', '!d-m-Y', '!d-m-y H:i:s', '!d-m-y H:i', '!d-m-y', '!Y-m-d H:i:s', '!Y-m-d H:i', '!Y-m-d' );

                foreach ( $formats as $format ) {
                        $display  = ltrim( $format, '!' );
                        $date_obj = \DateTimeImmutable::createFromFormat( $format, $value, $tz );

                        if ( $date_obj && $date_obj->format( $display ) === $value ) {
                                return $date_obj;
                        }
                }

                return null;
        }
}


if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_date_to_timestamp' ) ) {
        /**
         * Convert a date string to a Unix timestamp (0 on failure).
         *
         * @param string $value
         * @return int
         */
        function lpr_allocator_date_to_timestamp( string $value ): int {
                $dt = lpr_allocator_parse_date( $value );

                return $dt ? (int) $dt->getTimestamp() : 0;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_compare_dates' ) ) {
        /**
         * Compare two date strings chronologically.
         *
         * @param string $a
         * @param string $b
         * @return int Negative when $a < $b, positive when $a > $b.
         */
        function lpr_allocator_compare_dates( string $a, string $b ): int {
                $ta = lpr_allocator_date_to_timestamp( $a );
                $tb = lpr_allocator_date_to_timestamp( $b );

                if ( $ta === $tb ) {
                        return 0;
                }
                if ( 0 === $ta ) {
                        return 1;
                }
                if ( 0 === $tb ) {
                        return -1;
                }

                return $ta <=> $tb;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_format_store_date' ) ) {
        /**
         * Format a stored d-m-Y (or d-m-Y H:i:s) value using the store date/time format.
         * Falls back to the raw input when parsing fails.
         */
        function lpr_allocator_format_store_date( string $ymd, bool $include_time = false ): string {
                $ymd = trim( $ymd );
                if ( '' === $ymd ) {
                        return '';
                }

                $site_tz = function_exists( 'wp_timezone' ) ? wp_timezone() : new \DateTimeZone( 'UTC' );
                $dt      = lpr_allocator_parse_date( $ymd );

                if ( $dt instanceof \DateTimeImmutable ) {
                        if ( class_exists( '\\WC_DateTime' ) && function_exists( 'wc_format_datetime' ) && function_exists( 'wc_date_format' ) ) {
                                $wc_dt = new \WC_DateTime( $dt->format( 'Y-m-d H:i:s' ), $site_tz );
                                $format = wc_date_format();
                                if ( $include_time ) {
                                        $format .= ' ' . wc_time_format();
                                }

                                return wc_format_datetime( $wc_dt, $format );
                        }

                        $format = get_option( 'date_format', 'd-m-Y' );
                        if ( $include_time ) {
                                $format .= ' ' . get_option( 'time_format', 'H:i' );
                        }

                        return wp_date( $format, $dt->getTimestamp(), $site_tz );
                }

                return $ymd;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_touch_allocation_status' ) ) {
        /**
         * Update an allocation row status and stamp the change time.
         *
         * @param array  $row    Allocation row (passed by reference).
         * @param string $status New status label.
         * @return void
         */
        function lpr_allocator_touch_allocation_status( array &$row, string $status ): void {
                $row['status']            = $status;
                $row['status_changed_at'] = current_time( 'mysql' );
                if ( 'reserved' === $status && empty( $row['allocated_at'] ) ) {
                        $row['allocated_at'] = $row['status_changed_at'];
                }
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_logging_enabled' ) ) {
        /**
         * Toggleable logging helper (static cache to keep runtime cost negligible).
         */
        function lpr_allocator_logging_enabled(): bool {
                static $enabled = null;

                if ( null === $enabled ) {
                        $enabled = (bool) apply_filters( 'lpr_allocator_enable_logging', false );
                }

                return $enabled;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_log_event' ) ) {
        /**
         * Lightweight structured logger for allocator events.
         */
        function lpr_allocator_log_event( string $action, array $context = array() ): void {
                if ( ! lpr_allocator_logging_enabled() || ! function_exists( 'wc_get_logger' ) ) {
                        return;
                }

                $parts = array( 'action=' . $action );

                foreach ( $context as $key => $value ) {
                        if ( is_scalar( $value ) || null === $value ) {
                                $parts[] = $key . '=' . ( null === $value ? 'null' : (string) $value );
                                continue;
                        }

                        if ( is_object( $value ) && method_exists( $value, 'get_id' ) ) {
                                $parts[] = $key . '=' . (string) $value->get_id();
                                continue;
                        }

                        $parts[] = $key . '=' . wp_json_encode( $value );
                }

                wc_get_logger()->info( implode( ' | ', $parts ), array( 'source' => 'lpr-allocator' ) );
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_add_release_note' ) ) {
        /**
         * Add a standardized order note explaining why allocations were released.
         */
        function lpr_allocator_add_release_note( \WC_Order $order, \WC_Order_Item_Product $item, int $qty, string $reason ): void {
                if ( $qty <= 0 ) {
                        return;
                }

                $product   = $item->get_product();
                $sku       = $product instanceof \WC_Product ? $product->get_sku() : '';
                $line_name = $item->get_name();

                $note = sprintf(
                        /* translators: 1: qty, 2: item name, 3: SKU (optional), 4: reason */
                        __( 'Released %1$dx %2$s%3$s: %4$s.', 'lpr-backorder-allocator' ),
                        (int) $qty,
                        $line_name,
                        $sku ? ' [' . $sku . ']' : '',
                        $reason
                );

                $order->add_order_note( $note, false, true );
        }
}
if ( ! class_exists( __NAMESPACE__ . '\Admin_Menu' ) ) {
        /**
         * Top-level admin menu wrapper for all plugin pages.
         */
        class Admin_Menu {

                public static function init(): void {
                        add_action( 'admin_menu', array( __CLASS__, 'register_menu' ), 5 );
                }

                public static function register_menu(): void {
                        add_menu_page(
                                __( 'PO Allocator', 'lpr-backorder-allocator' ),
                                __( 'PO Allocator', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                ADMIN_MENU_SLUG,
                                array( __CLASS__, 'redirect_to_default' ),
                                'dashicons-clipboard',
                                54
                        );

                        add_submenu_page(
                                ADMIN_MENU_SLUG,
                                __( 'Settings', 'lpr-backorder-allocator' ),
                                __( 'Settings', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                ADMIN_MENU_SLUG . '-settings',
                                array( __CLASS__, 'redirect_to_settings' ),
                                90
                        );
                }

                public static function redirect_to_default(): void {
                        wp_safe_redirect( admin_url( 'admin.php?page=lpr-backordered-products' ) );
                        exit;
                }

                public static function redirect_to_settings(): void {
                        wp_safe_redirect( admin_url( 'admin.php?page=wc-settings&tab=' . Admin_Settings_Tab::TAB_ID ) );
                        exit;
                }
        }
        Admin_Menu::init();
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_product_exists' ) ) {
	/**
	 * Validate a product or variation ID via Woo CRUD (HPOS-safe).
	 *
	 * @param int $id
	 * @return bool
	 */
	function lpr_allocator_product_exists( int $id ): bool {
		if ( $id <= 0 ) {
			return false;
		}
		if ( ! function_exists( 'wc_get_product' ) ) {
			return false;
		}
		$product = wc_get_product( $id );
		return $product instanceof \WC_Product;
	}
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_sanitize_po_lines_input' ) ) {
	/**
	 * Normalize and validate PO line input rows (shared by PO edit screens).
	 *
	 * @param array[] $raw_lines
	 * @return array[]
	 */
	function lpr_allocator_sanitize_po_lines_input( array $raw_lines ): array {
		$clean = array();

		foreach ( $raw_lines as $row ) {
			$product_id   = isset( $row['product_id'] ) ? absint( $row['product_id'] ) : 0;
			$variation_id = isset( $row['variation_id'] ) ? absint( $row['variation_id'] ) : 0;
			$qty_ordered  = isset( $row['qty_ordered'] ) ? max( 0, (int) $row['qty_ordered'] ) : 0;
			$qty_alloc    = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
			$eta_override = isset( $row['eta_override'] ) ? lpr_allocator_sanitize_ymd( wp_unslash( $row['eta_override'] ) ) : '';
			$qty_recv     = isset( $row['qty_received'] ) ? max( 0, (int) $row['qty_received'] ) : 0;

			$chosen_id = $variation_id > 0 ? $variation_id : $product_id;
			if ( $chosen_id <= 0 || ! lpr_allocator_product_exists( $chosen_id ) ) {
				continue;
			}

			if ( $qty_ordered > 0 ) {
				$qty_alloc = min( $qty_alloc, $qty_ordered );
				$qty_recv  = min( $qty_recv, $qty_ordered );
			} else {
				$qty_alloc = 0;
				$qty_recv  = 0;
			}

			$line = array(
				'qty_ordered'   => $qty_ordered,
				'qty_allocated' => $qty_alloc,
				'eta_override'  => $eta_override,
				'qty_received'  => $qty_recv,
			);

			if ( $variation_id > 0 ) {
				$line['variation_id'] = $variation_id;
			} else {
				$line['product_id'] = $product_id;
			}

			$clean[] = $line;
		}

                return $clean;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_normalize_po_alloc_index' ) ) {
        /**
         * Normalize a PO allocation index array into a keyed map of order:item => row.
         *
         * @param array $rows
         * @return array<string, array{order_id:int,item_id:int}>
         */
        function lpr_allocator_normalize_po_alloc_index( array $rows ): array {
                $sanitized = array();

                foreach ( $rows as $row ) {
                        $oid = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                        $iid = isset( $row['item_id'] ) ? absint( $row['item_id'] ) : 0;
                        if ( $oid > 0 && $iid > 0 ) {
                                $sanitized[ $oid . ':' . $iid ] = array(
                                        'order_id' => $oid,
                                        'item_id'  => $iid,
                                );
                        }
                }

                return $sanitized;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_store_po_alloc_index' ) ) {
        /**
         * Persist the PO allocation index and bump its built timestamp.
         */
        function lpr_allocator_store_po_alloc_index( int $po_id, array $rows ): void {
                if ( $po_id <= 0 ) {
                        return;
                }

                update_post_meta( $po_id, PO_META_ALLOC_INDEX, array_values( $rows ) );
                update_post_meta( $po_id, PO_META_ALLOC_INDEX_BUILT_AT, time() );
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_po_alloc_index_is_stale' ) ) {
        /**
         * Determine if a PO allocation index should be rebuilt.
         */
        function lpr_allocator_po_alloc_index_is_stale( int $po_id ): bool {
                if ( $po_id <= 0 ) {
                        return true;
                }

                $built_at = (int) get_post_meta( $po_id, PO_META_ALLOC_INDEX_BUILT_AT, true );
                if ( $built_at <= 0 ) {
                        return true;
                }

                return ( time() - $built_at ) >= PO_ALLOC_INDEX_REFRESH_TTL;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_po_allocation_index' ) ) {
        /**
         * Retrieve the PO allocation index. If empty, attempt to rebuild from order item meta.
         *
         * @param int $po_id
         * @return array[] Each entry: ['order_id'=>int, 'item_id'=>int]
         */
        function lpr_allocator_get_po_allocation_index( int $po_id ): array {
                if ( $po_id <= 0 ) {
                        return array();
                }

                $meta_exists = metadata_exists( 'post', $po_id, PO_META_ALLOC_INDEX );
                $raw         = get_post_meta( $po_id, PO_META_ALLOC_INDEX, true );
                if ( ! is_array( $raw ) ) {
                        $raw = array();
                }

                $sanitized       = lpr_allocator_normalize_po_alloc_index( $raw );
                $needs_normalize = count( $sanitized ) !== count( $raw );

                if ( ! empty( $sanitized ) ) {
                        if ( $needs_normalize || lpr_allocator_po_alloc_index_is_stale( $po_id ) ) {
                                $rebuilt = lpr_allocator_normalize_po_alloc_index( lpr_allocator_rebuild_po_alloc_index( $po_id ) );

                                $sanitized = $rebuilt;

                                lpr_allocator_store_po_alloc_index( $po_id, $sanitized );
                        }

                        return array_values( $sanitized );
                }

                if ( ! $meta_exists || lpr_allocator_po_alloc_index_is_stale( $po_id ) ) {
                        // Legacy POs may have allocations on orders but no stored index; attempt a rebuild and cache the result.
                        $rebuilt = lpr_allocator_normalize_po_alloc_index( lpr_allocator_rebuild_po_alloc_index( $po_id ) );
                        if ( ! empty( $rebuilt ) ) {
                                lpr_allocator_store_po_alloc_index( $po_id, $rebuilt );
                                return array_values( $rebuilt );
                        }

                        lpr_allocator_store_po_alloc_index( $po_id, array() );
                        return array();
                }

                return array();
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_rebuild_po_alloc_index' ) ) {
        /**
         * Rebuild the allocation index for a PO by scanning order item meta for allocations pointing to it.
         *
         * @param int $po_id
         * @return array
         */
        function lpr_allocator_rebuild_po_alloc_index( int $po_id ): array {
                if ( $po_id <= 0 ) {
                        return array();
                }
                global $wpdb;
                if ( ! ( $wpdb instanceof \wpdb ) ) {
                        return array();
                }

                $meta_table  = $wpdb->prefix . 'woocommerce_order_itemmeta';
                $items_table = $wpdb->prefix . 'woocommerce_order_items';
                $like        = '%' . $wpdb->esc_like( '"po_id";i:' . (int) $po_id ) . '%';

                $sql   = $wpdb->prepare(
                        "SELECT im.order_item_id, oi.order_id, im.meta_value\n"
                        . "FROM {$items_table} oi\n"
                        . "INNER JOIN {$meta_table} im ON oi.order_item_id = im.order_item_id\n"
                        . "WHERE im.meta_key = %s AND im.meta_value LIKE %s",
                        ORDER_ITEM_META_ALLOCATIONS,
                        $like
                );
                $rows  = $wpdb->get_results( $sql, ARRAY_A );
                $index = array();

                if ( is_array( $rows ) ) {
                        foreach ( $rows as $row ) {
                                $oid       = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                                $item_id   = isset( $row['order_item_id'] ) ? absint( $row['order_item_id'] ) : 0;
                                $meta_val  = isset( $row['meta_value'] ) ? maybe_unserialize( $row['meta_value'] ) : array();
                                $has_match = false;

                                if ( $oid > 0 && $item_id > 0 && is_array( $meta_val ) ) {
                                        foreach ( $meta_val as $alloc_row ) {
                                                $po_match   = isset( $alloc_row['po_id'] ) ? (int) $alloc_row['po_id'] === $po_id : false;
                                                $row_status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                                $qty        = isset( $alloc_row['qty_allocated'] ) ? (int) $alloc_row['qty_allocated'] : 0;
                                                if ( $po_match && 'released' !== $row_status && $qty > 0 ) {
                                                        $has_match = true;
                                                        break;
                                                }
                                        }
                                }

                                if ( $has_match ) {
                                        $index[ $oid . ':' . $item_id ] = array(
                                                'order_id' => $oid,
                                                'item_id'  => $item_id,
                                        );
                                }
                        }
                }

                return array_values( $index );
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_index_po_allocation' ) ) {
        /**
         * Ensure the PO allocation index contains the given order/item pair.
         *
         * @param int $po_id
         * @param int $order_id
         * @param int $item_id
         * @return void
         */
        function lpr_allocator_index_po_allocation( int $po_id, int $order_id, int $item_id ): void {
                if ( $po_id <= 0 || $order_id <= 0 || $item_id <= 0 ) {
                        return;
                }

                $existing = lpr_allocator_get_po_allocation_index( $po_id );
                $key      = $order_id . ':' . $item_id;

                $map = array();
                foreach ( $existing as $entry ) {
                        $k = ( isset( $entry['order_id'] ) ? absint( $entry['order_id'] ) : 0 ) . ':' . ( isset( $entry['item_id'] ) ? absint( $entry['item_id'] ) : 0 );
                        if ( '0:0' !== $k ) {
                                $map[ $k ] = array(
                                        'order_id' => isset( $entry['order_id'] ) ? absint( $entry['order_id'] ) : 0,
                                        'item_id'  => isset( $entry['item_id'] ) ? absint( $entry['item_id'] ) : 0,
                                );
                        }
                }

                if ( ! isset( $map[ $key ] ) ) {
                        $map[ $key ] = array(
                                'order_id' => $order_id,
                                'item_id'  => $item_id,
                        );
                        lpr_allocator_store_po_alloc_index( $po_id, $map );
                }
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_recalculate_po_lines_from_allocations' ) ) {
        /**
         * Recompute qty_allocated for each PO line based on live allocations for orders in the PO's index.
         * Counts allocations on any non-cancelled/refunded/failed orders; ignores released rows.
         *
         * @param int   $po_id
         * @param array $lines
         * @return array
         */
        function lpr_allocator_recalculate_po_lines_from_allocations( int $po_id, array $lines ): array {
                if ( $po_id <= 0 ) {
                        return $lines;
                }

                $index    = lpr_allocator_get_po_allocation_index( $po_id );
                $meta_key = ORDER_ITEM_META_ALLOCATIONS;
                $active   = array(); // target_id => qty
                $valid    = array(); // rebuild index to drop stale entries.
                $exclude  = array( 'cancelled', 'refunded', 'failed', 'trash' );

                foreach ( $index as $row ) {
                        $order_id = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                        $item_id  = isset( $row['item_id'] ) ? absint( $row['item_id'] ) : 0;
                        if ( $order_id <= 0 || $item_id <= 0 ) {
                                continue;
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! ( $order instanceof \WC_Order ) ) {
                                continue;
                        }
                        if ( $order->has_status( $exclude ) ) {
                                continue; // do not count cancelled/refunded/failed orders.
                        }

                        $item = $order->get_item( $item_id );
                        if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                continue;
                        }

                        $allocs = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                continue;
                        }

                        $sum = 0;
                        foreach ( $allocs as $alloc_row ) {
                                $po_match   = isset( $alloc_row['po_id'] ) ? (int) $alloc_row['po_id'] === $po_id : false;
                                $row_status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                $qty        = isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                if ( $po_match && 'released' !== $row_status && $qty > 0 ) {
                                        $sum += $qty;
                                }
                        }

                        if ( $sum <= 0 ) {
                                continue;
                        }

                        $target_id = (int) $item->get_variation_id();
                        if ( $target_id <= 0 ) {
                                $target_id = (int) $item->get_product_id();
                        }
                        if ( $target_id <= 0 ) {
                                continue;
                        }

                        $active[ $target_id ] = ( $active[ $target_id ] ?? 0 ) + $sum;
                        $valid[ $order_id . ':' . $item_id ] = array(
                                'order_id' => $order_id,
                                'item_id'  => $item_id,
                        );
                }

                // Rebuild index to drop stale entries and to capture any new valid pairs we found.
                lpr_allocator_store_po_alloc_index( $po_id, $valid );

                // Apply available active allocations to PO lines in order.
                foreach ( $lines as &$line ) {
                        $variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
                        $product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
                        $target_id    = $variation_id > 0 ? $variation_id : $product_id;
                        $qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;

                        if ( $target_id <= 0 || $qty_ordered <= 0 ) {
                                $line['qty_allocated'] = 0;
                                continue;
                        }

                        $available = isset( $active[ $target_id ] ) ? (int) $active[ $target_id ] : 0;
                        $alloc     = min( $available, $qty_ordered );
                        $line['qty_allocated'] = $alloc;
                        $active[ $target_id ]  = max( 0, $available - $alloc );
                }
                unset( $line );

                return $lines;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_refresh_po_allocation_state' ) ) {
        /**
         * Ensure PO line and index tallies reflect the live allocation ledger before display.
         *
         * @param int $po_id
         * @return array Sanitized PO lines with refreshed qty_allocated values.
         */
        function lpr_allocator_refresh_po_allocation_state( int $po_id ): array {
                if ( $po_id <= 0 ) {
                        return array();
                }

                $lines = get_post_meta( $po_id, PO_META_LINES, true );
                if ( ! is_array( $lines ) || empty( $lines ) ) {
                        return array();
                }

                $updated = lpr_allocator_recalculate_po_lines_from_allocations( $po_id, $lines );

                if ( $updated !== $lines ) {
                        update_post_meta( $po_id, PO_META_LINES, $updated );
                }

                return $updated;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
        /**
         * When an order status changes, refresh qty_allocated on all POs that allocated its items.
         *
         * @param int $order_id
         * @return void
         */
        function lpr_allocator_reapply_po_allocations_for_order( int $order_id ): void {
                if ( $order_id <= 0 || ! function_exists( 'wc_get_order' ) ) {
                        return;
                }

                $order = wc_get_order( $order_id );
                if ( ! ( $order instanceof \WC_Order ) ) {
                        return;
                }

                $meta_key = ORDER_ITEM_META_ALLOCATIONS;
                $po_ids   = array();

                foreach ( $order->get_items( 'line_item' ) as $item ) {
                        if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                continue;
                        }
                        $allocs = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                continue;
                        }
                        foreach ( $allocs as $alloc_row ) {
                                $po_id = isset( $alloc_row['po_id'] ) ? (int) $alloc_row['po_id'] : 0;
                                if ( $po_id > 0 ) {
                                        $po_ids[ $po_id ] = true;
                                        lpr_allocator_index_po_allocation( $po_id, (int) $order_id, (int) $item->get_id() );
                                }
                        }
                }

                if ( empty( $po_ids ) ) {
                        return;
                }

                foreach ( array_keys( $po_ids ) as $po_id ) {
                        $lines = get_post_meta( $po_id, PO_META_LINES, true );
                        if ( ! is_array( $lines ) ) {
                                continue;
                        }
                        $updated = lpr_allocator_recalculate_po_lines_from_allocations( (int) $po_id, $lines );
                        update_post_meta( $po_id, PO_META_LINES, $updated );
                }
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_remove_po_allocations_from_orders' ) ) {
        /**
         * Remove all allocations pointing to a PO from order items and refresh dependent data.
         *
         * @param int $po_id
         * @return void
         */
        function lpr_allocator_remove_po_allocations_from_orders( int $po_id ): void {
                if ( $po_id <= 0 || ! function_exists( 'wc_get_order' ) ) {
                        return;
                }

                if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_po_allocation_index' ) ) {
                        return;
                }

                $index = lpr_allocator_get_po_allocation_index( $po_id );
                if ( empty( $index ) && function_exists( __NAMESPACE__ . '\lpr_allocator_rebuild_po_alloc_index' ) ) {
                        $index = lpr_allocator_rebuild_po_alloc_index( $po_id );
                }

                if ( empty( $index ) ) {
                        return;
                }

                $meta_key     = ORDER_ITEM_META_ALLOCATIONS;
                $needs_recalc = array();

                foreach ( $index as $entry ) {
                        $order_id = isset( $entry['order_id'] ) ? absint( $entry['order_id'] ) : 0;
                        $item_id  = isset( $entry['item_id'] ) ? absint( $entry['item_id'] ) : 0;

                        if ( $order_id <= 0 || $item_id <= 0 ) {
                                continue;
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! ( $order instanceof \WC_Order ) ) {
                                continue;
                        }

                        $item = $order->get_item( $item_id );
                        if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                continue;
                        }

                        if ( method_exists( $item, 'read_meta_data' ) ) {
                                $item->read_meta_data( true );
                        }

                        $allocs = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                continue;
                        }

                        $changed  = false;
                        $filtered = array();
                        foreach ( $allocs as $row ) {
                                $row_po_id = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                if ( $row_po_id === $po_id ) {
                                        $changed = true;
                                        continue;
                                }
                                $filtered[] = $row;
                        }

                        if ( $changed ) {
                                $item->update_meta_data( $meta_key, $filtered );
                                $item->save();
                                $needs_recalc[ $order_id ] = true;
                        }
                }

                if ( empty( $needs_recalc ) ) {
                        return;
                }

                foreach ( array_keys( $needs_recalc ) as $oid ) {
                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                lpr_allocator_reapply_po_allocations_for_order( (int) $oid );
                        }
                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                ETA::update_line_eta( (int) $oid );
                        }
                }
        }
}

add_action( 'woocommerce_order_status_changed', __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order', 10, 1 );

if ( ! class_exists( __NAMESPACE__ . '\Supplier_PO_CPT' ) ) {
	/**
	 * Registers Supplier PO CPT, custom statuses, admin columns, and metaboxes.
	 */
	class Supplier_PO_CPT {

		/**
		 * Prevent recursive save when updating status.
		 *
		 * @var bool
		 */
		protected static $saving = false;

		public static function init(): void {
			add_action( 'init', array( __CLASS__, 'register_statuses' ) );
			add_action( 'init', array( __CLASS__, 'register_cpt' ) );

			add_action( 'add_meta_boxes', array( __CLASS__, 'add_meta_boxes' ) );
                        add_action( 'save_post', array( __CLASS__, 'save_post' ), 10, 2 );

                        add_filter( 'manage_edit-' . CPT_SUPPLIER_PO . '_columns', array( __CLASS__, 'columns' ) );
                        add_action( 'manage_' . CPT_SUPPLIER_PO . '_posts_custom_column', array( __CLASS__, 'column_content' ), 10, 2 );

                        add_filter( 'display_post_states', array( __CLASS__, 'display_states' ), 10, 2 );

                        add_filter( 'request', array( __CLASS__, 'adjust_admin_request_statuses' ) );
                }

		public static function register_statuses(): void {
			$statuses = array(
				PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
				PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
				PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
			);

			foreach ( $statuses as $key => $label ) {
				if ( ! get_post_status_object( $key ) ) {
					register_post_status(
						$key,
						array(
							'label'                     => $label,
							'public'                    => false,
							'internal'                  => false,
							'exclude_from_search'       => true,
							'show_in_admin_all_list'    => true,
							'show_in_admin_status_list' => true,
							'label_count'               => _n_noop( "$label <span class=\"count\">(%s)</span>", "$label <span class=\"count\">(%s)</span>", 'lpr-backorder-allocator' ),
						)
					);
				}
			}
		}

		public static function register_cpt(): void {
			$labels = array(
				'name'               => __( 'Supplier POs', 'lpr-backorder-allocator' ),
				'singular_name'      => __( 'Supplier PO', 'lpr-backorder-allocator' ),
				'add_new'            => __( 'Add New', 'lpr-backorder-allocator' ),
				'add_new_item'       => __( 'Add New Supplier PO', 'lpr-backorder-allocator' ),
				'edit_item'          => __( 'Edit Supplier PO', 'lpr-backorder-allocator' ),
				'new_item'           => __( 'New Supplier PO', 'lpr-backorder-allocator' ),
				'all_items'          => __( 'Supplier POs', 'lpr-backorder-allocator' ),
				'view_item'          => __( 'View Supplier PO', 'lpr-backorder-allocator' ),
				'search_items'       => __( 'Search Supplier POs', 'lpr-backorder-allocator' ),
				'not_found'          => __( 'No Supplier POs found', 'lpr-backorder-allocator' ),
				'not_found_in_trash' => __( 'No Supplier POs found in Trash', 'lpr-backorder-allocator' ),
				'menu_name'          => __( 'Supplier POs', 'lpr-backorder-allocator' ),
			);

			$caps = array_fill_keys(
				array(
					'edit_post',
					'read_post',
					'delete_post',
					'edit_posts',
					'edit_others_posts',
					'publish_posts',
					'read_private_posts',
					'read',
					'delete_posts',
					'delete_private_posts',
					'delete_published_posts',
					'delete_others_posts',
					'edit_private_posts',
					'edit_published_posts',
					'create_posts',
				),
				'manage_woocommerce'
			);

			register_post_type(
				CPT_SUPPLIER_PO,
				array(
					'labels'              => $labels,
                                        'public'              => false,
                                        'show_ui'             => true,
                                        'show_in_menu'        => ADMIN_MENU_SLUG,
                                        'show_in_admin_bar'   => false,
                                        'show_in_rest'        => false,
					'has_archive'         => false,
					'exclude_from_search' => true,
					'rewrite'             => false,
					'map_meta_cap'        => false,
					'capabilities'        => $caps,
					'supports'            => array( 'title' ),
					'menu_icon'           => 'dashicons-clipboard',
				)
			);
		}

		public static function add_meta_boxes(): void {
			add_meta_box(
				'lpr_po_header',
				__( 'PO Header', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_header_metabox' ),
				CPT_SUPPLIER_PO,
				'normal',
				'high'
			);

			add_meta_box(
				'lpr_po_lines',
				__( 'PO Lines', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_lines_metabox' ),
				CPT_SUPPLIER_PO,
				'normal',
				'default'
			);
		}

		public static function render_header_metabox( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_header_action', 'lpr_po_header_nonce' );

                        $supplier  = get_post_meta( $post->ID, PO_META_SUPPLIER_NAME, true );
                        $po_number = get_post_meta( $post->ID, PO_META_PO_NUMBER, true );
                        $eta       = lpr_allocator_sanitize_ymd( (string) get_post_meta( $post->ID, PO_META_ETA_DATE, true ) );
                        $note      = (string) get_post_meta( $post->ID, PO_META_NOTE, true );
                        $status    = in_array( $post->post_status, array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED ), true ) ? $post->post_status : PO_STATUS_OPEN;

                        ?>
                        <style>
                                #lpr_po_header .lpr-grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
                                #lpr_po_header .lpr-grid .field { display:flex; flex-direction:column; }
                                #lpr_po_header input[type="text"], #lpr_po_header select { max-width: 420px; }
                                #lpr_po_header .lpr-grid .form-field { display:flex; flex-direction:column; margin:0; }
                                #lpr_po_header .lpr-grid .form-field .short { max-width: 420px; }
                                #lpr_po_header .lpr-grid .field-note { grid-column: 1 / -1; }
                        </style>
                        <div class="lpr-grid">
                                <div class="field">
                                        <label for="lpr_supplier_name"><strong><?php echo esc_html__( 'Supplier Name', 'lpr-backorder-allocator' ); ?></strong></label>
                                        <input type="text" id="lpr_supplier_name" name="lpr_supplier_name" value="<?php echo esc_attr( (string) $supplier ); ?>" />
				</div>
				<div class="field">
					<label for="lpr_po_number"><strong><?php echo esc_html__( 'PO Number', 'lpr-backorder-allocator' ); ?></strong></label>
					<input type="text" id="lpr_po_number" name="lpr_po_number" value="<?php echo esc_attr( (string) $po_number ); ?>" />
				</div>
                                <div class="field">
                                        <?php
                                        woocommerce_wp_text_input(
                                                array(
                                                        'id'                => 'lpr_eta_date',
                                                        'name'              => 'lpr_eta_date',
                                                        'type'              => 'text',
                                                        'label'             => __( 'Default ETA (dd-mm-yyyy)', 'lpr-backorder-allocator' ),
                                                        'class'             => 'short',
                                                        'value'             => $eta,
                                                        'custom_attributes' => array(
                                                                'pattern'     => '\\d{2}-\\d{2}-\\d{4}',
                                                                'placeholder' => 'DD-MM-YYYY',
                                                        ),
                                                )
                                        );
                                        ?>
                                </div>
				<div class="field">
					<label for="lpr_po_status"><strong><?php echo esc_html__( 'PO Status', 'lpr-backorder-allocator' ); ?></strong></label>
					<select id="lpr_po_status" name="lpr_po_status">
						<?php
						$opts = array(
							PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
							PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
							PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
						);
						foreach ( $opts as $val => $label ) {
							printf(
								'<option value="%s"%s>%s</option>',
								esc_attr( $val ),
								selected( $status, $val, false ),
								esc_html( $label )
							);
                                                }
                                                ?>
                                        </select>
                                </div>
                                <div class="field field-note">
                                        <label for="lpr_po_note"><strong><?php echo esc_html__( 'PO Note', 'lpr-backorder-allocator' ); ?></strong></label>
                                        <textarea id="lpr_po_note" name="lpr_po_note" rows="3" style="max-width:700px; width:100%;"><?php echo esc_textarea( $note ); ?></textarea>
                                        <p class="description"><?php echo esc_html__( 'Add internal notes about this purchase order (kept in the admin only).', 'lpr-backorder-allocator' ); ?></p>
                                </div>
                        </div>
                        <?php
                }

		public static function render_lines_metabox( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_lines_action', 'lpr_po_lines_nonce' );
			$lines = get_post_meta( $post->ID, PO_META_LINES, true );
			if ( ! is_array( $lines ) ) {
				$lines = array();
			}
			?>
			<style>
				#lpr_po_lines table { width: 100%; border-collapse: collapse; }
				#lpr_po_lines th, #lpr_po_lines td { border-bottom: 1px solid #ddd; padding: 6px; text-align:left; }
				#lpr_po_lines .actions { text-align: right; margin-top: 8px; }
				#lpr_po_lines input[type="number"] { width: 100px; }
				#lpr_po_lines input[type="text"] { width: 160px; }
			</style>
			<table class="widefat striped" id="lpr-po-lines-table">
				<thead>
					<tr>
						<th><?php echo esc_html__( 'Product ID', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Variation ID', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Ordered', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                <th><?php echo esc_html__( 'ETA Override (dd-mm-yyyy)', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Received', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<?php
					$idx = 0;
					foreach ( $lines as $line ) :
						$product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
						$variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
						$qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
						$qty_alloc    = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
                                                $eta_override = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
						$qty_recv     = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
						?>
						<tr>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][product_id]" value="<?php echo esc_attr( $product_id ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][variation_id]" value="<?php echo esc_attr( $variation_id ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_ordered]" value="<?php echo esc_attr( $qty_ordered ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_allocated]" value="<?php echo esc_attr( $qty_alloc ); ?>" /></td>
                                                        <td><input type="text" class="short" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][eta_override]" value="<?php echo esc_attr( $eta_override ); ?>" placeholder="DD-MM-YYYY" pattern="\d{2}-\d{2}-\d{4}" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_received]" value="<?php echo esc_attr( $qty_recv ); ?>" /></td>
							<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></button></td>
						</tr>
						<?php
						$idx++;
					endforeach;
					?>
				</tbody>
			</table>
			<div class="actions">
				<button type="button" class="button button-secondary" id="lpr-add-line"><?php echo esc_html__( 'Add Line', 'lpr-backorder-allocator' ); ?></button>
			</div>
			<script>
				(function(){
					const table = document.getElementById('lpr-po-lines-table').getElementsByTagName('tbody')[0];
					const addBtn = document.getElementById('lpr-add-line');
					function nextIndex(){
						let max = -1;
						table.querySelectorAll('tr').forEach(function(tr){
							const m = tr.querySelector('input[name^="lpr_po_lines["]')?.name.match(/^lpr_po_lines\[(\d+)\]/);
							if(m){ max = Math.max(max, parseInt(m[1], 10)); }
						});
						return max + 1;
					}
					function onRemoveClick(e){
						if(e.target && e.target.classList.contains('lpr-remove-line')){
							e.preventDefault();
							const tr = e.target.closest('tr');
							if(tr){ tr.remove(); }
						}
					}
					addBtn.addEventListener('click', function(e){
						e.preventDefault();
						const i = nextIndex();
						const tr = document.createElement('tr');
tr.innerHTML =
'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][product_id]" value="" /></td>'+
'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][variation_id]" value="" /></td>'+
'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_ordered]" value="0" /></td>'+
'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_allocated]" value="0" /></td>'+
'<td><input type="text" class="short" name="lpr_po_lines['+i+'][eta_override]" value="" placeholder="DD-MM-YYYY" pattern="\\d{2}-\\d{2}-\\d{4}" /></td>'+
'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_received]" value="0" /></td>'+
'<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_js( __( 'Remove', 'lpr-backorder-allocator' ) ); ?></button></td>';
table.appendChild(tr);
                                        });
					table.addEventListener('click', onRemoveClick);
				})();
			</script>
			<p class="description">
				<?php echo esc_html__( 'Provide either Product ID or Variation ID for each line. Received defaults to 0. Allocation is a ledger only; no stock writes.', 'lpr-backorder-allocator' ); ?>
			</p>
			<?php
		}

		public static function save_post( int $post_id, \WP_Post $post ): void {
			if ( self::$saving ) {
				return;
			}
			if ( CPT_SUPPLIER_PO !== $post->post_type ) {
				return;
			}
			// Bail on autosave/revision.
			if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) {
				return;
			}
			if ( wp_is_post_revision( $post_id ) ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}

			// Header save.
			if ( isset( $_POST['lpr_po_header_nonce'] ) && wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_header_nonce'] ) ), 'lpr_po_header_action' ) ) {
                                $supplier  = isset( $_POST['lpr_supplier_name'] ) ? sanitize_text_field( wp_unslash( $_POST['lpr_supplier_name'] ) ) : '';
                                $po_number = isset( $_POST['lpr_po_number'] ) ? sanitize_text_field( wp_unslash( $_POST['lpr_po_number'] ) ) : '';
                                $eta       = isset( $_POST['lpr_eta_date'] ) ? lpr_allocator_sanitize_ymd( wp_unslash( $_POST['lpr_eta_date'] ) ) : '';
                                $note      = isset( $_POST['lpr_po_note'] ) ? sanitize_textarea_field( wp_unslash( $_POST['lpr_po_note'] ) ) : '';
                                $status    = isset( $_POST['lpr_po_status'] ) ? sanitize_key( wp_unslash( $_POST['lpr_po_status'] ) ) : PO_STATUS_OPEN;

                                update_post_meta( $post_id, PO_META_SUPPLIER_NAME, $supplier );
                                update_post_meta( $post_id, PO_META_PO_NUMBER, $po_number );
                                update_post_meta( $post_id, PO_META_ETA_DATE, $eta );
                                update_post_meta( $post_id, PO_META_NOTE, $note );

				$allowed_status = array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED );
				if ( in_array( $status, $allowed_status, true ) && $post->post_status !== $status ) {
					self::$saving = true;
					remove_action( 'save_post', array( __CLASS__, 'save_post' ), 10 );
					wp_update_post(
						array(
							'ID'          => $post_id,
							'post_status' => $status,
						)
					);
					add_action( 'save_post', array( __CLASS__, 'save_post' ), 10, 2 );
					self::$saving = false;
				}
			}

			// Lines save.
                        if ( isset( $_POST['lpr_po_lines_nonce'] ) && wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_lines_nonce'] ) ), 'lpr_po_lines_action' ) ) {
                                $raw_lines = isset( $_POST['lpr_po_lines'] ) ? (array) $_POST['lpr_po_lines'] : array();
                                $clean     = lpr_allocator_sanitize_po_lines_input( $raw_lines );
                                $clean     = lpr_allocator_recalculate_po_lines_from_allocations( $post_id, $clean );
                                update_post_meta( $post_id, PO_META_LINES, $clean );
                        }

                        $po_number_for_log = (string) get_post_meta( $post_id, PO_META_PO_NUMBER, true );
                        $created_marker    = (string) get_post_meta( $post_id, '_lpr_po_created_at', true );

                        if ( '' === $created_marker && ! in_array( $post->post_status, array( 'auto-draft', 'trash' ), true ) ) {
                                $reason = __( 'Supplier PO saved via admin UI.', 'lpr-backorder-allocator' );

                                update_post_meta( $post_id, '_lpr_po_created_at', current_time( 'mysql' ) );

                                lpr_allocator_log_event(
                                        'po_created',
                                        array(
                                                'po_id'     => $post_id,
                                                'po_number' => $po_number_for_log,
                                                'status'    => $post->post_status,
                                                'reason'    => $reason,
                                        )
                                );
                        }
                }

		public static function columns( array $columns ): array {
			$new = array();
			$new['cb']        = isset( $columns['cb'] ) ? $columns['cb'] : '<input type="checkbox" />';
			$new['title']     = __( 'Title', 'lpr-backorder-allocator' );
			$new['po_number'] = __( 'PO #', 'lpr-backorder-allocator' );
			$new['supplier']  = __( 'Supplier', 'lpr-backorder-allocator' );
			$new['eta']       = __( 'ETA', 'lpr-backorder-allocator' );
			$new['lines']     = __( 'Lines', 'lpr-backorder-allocator' );
			$new['allocated'] = __( 'Allocated', 'lpr-backorder-allocator' );
			$new['po_status'] = __( 'Status', 'lpr-backorder-allocator' );
			$new['date']      = isset( $columns['date'] ) ? $columns['date'] : __( 'Date', 'lpr-backorder-allocator' );
			return $new;
		}

                public static function column_content( string $column, int $post_id ): void {
                        switch ( $column ) {
                                case 'po_number':
                                        $po = (string) get_post_meta( $post_id, PO_META_PO_NUMBER, true );
                                        echo esc_html( $po );
					break;
				case 'supplier':
					$supplier = (string) get_post_meta( $post_id, PO_META_SUPPLIER_NAME, true );
					echo esc_html( $supplier );
					break;
				case 'eta':
					$eta = (string) get_post_meta( $post_id, PO_META_ETA_DATE, true );
					echo esc_html( $eta );
					break;
				case 'lines':
					$lines = get_post_meta( $post_id, PO_META_LINES, true );
					if ( ! is_array( $lines ) ) {
						$lines = array();
					}
					echo esc_html( (string) count( $lines ) );
					break;
				case 'allocated':
					$lines = get_post_meta( $post_id, PO_META_LINES, true );
					$sum   = 0;
					if ( is_array( $lines ) ) {
						foreach ( $lines as $l ) {
							$sum += isset( $l['qty_allocated'] ) ? max( 0, (int) $l['qty_allocated'] ) : 0;
						}
					}
					echo esc_html( (string) $sum );
					break;
				case 'po_status':
					$st = get_post_status( $post_id );
					$obj = get_post_status_object( $st );
					echo esc_html( $obj && isset( $obj->label ) ? $obj->label : $st );
					break;
                        }
                }

                /**
                 * Ensure the list table "All" view includes custom PO statuses.
                 */
                public static function adjust_admin_request_statuses( array $vars ): array {
                        if ( ! is_admin() || ( $vars['post_type'] ?? '' ) !== CPT_SUPPLIER_PO ) {
                                return $vars;
                        }

                        $requested_status = isset( $vars['post_status'] ) ? (string) $vars['post_status'] : '';
                        if ( '' !== $requested_status && 'all' !== $requested_status ) {
                                return $vars;
                        }

                        $vars['post_status'] = array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED, 'publish', 'draft', 'pending', 'private' );
                        return $vars;
                }

                public static function display_states( array $states, \WP_Post $post ): array {
                        if ( CPT_SUPPLIER_PO !== $post->post_type ) {
                                return $states;
                        }
                        $map = array(
				PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
				PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
				PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
			);
			if ( isset( $map[ $post->post_status ] ) ) {
				$states[] = $map[ $post->post_status ];
			}
			return $states;
		}
	}
	Supplier_PO_CPT::init();
}

/* SELF-CHECK:
- Added CPT `supplier_po` (admin-only UI under WooCommerce menu), custom statuses open/partial/closed via register_post_status.
- Header meta keys: _lpr_supplier_name, _lpr_po_number, _lpr_eta_date; Lines meta: _lpr_po_lines (array with product_id|variation_id, qty_ordered, qty_allocated, eta_override, qty_received default 0).
- Implemented two metaboxes: PO Header (includes status select) and PO Lines (add/remove rows with JS). Full nonce + capability checks.
- Admin list columns: PO #, Supplier, ETA, Lines, Allocated, Status. Values computed without raw SQL; products validated via Woo CRUD.
- No stock writes; HPOS-safe; no wildcard meta queries; bails on frontend due to early admin/cron check; all declarations guarded; no re-declarations of prior batch elements.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() && ! lpr_allocator_is_incoming_request() ) {
        return;
}

if ( ! class_exists( __NAMESPACE__ . '\Backorder' ) ) {
	/**
	 * Backorder detection utilities.
	 */
	class Backorder {

		/**
		 * Determine if an order item needs allocation.
		 *
                 * True when:
                 * - Order status âˆˆ settings order_statuses, and
                 * - Order item meta "Backordered" (or its translated/raw variants) > 0
                 *   (force allocation meta bypasses this)
		 *
		 * @param \WC_Order_Item_Product $item
		 * @return bool
		 */
		public static function needs_allocation( \WC_Order_Item_Product $item ): bool {
			if ( ! $item instanceof \WC_Order_Item_Product ) {
				return false;
			}

			$order_id = (int) $item->get_order_id();
			if ( $order_id <= 0 || ! function_exists( 'wc_get_order' ) ) {
				return false;
			}
                        $order = wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                return false;
                        }

			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$status   = $order->get_status(); // bare slug like 'processing'
			if ( empty( $settings['order_statuses'] ) || ! in_array( $status, (array) $settings['order_statuses'], true ) ) {
				return false;
			}

                        $force_qty = (int) $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation', true );
                        if ( $force_qty > 0 ) {
                                return true;
                        }

                        // Detect backordered amount from order-time meta, not current product stock state.
                        $meta_backordered = self::get_backordered_qty( $item );

                        return ( $meta_backordered > 0 );
                }

                /**
                 * Determine the backordered quantity recorded on the line item.
                 *
                 * Uses both the raw meta keys and the localized WooCommerce label
                 * to catch translated stores (e.g., Norwegian "Restbestilt").
                 *
                 * @param \WC_Order_Item_Product $item
                 * @return int
                 */
                public static function get_backordered_qty( \WC_Order_Item_Product $item ): int {
                        if ( ! $item instanceof \WC_Order_Item_Product ) {
                                return 0;
                        }

                        $localized = __( 'Backordered', 'woocommerce' );
                        $keys      = array( 'Backordered', '_backordered', 'backordered' );

                        if ( is_string( $localized ) && '' !== $localized && ! in_array( $localized, $keys, true ) ) {
                                $keys[] = $localized;
                        }

                        // In cron or CLI contexts, the site locale may differ from the locale
                        // used when the order was created (e.g., orders in Norwegian with cron
                        // running in en_US). Try to add the order's locale translation as well
                        // so we can read the meta key that was saved at checkout.
                        $order_locale = '';
                        $order_id     = (int) $item->get_order_id();
                        if ( $order_id > 0 && function_exists( 'wc_get_order' ) ) {
                                $order = wc_get_order( $order_id );
                                if ( $order instanceof \WC_Order ) {
                                        $order_locale = (string) $order->get_meta( '_locale' );
                                }
                        }

                        if ( '' !== $order_locale && function_exists( 'switch_to_locale' ) && function_exists( 'restore_previous_locale' ) ) {
                                $current_locale = function_exists( 'determine_locale' ) ? determine_locale() : get_locale();
                                if ( $current_locale !== $order_locale ) {
                                        switch_to_locale( $order_locale );
                                        $order_localized = __( 'Backordered', 'woocommerce' );
                                        restore_previous_locale();

                                        if ( is_string( $order_localized ) && '' !== $order_localized && ! in_array( $order_localized, $keys, true ) ) {
                                                $keys[] = $order_localized;
                                        }
                                }
                        }

                        $meta_backordered = 0;
                        foreach ( array_unique( $keys ) as $k ) {
                                $v = $item->get_meta( $k, true );
                                if ( '' !== $v && null !== $v ) {
                                        $meta_backordered = max( $meta_backordered, (int) $v );
                                }
                        }

                        return max( 0, $meta_backordered );
                }
        }
}

if ( ! class_exists( __NAMESPACE__ . '\ETA' ) ) {
	/**
	 * ETA computation & persistence.
	 */
	class ETA {

		/**
		 * Re-entrancy guard.
		 * @var bool
		 */
		protected static $updating = false;

		/**
		 * Compute earliest ETA over non-released allocations for each order line
		 * and persist to ORDER_ITEM_META_LINE_ETA (d-m-Y).
		 *
		 * @param int $order_id
		 * @return void
		 */
		
		/**
 * Get the current ETA for this item from the given PO:
 * - If the PO has a line for this product/variation with an 'eta_override', use that.
 * - Otherwise, use the PO header ETA.
 */
public static function live_eta_from_po( int $po_id, \WC_Order_Item_Product $item ): string {
	if ( $po_id <= 0 || ! ( $item instanceof \WC_Order_Item_Product ) ) {
		return '';
	}
	$target_id = (int) $item->get_variation_id();
	if ( $target_id <= 0 ) {
		$target_id = (int) $item->get_product_id();
	}
	if ( $target_id <= 0 ) {
		return '';
	}

	$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
	if ( is_array( $lines ) ) {
		foreach ( $lines as $line ) {
			$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
			$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
			$tid = $vid > 0 ? $vid : $pid;
			if ( $tid === $target_id ) {
				$eta_override = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
				if ( '' !== $eta_override ) {
					return $eta_override;
				}
				break; // matching line found but no override - fall back to header ETA
			}
		}
	}

	$po_eta = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true );
	return lpr_allocator_sanitize_ymd( (string) $po_eta );
}
		// inside class ETA { ... }

// REPLACE update_line_eta() with this version
public static function update_line_eta( int $order_id ): void {
	if ( self::$updating ) {
		return;
	}
	if ( ! function_exists( 'wc_get_order' ) || $order_id <= 0 ) {
		return;
	}

        $order = wc_get_order( $order_id );
        if ( ! $order instanceof \WC_Order ) {
                return;
        }

        // Do not mutate completed orders (already shipped).
        if ( $order->has_status( 'completed' ) ) {
                return;
        }

	self::$updating = true;

	$items    = $order->get_items( 'line_item' );
	$changes  = array(); // collect changes to email once per order

	foreach ( $items as $item ) {
		if ( ! $item instanceof \WC_Order_Item_Product ) {
			continue;
		}
		$allocs = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
		if ( ! is_array( $allocs ) ) {
			$allocs = array();
		}

		$etas = array();

		foreach ( $allocs as $row ) {
			$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
			if ( 'released' === $status ) {
				continue;
			}

			$eta   = '';
			$po_id = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;

			if ( $po_id > 0 ) {
				// Always use the current PO value (line override > PO header)
				$eta = self::live_eta_from_po( $po_id, $item );
			} else {
				// Non-PO allocations: use stored row ETA if present
				if ( ! empty( $row['eta'] ) ) {
					$eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
				}
			}

			if ( '' !== $eta ) {
				$etas[] = $eta;
			}
		}

		$new_eta = '';
                if ( ! empty( $etas ) ) {
                        usort(
                                $etas,
                                static function ( $a, $b ) {
                                        return lpr_allocator_compare_dates( (string) $a, (string) $b );
                                }
                        );
                        $new_eta = (string) $etas[0];
                }

		$meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';
		$prev_eta = (string) $item->get_meta( $meta_key, true );

		if ( $prev_eta !== $new_eta ) {
			// Persist new ETA
			$item->update_meta_data( $meta_key, $new_eta );
			$item->save();

			// Private order note (always)
			$product = $item->get_product();
			$sku     = $product instanceof \WC_Product ? $product->get_sku() : '';
                        $from    = $prev_eta !== '' ? $prev_eta : 'â€”';
                        $to      = $new_eta  !== '' ? $new_eta  : 'â€”';
                        $from_h  = $prev_eta !== '' ? lpr_allocator_format_store_date( $prev_eta ) : 'â€”';
                        $to_h    = $new_eta !== '' ? lpr_allocator_format_store_date( $new_eta ) : 'â€”';

			$order->add_order_note(
				sprintf(
					/* translators: 1: item name, 2: SKU, 3: from ETA, 4: to ETA */
					__( 'ETA changed for %1$s%2$s: %3$s â†’ %4$s.', 'lpr-backorder-allocator' ),
					$item->get_name(),
					$sku ? ' [' . $sku . ']' : '',
                                        $from_h,
                                        $to_h
                                ),
                                false, // private
                                true
                        );

			// Queue for optional customer email (weâ€™ll send once per order)
                        $changes[] = array(
                                'name' => $item->get_name() . ( $sku ? ' [' . $sku . ']' : '' ),
                                'prev' => $from_h,
                                'new'  => $to_h,
                        );
                }
        }

	// Optional email once per order
	if ( ! empty( $changes ) ) {
		self::maybe_email_eta_changes( $order, $changes );
	}

	self::$updating = false;
}

                protected static function maybe_email_eta_changes( \WC_Order $order, array $changes ): void {
                        self::send_eta_email( $order, $changes );
                }

                /**
                 * Send an ETA email for the provided rows.
                 *
                 * @param \WC_Order $order
                 * @param array     $rows
                 * @param bool      $respect_setting
                 * @return bool
                 */
                public static function send_eta_email( \WC_Order $order, array $rows, bool $respect_setting = true, array $overview_rows = array() ): bool {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();

                        if ( $respect_setting && empty( $settings['inform_customer_eta'] ) ) {
                                return false;
                        }

                        if ( empty( $overview_rows ) && class_exists( __NAMESPACE__ . '\Order_Allocations_Metabox' ) ) {
                                $overview_rows = Order_Allocations_Metabox::build_eta_email_rows( $order );
                        }

                        if ( empty( $rows ) && empty( $overview_rows ) ) {
                                return false;
                        }

                        $email = $order->get_billing_email();
                        if ( ! $email ) {
                                return false;
                        }

                        $tokens   = self::email_tokens_for_order( $order );
                        $compiled = self::build_eta_email_content( $rows, $settings, $tokens, $overview_rows, $order );
                        $subject  = $compiled['subject'] ?? '';
                        $body     = $compiled['body'] ?? '';

                        if ( '' === trim( (string) $subject ) || '' === trim( (string) $body ) ) {
                                return false;
                        }

                        if ( function_exists( 'wc_mail' ) ) {
                                wc_mail( $email, $subject, $body, array( 'Content-Type: text/html; charset=UTF-8' ) );
                        } else {
                                wp_mail( $email, $subject, $body, array( 'Content-Type: text/html; charset=UTF-8' ) );
                        }

                        $note = sprintf( /* translators: %s: customer email */ __( 'Backorder ETA email sent to %s.', 'lpr-backorder-allocator' ), $email );
                        $order->add_order_note( $note, false, true );

                        $eta_email_meta_key = defined( __NAMESPACE__ . '\\ORDER_META_LAST_ETA_EMAIL' ) ? ORDER_META_LAST_ETA_EMAIL : '_lpr_last_eta_email';
                        $order->update_meta_data( $eta_email_meta_key, time() );
                        $order->save();

                        return true;
                }

                /**
                 * Build the compiled subject/body for an ETA email without sending.
                 */
                public static function build_eta_email_preview( \WC_Order $order, array $overview_rows = array() ): array {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();

                        if ( empty( $overview_rows ) && class_exists( __NAMESPACE__ . '\Order_Allocations_Metabox' ) ) {
                                $overview_rows = Order_Allocations_Metabox::build_eta_email_rows( $order );
                        }

                        if ( empty( $overview_rows ) ) {
                                return array();
                        }

                        $tokens   = self::email_tokens_for_order( $order );
                        $compiled = self::build_eta_email_content( array(), $settings, $tokens, $overview_rows, $order );

                        $subject = isset( $compiled['subject'] ) ? (string) $compiled['subject'] : '';
                        $body    = isset( $compiled['body'] ) ? (string) $compiled['body'] : '';

                        if ( '' === trim( $subject ) || '' === trim( $body ) ) {
                                return array();
                        }

                        return array(
                                'subject' => $subject,
                                'body'    => $body,
                        );
                }

                /**
                 * Build the subject and HTML body for an ETA email.
                 *
                 * @param array $rows
                 * @param array $settings
                 * @param array $tokens
                 * @return array{subject:string,body:string}
                 */
                public static function build_eta_email_content( array $rows, array $settings, array $tokens, array $overview_rows = array(), ?\WC_Order $order = null ): array {
                        $defaults = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::defaults() : array();
                        $settings = array_replace( $defaults, $settings );

                        $subject_tpl   = (string) ( $settings['eta_email_subject'] ?? ( $defaults['eta_email_subject'] ?? __( 'Your order ETA has been updated', 'lpr-backorder-allocator' ) ) );
                        $intro_tpl     = (string) ( $settings['eta_email_intro'] ?? ( $defaults['eta_email_intro'] ?? __( 'Weâ€™ve updated the expected arrival for the items below:', 'lpr-backorder-allocator' ) ) );
                        $logo          = (string) ( $settings['brand_logo_url']       ?? '' );
                        $color         = (string) ( $settings['brand_primary_color']  ?? '#1a1a1a' );
                        $foot          = (string) ( $settings['email_footer_text_no'] ?? '' );
                        $disclaimer    = (string) ( $settings['email_eta_disclaimer'] ?? ( $defaults['email_eta_disclaimer'] ?? '' ) );
                        $progress_head = (string) ( $settings['email_progress_heading'] ?? ( $defaults['email_progress_heading'] ?? '' ) );
                        $progress_sub  = (string) ( $settings['email_progress_subheading'] ?? ( $defaults['email_progress_subheading'] ?? '' ) );
                        $progress_ring = (string) ( $settings['email_progress_complete_label'] ?? ( $defaults['email_progress_complete_label'] ?? '%complete%%' ) );
                        $status_done   = (string) ( $settings['email_status_done_label'] ?? ( $defaults['email_status_done_label'] ?? __( 'Completed', 'lpr-backorder-allocator' ) ) );
                        $status_pending = (string) ( $settings['email_status_pending_label'] ?? ( $defaults['email_status_pending_label'] ?? __( 'Pending', 'lpr-backorder-allocator' ) ) );
                        $updated_heading   = (string) ( $settings['email_updated_heading'] ?? ( $defaults['email_updated_heading'] ?? __( 'Updated items', 'lpr-backorder-allocator' ) ) );
                        $overview_heading  = (string) ( $settings['email_overview_heading'] ?? ( $defaults['email_overview_heading'] ?? __( 'Backordered items', 'lpr-backorder-allocator' ) ) );
                        $th_item           = (string) ( $settings['email_table_heading_item'] ?? ( $defaults['email_table_heading_item'] ?? __( 'Item', 'lpr-backorder-allocator' ) ) );
                        $th_prev           = (string) ( $settings['email_table_heading_previous'] ?? ( $defaults['email_table_heading_previous'] ?? __( 'Previous', 'lpr-backorder-allocator' ) ) );
                        $th_new            = (string) ( $settings['email_table_heading_new_eta'] ?? ( $defaults['email_table_heading_new_eta'] ?? __( 'New ETA', 'lpr-backorder-allocator' ) ) );
                        $status_labels     = array(
                                'order' => (string) ( $settings['email_status_label_order_placed'] ?? ( $defaults['email_status_label_order_placed'] ?? __( 'Order placed', 'lpr-backorder-allocator' ) ) ),
                                'po'    => (string) ( $settings['email_status_label_po_allocated'] ?? ( $defaults['email_status_label_po_allocated'] ?? __( 'PO allocated', 'lpr-backorder-allocator' ) ) ),
                                'eta'   => (string) ( $settings['email_status_label_eta_received'] ?? ( $defaults['email_status_label_eta_received'] ?? __( 'ETA received', 'lpr-backorder-allocator' ) ) ),
                                'delivery' => (string) ( $settings['email_status_label_delivery'] ?? ( $defaults['email_status_label_delivery'] ?? __( 'Estimated delivery', 'lpr-backorder-allocator' ) ) ),
                        );
                        $unallocated_label = (string) ( $settings['email_unallocated_label'] ?? ( $defaults['email_unallocated_label'] ?? __( 'Unallocated', 'lpr-backorder-allocator' ) ) );

                        $subject = self::apply_email_tokens( $subject_tpl, $tokens );
                        $intro   = self::apply_email_tokens( $intro_tpl, $tokens );

                        $logo_html = $logo ? '<div style="margin-bottom:12px;"><img src="' . esc_url( $logo ) . '" style="max-height:40px;" alt="" /></div>' : '';

                        $body  = '<div style="font-family:Arial,Helvetica,sans-serif;">' . $logo_html;
                        $body .= '<h2 style="color:' . esc_attr( $color ) . ';margin:0 0 12px 0;">' . esc_html( $subject ) . '</h2>';
                        if ( '' !== trim( (string) $intro ) ) {
                                $body .= '<p>' . wp_kses_post( $intro ) . '</p>';
                        }

                        $progress = self::build_progress_steps( $order, $overview_rows, $status_labels, $unallocated_label, $status_done, $status_pending );
                        if ( ! empty( $progress['steps'] ) ) {
                                $body .= self::render_progress_block( $progress, $color, $progress_head, $progress_sub, $progress_ring, $status_done, $status_pending );
                        }

                        if ( ! empty( $rows ) ) {
                                $body .= '<h3 style="margin:16px 0 8px 0;">' . esc_html( $updated_heading ) . '</h3>';
                                $body .= self::render_eta_table( $rows, $th_item, $th_prev, $th_new, $unallocated_label );
                        }

                        if ( ! empty( $overview_rows ) ) {
                                $body .= '<h3 style="margin:16px 0 8px 0;">' . esc_html( $overview_heading ) . '</h3>';
                                $body .= self::render_backorder_overview( $overview_rows, $th_item, $th_new, $unallocated_label );
                        }

                        if ( '' !== trim( (string) $disclaimer ) ) {
                                $body .= '<p style="margin-top:12px;color:#475569;font-size:12px;font-style:italic;">' . wp_kses_post( $disclaimer ) . '</p>';
                        }

                        if ( $foot ) {
                                $body .= '<p style="margin-top:16px;color:#777;font-size:12px;">' . wp_kses_post( $foot ) . '</p>';
                        }
                        $body .= '</div>';

                        return array(
                                'subject' => $subject,
                                'body'    => $body,
                        );
                }

                /**
                 * Build progress metadata for the email ring.
                 */
                protected static function build_progress_steps( ?\WC_Order $order, array $overview_rows, array $labels, string $unallocated_label, string $done_label, string $pending_label ): array {
                        $order_date          = '';
                        $has_allocs          = false;
                        $backorder_lines     = 0;
                        $allocated_lines     = 0;
                        $full_allocated      = 0;
                        $partial_allocated   = 0;
                        $eta_dates           = array();
                        $eta_label_fallback  = '';
                        $eta_display         = $unallocated_label;
                        $force_key           = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation';

                        if ( $order instanceof \WC_Order ) {
                                $created = $order->get_date_created();
                                if ( $created ) {
                                        $order_date = function_exists( 'wc_format_datetime' ) ? wc_format_datetime( $created, wc_date_format() ) : $created->date_i18n( get_option( 'date_format', 'Y-m-d' ) );
                                }

                                foreach ( $order->get_items( 'line_item' ) as $item ) {
                                        if ( ! $item instanceof \WC_Order_Item_Product ) {
                                                continue;
                                        }

                                        $force_qty   = (int) $item->get_meta( $force_key, true );
                                        $needs_alloc = class_exists( __NAMESPACE__ . '\\Backorder' ) ? Backorder::needs_allocation( $item ) : false;
                                        $desired     = function_exists( __NAMESPACE__ . '\\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : max( 0, (int) $item->get_quantity() );
                                        $allocated   = function_exists( __NAMESPACE__ . '\\lpr_allocator_get_item_allocated_active' ) ? lpr_allocator_get_item_allocated_active( $item ) : 0;

                                        if ( $needs_alloc || $force_qty > 0 || $desired > 0 ) {
                                                $backorder_lines++;
                                                if ( $allocated > 0 ) {
                                                        $allocated_lines++;
                                                        $has_allocs = true;
                                                }
                                                $target_qty = max( $desired, $force_qty );
                                                if ( $target_qty > 0 && $allocated >= $target_qty ) {
                                                        $full_allocated++;
                                                } elseif ( $allocated > 0 ) {
                                                        $partial_allocated++;
                                                }
                                        }

                                        $eta_val = (string) $item->get_meta( defined( __NAMESPACE__ . '\\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta', true );
                                        if ( '' !== trim( $eta_val ) && '' === $eta_label_fallback ) {
                                                $eta_label_fallback = $eta_val;
                                        }
                                        $eta_obj = lpr_allocator_parse_date( $eta_val );
                                        if ( $eta_obj ) {
                                                $eta_dates[] = $eta_obj;
                                        }
                                }
                        }

                        if ( empty( $eta_dates ) && ! empty( $overview_rows ) ) {
                                foreach ( $overview_rows as $row ) {
                                        $eta_val = isset( $row['eta'] ) ? (string) $row['eta'] : ( isset( $row['new'] ) ? (string) $row['new'] : '' );
                                        if ( '' !== trim( $eta_val ) && '' === $eta_label_fallback ) {
                                                $eta_label_fallback = $eta_val;
                                        }
                                        $eta_obj = lpr_allocator_parse_date( $eta_val );
                                        if ( $eta_obj ) {
                                                $eta_dates[] = $eta_obj;
                                        }
                                }
                        }

                        $overall_eta = null;
                        foreach ( $eta_dates as $candidate ) {
                                if ( ! $overall_eta || $candidate->getTimestamp() > $overall_eta->getTimestamp() ) {
                                        $overall_eta = $candidate;
                                }
                        }

                        $eta_received = false;
                        if ( $overall_eta ) {
                                $eta_label    = lpr_allocator_format_store_date( $overall_eta->format( 'Y-m-d' ) );
                                $eta_received = true;
                                $eta_display  = $eta_label;
                        } elseif ( '' !== trim( $eta_label_fallback ) ) {
                                $eta_label    = $eta_label_fallback;
                                $eta_received = true;
                                $eta_display  = $eta_label;
                        } else {
                                $eta_label = $unallocated_label;
                        }

                        $delivery_detail   = $eta_received ? $eta_label : $pending_label;
                        $delivery_complete = false; // Never show fully complete to customers.

                        $po_state   = 'pending';
                        $po_detail  = $pending_label;
                        $eta_state  = $eta_received ? 'complete' : 'pending';
                        $ship_state = $eta_received ? 'partial' : 'pending';

                        if ( $backorder_lines > 0 ) {
                                if ( $full_allocated === $backorder_lines ) {
                                        $po_state  = 'complete';
                                        $po_detail = sprintf(
                                                /* translators: 1: allocated lines, 2: total lines */
                                                __( 'Allocated (%1$d of %2$d lines)', 'lpr-backorder-allocator' ),
                                                $full_allocated,
                                                $backorder_lines
                                        );
                                } elseif ( $allocated_lines > 0 ) {
                                        $po_state  = 'partial';
                                        $po_detail = sprintf(
                                                /* translators: 1: allocated lines, 2: total lines */
                                                __( 'Partially allocated (%1$d of %2$d lines)', 'lpr-backorder-allocator' ),
                                                $allocated_lines,
                                                $backorder_lines
                                        );
                                } else {
                                        $po_detail = sprintf(
                                                /* translators: %d: number of backordered lines */
                                                __( 'Awaiting allocation (%d lines)', 'lpr-backorder-allocator' ),
                                                $backorder_lines
                                        );
                                }
                        }

                        $steps = array(
                                array(
                                        'label'    => $labels['order'] ?? __( 'Order placed', 'lpr-backorder-allocator' ),
                                        'complete' => true,
                                        'detail'   => $order_date,
                                        'type'     => 'order',
                                ),
                                array(
                                        'label'    => $labels['po'] ?? __( 'PO allocated', 'lpr-backorder-allocator' ),
                                        'complete' => 'complete' === $po_state,
                                        'detail'   => $po_detail,
                                        'state'    => $po_state,
                                        'type'     => 'po',
                                ),
                                array(
                                        'label'    => $labels['eta'] ?? __( 'ETA received', 'lpr-backorder-allocator' ),
                                        'complete' => $eta_received,
                                        'detail'   => $eta_received ? $eta_label : $pending_label,
                                        'state'    => $eta_state,
                                        'type'     => 'eta',
                                ),
                                array(
                                        'label'    => $labels['delivery'] ?? __( 'Estimated delivery', 'lpr-backorder-allocator' ),
                                        'complete' => $delivery_complete,
                                        'detail'   => $delivery_detail,
                                        'state'    => $ship_state,
                                        'type'     => 'delivery',
                                ),
                        );

                        $completed = 0;
                        $partials  = 0;
                        foreach ( $steps as $step ) {
                                if ( ! empty( $step['complete'] ) ) {
                                        $completed++;
                                        continue;
                                }
                                if ( isset( $step['state'] ) && 'partial' === $step['state'] ) {
                                        $partials++;
                                }
                        }

                        $percent_raw = count( $steps ) > 0 ? round( ( ( $completed + ( 0.5 * $partials ) ) / count( $steps ) ) * 100 ) : 0;
                        $percent     = max( 0, min( 95, $percent_raw ) );

                        return array(
                                'steps'     => $steps,
                                'percent'   => max( 0, min( 100, $percent ) ),
                                'eta_label' => $eta_display,
                        );
                }

                /**
                 * Render the visual progress wheel and status list.
                 */
                protected static function render_progress_block( array $progress, string $color, string $heading, string $subheading, string $complete_tpl, string $done_label, string $pending_label ): string {
                        if ( empty( $progress['steps'] ) ) {
                                return '';
                        }

                        $percent      = (int) ( $progress['percent'] ?? 0 );
                        $eta_label    = (string) ( $progress['eta_label'] ?? '' );
                        $ring_label   = str_replace( '%complete%', (string) $percent, $complete_tpl );
                        $ring_color   = $color ?: '#1a1a1a';
                        $ring_back    = '#e5e7eb';
                        $eta_text     = $eta_label ?: $pending_label;
                        $circum       = 2 * pi() * 60;
                        $progress_len = $circum * ( max( 0, min( 100, $percent ) ) / 100 );
                        $offset       = $circum - $progress_len;
                        $icons        = array(
                                'order'    => 'ðŸ›’',
                                'po'       => 'ðŸ“¦',
                                'eta'      => 'â°',
                                'delivery' => 'ðŸšš',
                        );
                        $steps_html   = '<table role="presentation" cellpadding="0" cellspacing="0" style="width:100%;border-collapse:collapse;">';

                        foreach ( $progress['steps'] as $step ) {
                                $complete    = ! empty( $step['complete'] );
                                $state       = isset( $step['state'] ) ? (string) $step['state'] : ( $complete ? 'complete' : 'pending' );
                                $detail      = isset( $step['detail'] ) ? (string) $step['detail'] : '';
                                $type        = isset( $step['type'] ) ? (string) $step['type'] : '';
                                $icon        = isset( $icons[ $type ] ) ? $icons[ $type ] : ( 'complete' === $state ? 'âœ…' : ( 'partial' === $state ? 'âž¡ï¸' : 'â³' ) );
                                $pill        = 'complete' === $state ? $ring_color : ( 'partial' === $state ? '#fbbf24' : $ring_back );
                                $state_label = 'complete' === $state ? $done_label : ( 'partial' === $state ? __( 'In progress', 'lpr-backorder-allocator' ) : $pending_label );

                                $steps_html .= '<tr>'; // icon column
                                $steps_html .= '<td valign="top" style="padding:8px 10px 8px 0;width:40px;">';
                                $steps_html .= '<div style="width:36px;height:36px;border-radius:14px;background:' . esc_attr( $pill ) . ';color:' . ( 'complete' === $state ? '#fff' : '#0f172a' ) . ';text-align:center;line-height:36px;font-weight:700;font-size:16px;">' . esc_html( $icon ) . '</div>';
                                $steps_html .= '</td>';

                                $steps_html .= '<td valign="top" style="padding:8px 0 8px 0;border-bottom:1px solid #e2e8f0;">';
                                $steps_html .= '<div style="font-weight:700;color:#0f172a;font-size:14px;">' . esc_html( $step['label'] ?? '' ) . '</div>';
                                $steps_html .= '<div style="color:#475569;font-size:12px;">' . esc_html( $state_label );
                                if ( '' !== trim( $detail ) ) {
                                        $steps_html .= ' Â· ' . esc_html( $detail );
                                }
                                $steps_html .= '</div>';
                                $steps_html .= '</td>';
                                $steps_html .= '</tr>';
                        }

                        $steps_html .= '</table>';

                        $ring  = '<div style="position:relative;width:160px;height:160px;">';
                        $ring .= '<svg width="160" height="160" viewBox="0 0 160 160" xmlns="http://www.w3.org/2000/svg">';
                        $ring .= '<circle cx="80" cy="80" r="60" stroke="' . esc_attr( $ring_back ) . '" stroke-width="14" fill="none" />';
                        $ring .= '<circle cx="80" cy="80" r="60" stroke="' . esc_attr( $ring_color ) . '" stroke-width="14" fill="none" stroke-linecap="round" stroke-dasharray="' . esc_attr( number_format( $circum, 2, '.', '' ) ) . '" stroke-dashoffset="' . esc_attr( number_format( $offset, 2, '.', '' ) ) . '" transform="rotate(-90 80 80)" />';
                        $ring .= '</svg>';
                        $ring .= '<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;">';
                        $ring .= '<div style="font-weight:800;font-size:18px;color:#0f172a;">' . esc_html( $ring_label ) . '</div>';
                        $ring .= '<div style="font-size:12px;color:#475569;margin-top:4px;">' . esc_html( $eta_text ) . '</div>';
                        $ring .= '</div>';
                        $ring .= '</div>';

                        $html  = '<div style="margin:20px 0;padding:18px;border:1px solid #e2e8f0;border-radius:16px;background:#ffffff;box-shadow:0 14px 32px rgba(15,23,42,0.08);">';
                        if ( '' !== trim( $heading ) ) {
                                $html .= '<div style="font-weight:800;font-size:18px;margin-bottom:4px;color:#0f172a;">âœ¨ ' . esc_html( $heading ) . '</div>';
                        }
                        if ( '' !== trim( $subheading ) ) {
                                $html .= '<div style="color:#475569;margin-bottom:12px;font-size:13px;">' . esc_html( $subheading ) . '</div>';
                        }
                        $html .= '<table role="presentation" cellpadding="0" cellspacing="0" style="width:100%;border-collapse:collapse;">';
                        $html .= '<tr>';
                        $html .= '<td valign="top" align="center" style="padding:8px 12px;width:190px;">' . $ring . '</td>';
                        $html .= '<td valign="top" style="padding:8px 12px;">' . $steps_html . '</td>';
                        $html .= '</tr>';
                        $html .= '</table>';
                        $html .= '</div>';

                        return $html;
                }

                /**
                 * Shared wrapper for email tables to ensure consistent styling.
                 */
                protected static function wrap_email_table( string $head_html, string $body_html ): string {
                        $table  = '<div style="margin:8px 0 12px;overflow:hidden;border:1px solid #e2e8f0;border-radius:12px;box-shadow:0 12px 30px rgba(15,23,42,0.06);">';
                        $table .= '<table cellspacing="0" cellpadding="0" border="0" style="width:100%;border-collapse:collapse;font-size:14px;">';
                        $table .= $head_html . $body_html;
                        $table .= '</table></div>';

                        return $table;
                }

                /**
                 * Render ETA rows as a HTML table.
                 */
                protected static function render_eta_table( array $rows, string $heading_item, string $heading_prev, string $heading_new, string $unallocated_label ): string {
                        $head  = '<thead style="background:#f8fafc;"><tr>';
                        $head .= '<th align="left" style="padding:12px;color:#0f172a;font-size:13px;font-weight:700;border-bottom:1px solid #e2e8f0;">' . esc_html( $heading_item ) . '</th>';
                        $head .= '<th align="left" style="padding:12px;color:#0f172a;font-size:13px;font-weight:700;border-bottom:1px solid #e2e8f0;">' . esc_html( $heading_prev ) . '</th>';
                        $head .= '<th align="left" style="padding:12px;color:#0f172a;font-size:13px;font-weight:700;border-bottom:1px solid #e2e8f0;">' . esc_html( $heading_new ) . '</th>';
                        $head .= '</tr></thead>';

                        $body = '<tbody style="background:#fff;">';

                        foreach ( $rows as $row ) {
                                $name = isset( $row['name'] ) ? (string) $row['name'] : '';
                                $prev = isset( $row['prev'] ) ? (string) $row['prev'] : $unallocated_label;
                                $new  = isset( $row['new'] ) ? (string) $row['new'] : $unallocated_label;

                                if ( '' === trim( $prev ) ) {
                                        $prev = $unallocated_label;
                                }
                                if ( '' === trim( $new ) ) {
                                        $new = $unallocated_label;
                                }

                                $body .= '<tr>';
                                $body .= '<td style="padding:12px;border-bottom:1px solid #e2e8f0;color:#0f172a;font-weight:600;">' . esc_html( $name ) . '</td>';
                                $body .= '<td style="padding:12px;border-bottom:1px solid #e2e8f0;color:#475569;">' . esc_html( $prev ) . '</td>';
                                $body .= '<td style="padding:12px;border-bottom:1px solid #e2e8f0;color:#0f172a;">' . esc_html( $new ) . '</td>';
                                $body .= '</tr>';
                        }

                        $body .= '</tbody>';

                        return self::wrap_email_table( $head, $body );
                }

                /**
                 * Render a simple overview table of backordered lines.
                 */
                protected static function render_backorder_overview( array $rows, string $heading_item, string $heading_eta, string $unallocated_label ): string {
                        $head  = '<thead style="background:#f8fafc;"><tr>';
                        $head .= '<th align="left" style="padding:12px;color:#0f172a;font-size:13px;font-weight:700;border-bottom:1px solid #e2e8f0;">' . esc_html( $heading_item ) . '</th>';
                        $head .= '<th align="left" style="padding:12px;color:#0f172a;font-size:13px;font-weight:700;border-bottom:1px solid #e2e8f0;">' . esc_html( $heading_eta ) . '</th>';
                        $head .= '</tr></thead>';

                        $body = '<tbody style="background:#fff;">';

                        foreach ( $rows as $row ) {
                                $name = isset( $row['name'] ) ? (string) $row['name'] : '';
                                $eta  = isset( $row['new'] ) ? (string) $row['new'] : ( isset( $row['eta'] ) ? (string) $row['eta'] : $unallocated_label );
                                $status = isset( $row['status'] ) ? (string) $row['status'] : '';

                                if ( '' === trim( $eta ) ) {
                                        $eta = $unallocated_label;
                                }

                                $body .= '<tr>';
                                $body .= '<td style="padding:12px;border-bottom:1px solid #e2e8f0;color:#0f172a;font-weight:600;">' . esc_html( $name ) . '</td>';
                                $body .= '<td style="padding:12px;border-bottom:1px solid #e2e8f0;color:#0f172a;">' . esc_html( $eta );
                                if ( '' !== trim( $status ) ) {
                                        $body .= '<div style="color:#475569;font-size:12px;margin-top:4px;">' . esc_html( $status ) . '</div>';
                                }
                                $body .= '</td>';
                                $body .= '</tr>';
                        }

                        $body .= '</tbody>';

                        return self::wrap_email_table( $head, $body );
                }

                /**
                 * Replace supported tokens in templates.
                 */
                public static function apply_email_tokens( string $template, array $tokens ): string {
                        return strtr( $template, $tokens );
                }

                /**
                 * Build common tokens for an order.
                 */
                protected static function email_tokens_for_order( \WC_Order $order ): array {
                        $order_number = method_exists( $order, 'get_order_number' ) ? (string) $order->get_order_number() : (string) $order->get_id();
                        $customer     = trim( $order->get_formatted_billing_full_name() ?: '' );
                        if ( '' === $customer ) {
                                $customer = trim( $order->get_formatted_shipping_full_name() ?: '' );
                        }
                        if ( '' === $customer ) {
                                $customer = (string) $order->get_billing_email();
                        }

                        if ( '' === $customer ) {
                                $customer = __( 'Customer', 'lpr-backorder-allocator' );
                        }

                        return array(
                                '%order_number%'  => $order_number,
                                '%customer_name%' => $customer,
                        );
                }

		/**
		 * Hook: update ETA when orders save (classic + HPOS).
		 */
		public static function init_hooks(): void {
			// Classic posts screen.
			add_action(
				'save_post_shop_order',
				static function ( $post_id, $post ) {
					if ( self::$updating ) {
						return;
					}
					if ( ! current_user_can( 'manage_woocommerce' ) ) {
						return;
					}
					if ( $post && 'shop_order' === $post->post_type ) {
						self::update_line_eta( (int) $post_id );
					}
				},
				20,
				2
			);

			// HPOS data store.
			add_action(
				'woocommerce_after_order_object_save',
				static function ( $order ) {
					if ( self::$updating ) {
						return;
					}
					if ( $order instanceof \WC_Order ) {
						self::update_line_eta( (int) $order->get_id() );
					}
				},
				20,
				1
			);
		}
	}
	ETA::init_hooks();
}

if ( ! class_exists( __NAMESPACE__ . '\Order_Allocations_Metabox' ) ) {
	/**
	 * Order admin metabox rendering allocations & ETA per line.
	 */
	class Order_Allocations_Metabox {

                public static function init(): void {
                        add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 20 );
                        // Extra registrations to better support HPOS screen routing.
                        add_action( 'add_meta_boxes_shop_order', array( __CLASS__, 'register_box' ), 20 );
                        add_action( 'add_meta_boxes_woocommerce_page_wc-orders', array( __CLASS__, 'register_box' ), 20 );

                        // Persist manual force-allocation flags.
                        add_action( 'save_post_shop_order', array( __CLASS__, 'save_force_flags' ), 10, 2 );
                        add_action( 'woocommerce_before_order_object_save', array( __CLASS__, 'save_force_flags_object' ), 10, 1 );

                        add_action( 'admin_post_lpr_allocator_free_item_allocations', array( __CLASS__, 'handle_free_item_allocations' ) );

                        // Force ETA email endpoint.
                        add_action( 'wp_ajax_lpr_force_eta_email', array( __CLASS__, 'ajax_force_eta_email' ) );
                        add_action( 'wp_ajax_lpr_force_eta_email_preview', array( __CLASS__, 'ajax_force_eta_email_preview' ) );
                }

		public static function register_box(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			add_meta_box(
				'lpr_order_allocations_eta',
				__( 'Allocations & ETA', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'shop_order',
				'normal',
				'default'
			);

			// HPOS screen support (screen id acts as $post_type).
			add_meta_box(
				'lpr_order_allocations_eta',
				__( 'Allocations & ETA', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'woocommerce_page_wc-orders',
				'normal',
				'default'
			);
		}

		/**
		 * Resolve order ID from context (classic & HPOS edit screens).
		 *
		 * @param mixed $context
		 * @return int
		 */
                protected static function resolve_order_id( $context ): int {
                        $order_id = 0;
                        if ( $context instanceof \WP_Post ) {
                                $order_id = (int) $context->ID;
                        }
                        if ( $order_id <= 0 && isset( $_GET['id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                                $order_id = absint( $_GET['id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        }
                        return $order_id;
                }

                /**
                 * Save force-allocation flags for order items.
                 *
                 * @param int                $order_id
                 * @param null|\WC_Order    $order_obj
                 * @return void
                 */
                protected static function persist_force_flags( int $order_id, $order_obj = null ): void {
                        if ( $order_id <= 0 || ! is_admin() ) {
                                return;
                        }
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }
                        $nonce = isset( $_POST['lpr_force_allocation_nonce'] ) ? sanitize_text_field( wp_unslash( $_POST['lpr_force_allocation_nonce'] ) ) : '';
                        if ( ! $nonce || ! wp_verify_nonce( $nonce, 'lpr_force_allocation_' . $order_id ) ) {
                                return;
                        }

                        $order = $order_obj instanceof \WC_Order ? $order_obj : wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                return;
                        }

                        $flags = array();
                        if ( isset( $_POST['lpr_force_allocation'] ) && is_array( $_POST['lpr_force_allocation'] ) ) {
                                foreach ( wp_unslash( $_POST['lpr_force_allocation'] ) as $item_id => $val ) { // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
                                        $flags[ absint( $item_id ) ] = true;
                                }
                        }

                        $quantities = array();
                        if ( isset( $_POST['lpr_force_allocation_qty'] ) && is_array( $_POST['lpr_force_allocation_qty'] ) ) {
                                foreach ( wp_unslash( $_POST['lpr_force_allocation_qty'] ) as $item_id => $qty ) { // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
                                        $quantities[ absint( $item_id ) ] = (int) $qty;
                                }
                        }

                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : Settings::defaults();
                        $unallocated = (string) ( $settings['email_unallocated_label'] ?? __( 'Unallocated', 'lpr-backorder-allocator' ) );

                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                if ( ! $item instanceof \WC_Order_Item_Product ) {
                                        continue;
                                }

                                $item_id   = (int) $item->get_id();
                                $qty       = max( 0, (int) $item->get_quantity() );
                                $force_on  = isset( $flags[ $item_id ] );
                                $force_qty = isset( $quantities[ $item_id ] ) ? (int) $quantities[ $item_id ] : $qty;
                                $force_qty = max( 0, min( $qty, $force_qty ) );

                                $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation';
                                if ( $force_on && $force_qty > 0 ) {
                                        $item->update_meta_data( $meta_key, $force_qty );
                                } else {
                                        $item->delete_meta_data( $meta_key );
                                }

                                if ( method_exists( $item, 'save' ) ) {
                                        $item->save();
                                }
                        }
                }

                public static function save_force_flags( $post_id, $post ): void {
                        if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) {
                                return;
                        }
                        if ( $post && 'shop_order' !== $post->post_type ) {
                                return;
                        }
                        self::persist_force_flags( (int) $post_id );
                }

                public static function save_force_flags_object( $order ): void {
                        if ( ! ( $order instanceof \WC_Order ) ) {
                                return;
                        }
                        self::persist_force_flags( (int) $order->get_id(), $order );
                }

                public static function handle_free_item_allocations(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_die( esc_html__( 'Access denied.', 'lpr-backorder-allocator' ) );
                        }

                        $order_id = isset( $_GET['order_id'] ) ? absint( $_GET['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $item_id  = isset( $_GET['item_id'] ) ? absint( $_GET['item_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $nonce    = isset( $_GET['_wpnonce'] ) ? sanitize_text_field( wp_unslash( $_GET['_wpnonce'] ) ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( $order_id <= 0 || $item_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_free_allocations_' . $order_id . '_' . $item_id ) ) {
                                wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! ( $order instanceof \WC_Order ) ) {
                                wp_die( esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) );
                        }

                        $item = $order->get_item( $item_id );
                        if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                wp_die( esc_html__( 'Order line not found.', 'lpr-backorder-allocator' ) );
                        }

                        if ( method_exists( $item, 'read_meta_data' ) ) {
                                $item->read_meta_data( true );
                        }

                        $meta_key       = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $snapshot_key   = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT' ) ? ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT : '_lpr_alloc_qty_snapshot';
                        $allocs         = $item->get_meta( $meta_key, true );
                        $released_total = 0;

                        if ( is_array( $allocs ) ) {
                                foreach ( $allocs as &$alloc_row ) {
                                        $status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                        $qty    = isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                        if ( 'released' === $status || $qty <= 0 ) {
                                                continue;
                                        }
                                        lpr_allocator_touch_allocation_status( $alloc_row, 'released' );
                                        $released_total += $qty;
                                }
                                unset( $alloc_row );
                        }

                        $item->update_meta_data( $snapshot_key, max( 0, (int) $item->get_quantity() ) );

                        if ( $released_total > 0 ) {
                                $item->update_meta_data( $meta_key, $allocs );
                                $item->save();

                                $reason = sprintf(
                                        /* translators: 1: user name */
                                        __( 'Manual free allocation by %s from the order page.', 'lpr-backorder-allocator' ),
                                        wp_get_current_user()->display_name
                                );

                                lpr_allocator_add_release_note( $order, $item, (int) $released_total, $reason );

                                if ( function_exists( __NAMESPACE__ . '\\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                        lpr_allocator_reapply_po_allocations_for_order( (int) $order_id );
                                }

                                if ( class_exists( __NAMESPACE__ . '\\ETA' ) ) {
                                        ETA::update_line_eta( (int) $order_id );
                                }
                        } else {
                                $item->save();
                        }

                        $redirect = wp_get_referer();
                        if ( ! $redirect ) {
                                $redirect = admin_url( 'post.php?post=' . $order_id . '&action=edit' );
                        }

                        wp_safe_redirect( $redirect );
                        exit;
                }

                public static function render_box( $post_or_screen ): void {
                        if ( ! function_exists( 'wc_get_order' ) ) {
                                return;
                        }
			$order_id = self::resolve_order_id( $post_or_screen );
			if ( $order_id <= 0 ) {
				echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
				return;
			}

			// Persist latest ETA before rendering.
			if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
				ETA::update_line_eta( $order_id );
			}

                        $order = wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
                         return;
                        }

                        wp_nonce_field( 'lpr_force_allocation_' . (int) $order_id, 'lpr_force_allocation_nonce' );

                        $items = $order->get_items( 'line_item' );

                        // VIP prioritization trigger.
                        $vip_nonce = wp_create_nonce( 'lpr_vip_' . (int) $order_id );
                        if ( class_exists( __NAMESPACE__ . '\Order_VIP_Prioritizer' ) && Order_VIP_Prioritizer::should_show_button( $order ) ) {
                                echo '<div style="margin:8px 0 14px;">';
                                echo '<button type="button" class="button button-primary lpr-vip-trigger" data-order="' . esc_attr( (string) $order_id ) . '" data-nonce="' . esc_attr( $vip_nonce ) . '">' . esc_html__( 'VIP prioritize', 'lpr-backorder-allocator' ) . '</button>';
                                echo '<span style="margin-left:10px;opacity:.8;">' . esc_html__( 'Give this order the earliest possible delivery date.', 'lpr-backorder-allocator' ) . '</span>';
                                echo '</div>';
                        }

                        $vip_badge = class_exists( __NAMESPACE__ . '\Order_VIP_Prioritizer' ) && Order_VIP_Prioritizer::is_vip_order( $order ) ? Order_VIP_Prioritizer::vip_badge_html() : '';
                        if ( $vip_badge ) {
                                echo '<p style="margin:4px 0 10px;">' . $vip_badge . '<span style="margin-left:6px;opacity:.8;">' . esc_html__( 'VIP order', 'lpr-backorder-allocator' ) . '</span></p>';
                        }

                        // Basic styles.
                        $css  = '.lpr-alloc-eta{width:100%;border-collapse:collapse}.lpr-alloc-eta th,.lpr-alloc-eta td{padding:6px;border-bottom:1px solid #ddd;text-align:left}';
                        $css .= '.lpr-alloc-sub{margin:6px 0 0 0;border-collapse:collapse;width:100%}.lpr-alloc-sub th,.lpr-alloc-sub td{padding:4px;border-bottom:1px solid #eee;font-size:12px}';
                        $css .= '.lpr-badge{display:inline-block;padding:2px 6px;border-radius:3px;background:#f0ad4e;color:#111;font-size:11px;margin-left:6px}';
                        $css .= '.lpr-badge.lpr-badge-vip{background:#c2274e;color:#fff;font-weight:600}';
                        $css .= '.lpr-unallocated{font-style:italic;opacity:0.8}';
                        $css .= '.lpr-force-row{margin-top:6px;font-size:12px;opacity:0.9}';
                        $css .= '.lpr-force-row summary{cursor:pointer;user-select:none;display:flex;align-items:center;gap:6px;}';
                        $css .= '.lpr-force-row[open]{padding-bottom:4px;}';
                        $css .= '.lpr-force-controls{margin-top:6px;padding-left:18px;}';
                        $css .= '.lpr-force-row input[type=number]{width:70px;margin-left:6px}';
                        echo '<style type="text/css">' . esc_html( $css ) . '</style>';

			echo '<table class="widefat striped lpr-alloc-eta">';
			echo '<thead><tr>';
			echo '<th>' . esc_html__( 'Item', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'Qty', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'Allocations', 'lpr-backorder-allocator' ) . '</th>';
			echo '</tr></thead><tbody>';

			foreach ( $items as $item ) {
				if ( ! $item instanceof \WC_Order_Item_Product ) {
					continue;
				}

                                // Ensure we have the latest meta (may have changed earlier in the request).
                                if ( method_exists( $item, 'read_meta_data' ) ) {
                                        $item->read_meta_data( true );
                                }

                                $product   = $item->get_product();
                                $name      = $item->get_name();
                                $qty       = (int) $item->get_quantity();
                                $sku       = $product instanceof \WC_Product ? $product->get_sku() : '';
                                $line_eta  = (string) $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta', true );
                                $allocs    = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
                                $needs     = class_exists( __NAMESPACE__ . '\Backorder' ) ? Backorder::needs_allocation( $item ) : false;
                                $force_qty = (int) $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation', true );

                                echo '<tr>';
                                echo '<td>';
                                echo esc_html( $name );
                                if ( $sku ) {
                                        echo ' <small>#' . esc_html( $sku ) . '</small>';
                                }
                                if ( $force_qty > 0 ) {
                                        echo ' <span class="lpr-badge">' . esc_html__( 'Needs allocation', 'lpr-backorder-allocator' ) . '</span>';
                                } elseif ( $needs ) {
                                        echo ' <span class="lpr-badge">' . esc_html__( 'Backorder', 'lpr-backorder-allocator' ) . '</span>';
                                }

                                $prefill = $force_qty > 0 ? $force_qty : $qty;
                                $force_open = $force_qty > 0 ? ' open' : '';
                                echo '<details class="lpr-force-row"' . $force_open . '>';
                                echo '<summary>' . esc_html__( 'Force allocation', 'lpr-backorder-allocator' ) . '</summary>';
                                echo '<div class="lpr-force-controls">';
                                echo '<label><input type="checkbox" name="lpr_force_allocation[' . esc_attr( (string) $item->get_id() ) . ']" value="1" ' . checked( $force_qty > 0, true, false ) . ' /> ' . esc_html__( 'Enable force allocation', 'lpr-backorder-allocator' ) . '</label>';
                                echo '<input type="number" name="lpr_force_allocation_qty[' . esc_attr( (string) $item->get_id() ) . ']" min="1" max="' . esc_attr( (string) $qty ) . '" value="' . esc_attr( (string) $prefill ) . '" />';
                                echo '<span style="margin-left:6px;">' . esc_html__( 'Treat as needing PO allocation even if in stock.', 'lpr-backorder-allocator' ) . '</span>';
                                if ( is_array( $allocs ) && ! empty( $allocs ) ) {
                                        $free_url = wp_nonce_url(
                                                admin_url( 'admin-post.php?action=lpr_allocator_free_item_allocations&order_id=' . (int) $order_id . '&item_id=' . (int) $item->get_id() ),
                                                'lpr_free_allocations_' . (int) $order_id . '_' . (int) $item->get_id()
                                        );

                                        echo '<a class="button" style="margin-left:8px;" href="' . esc_url( $free_url ) . '">' . esc_html__( 'Free allocations', 'lpr-backorder-allocator' ) . '</a>';
                                }
                                echo '</div>';
                                echo '</details>';
                                echo '</td>';

				echo '<td>' . esc_html( (string) $qty ) . '</td>';

                                if ( $line_eta ) {
                                        echo '<td>' . esc_html( lpr_allocator_format_store_date( $line_eta ) ) . '</td>';
                                } else {
                                        echo '<td class="lpr-unallocated">' . esc_html__( 'Unallocated', 'lpr-backorder-allocator' ) . '</td>';
                                }

				echo '<td>';
				if ( is_array( $allocs ) && ! empty( $allocs ) ) {
					echo '<table class="lpr-alloc-sub"><thead><tr>';
					echo '<th>' . esc_html__( 'PO #', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'Qty', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'Status', 'lpr-backorder-allocator' ) . '</th>';
					echo '</tr></thead><tbody>';

					foreach ( $allocs as $row ) {
						$po_id     = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
						$po_number = isset( $row['po_number'] ) ? (string) $row['po_number'] : ( $po_id ? (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true ) : '' );
						$alloc_q   = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
						$eta_row   = '';
						if ( ! empty( $row['eta'] ) ) {
							$eta_row = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
						}
						if ( '' === $eta_row && $po_id ) {
							$eta_row = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
						}
                                                $status       = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                                $status_time  = isset( $row['status_changed_at'] ) ? (string) $row['status_changed_at'] : '';
                                                if ( ! $status_time && isset( $row['allocated_at'] ) && 'reserved' === $status ) {
                                                        $status_time = (string) $row['allocated_at'];
                                                }
                                                $status_label = $status;
                                                if ( $status_time ) {
                                                        $status_label .= ' â€” ' . lpr_allocator_format_store_date( $status_time, true );
                                                }

                                                echo '<tr>';
                                                echo '<td>' . esc_html( $po_number ) . '</td>';
                                                echo '<td>' . esc_html( (string) $alloc_q ) . '</td>';
                                                echo '<td>' . esc_html( lpr_allocator_format_store_date( $eta_row ) ) . '</td>';
                                                echo '<td>' . esc_html( $status_label ) . '</td>';
						echo '</tr>';
					}

					echo '</tbody></table>';
				} else {
					echo '<span class="lpr-unallocated">' . esc_html__( 'No allocations', 'lpr-backorder-allocator' ) . '</span>';
				}
				echo '</td>';

				echo '</tr>';
			}

                          echo '</tbody></table>';

                          $email_rows = self::build_eta_email_rows( $order );
                          if ( ! empty( $email_rows ) && $order->get_billing_email() ) {
                                  $force_nonce = wp_create_nonce( 'lpr_force_eta_email_' . (int) $order_id );
                                  echo '<div style="margin:12px 0 0;">';
                                  echo '<button type="button" class="button" id="lpr-force-eta-email-preview" data-order="' . esc_attr( (string) $order_id ) . '" data-nonce="' . esc_attr( $force_nonce ) . '">' . esc_html__( 'Preview updated ETA email', 'lpr-backorder-allocator' ) . '</button>';
                                  echo '<button type="button" class="button" style="margin-left:6px;" id="lpr-force-eta-email" data-order="' . esc_attr( (string) $order_id ) . '" data-nonce="' . esc_attr( $force_nonce ) . '">' . esc_html__( 'Send updated ETA email', 'lpr-backorder-allocator' ) . '</button>';
                                  echo '<span style="margin-left:8px;opacity:.8;display:inline-block;">' . esc_html__( 'Preview or force-send the latest ETA update to the customer.', 'lpr-backorder-allocator' ) . '</span>';
                                  echo '<p id="lpr-force-eta-email-status" style="margin:6px 0 0;color:#555;"></p>';
                                  echo '</div>';
                          }

                          // Lightweight modal container and behaviors (one-time output).
                          static $vip_script_done = false;
                        if ( ! $vip_script_done ) {
                                $vip_script_done = true;
                                ?>
                                <style>
                                        .lpr-vip-overlay{position:fixed;z-index:100000;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;padding:20px;}
                                        .lpr-vip-modal{background:#fff;max-width:820px;width:100%;border-radius:6px;box-shadow:0 10px 40px rgba(0,0,0,.25);overflow:hidden;}
                                        .lpr-vip-modal header{padding:14px 16px;border-bottom:1px solid #eee;display:flex;justify-content:space-between;align-items:center;}
                                        .lpr-vip-modal header h3{margin:0;font-size:16px;}
                                        .lpr-vip-modal .lpr-vip-body{max-height:60vh;overflow:auto;padding:16px;}
                                        .lpr-vip-modal table{width:100%;border-collapse:collapse;}
                                        .lpr-vip-modal th,.lpr-vip-modal td{padding:8px;border-bottom:1px solid #eee;text-align:left;vertical-align:top;}
                                        .lpr-vip-modal .lpr-actions{padding:12px 16px;border-top:1px solid #eee;text-align:right;}
                                </style>
                                <script>
                                (function($){
                                        function showVipModal(html){
                                                $('.lpr-vip-overlay').remove();
                                                var $wrap = $('<div class="lpr-vip-overlay"></div>');
                                                $wrap.append(html);
                                                $('body').append($wrap);
                                        }

                                          function collectVipOverrides($modal){
                                                  var map = {};
                                                  $modal.find('.lpr-vip-source').each(function(){
                                                          var $sel = $(this);
                                                          var item = $sel.data('item');
                                                          var val = $sel.val();
                                                          if(item && val){
                                                                  map[item] = val;
                                                          }
                                                  });
                                                  return map;
                                          }

                                          $(document).on('click','#lpr-force-eta-email-preview',function(e){
                                                  e.preventDefault();
                                                  var $btn = $(this);
                                                  var orderId = $btn.data('order');
                                                  var nonce = $btn.data('nonce');
                                                  var $status = $('#lpr-force-eta-email-status');
                                                  if(!orderId || !nonce){
                                                          return;
                                                  }
                                                  $btn.prop('disabled', true).addClass('lpr-loading');
                                                  $status.text('<?php echo esc_js( __( 'Loading email preview...', 'lpr-backorder-allocator' ) ); ?>');
                                                  $.post(ajaxurl,{action:'lpr_force_eta_email_preview',order_id:orderId,_wpnonce:nonce},function(resp){
                                                          $btn.prop('disabled', false).removeClass('lpr-loading');
                                                          if(resp && resp.success && resp.data && resp.data.body){
                                                                  var subject = resp.data.subject || '<?php echo esc_js( __( 'Updated ETA email', 'lpr-backorder-allocator' ) ); ?>';
                                                                  var html = '<div class="lpr-vip-modal lpr-eta-preview" data-order="'+orderId+'"><header><h3>'+subject+'</h3><a href="#" class="lpr-vip-cancel">&times;</a></header><div class="lpr-vip-body lpr-eta-preview-body">'+(resp.data.body||'')+'</div><div class="lpr-actions"><button type="button" class="button lpr-vip-cancel"><?php echo esc_js( __( 'Close', 'lpr-backorder-allocator' ) ); ?></button></div></div>';
                                                                  showVipModal(html);
                                                                  $status.text('');
                                                                  return;
                                                          }
                                                          var msg = (resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to load email preview.', 'lpr-backorder-allocator' ) ); ?>';
                                                          $status.text(msg);
                                                  }).fail(function(){
                                                          $btn.prop('disabled', false).removeClass('lpr-loading');
                                                          $status.text('<?php echo esc_js( __( 'Unable to load email preview.', 'lpr-backorder-allocator' ) ); ?>');
                                                  });
                                          });

                                          $(document).on('click','#lpr-force-eta-email',function(e){
                                                  e.preventDefault();
                                                  var $btn = $(this);
                                                  var orderId = $btn.data('order');
                                                  var nonce = $btn.data('nonce');
                                                  var $status = $('#lpr-force-eta-email-status');
                                                  if(!orderId || !nonce){
                                                          return;
                                                  }
                                                  $btn.prop('disabled', true).addClass('lpr-loading');
                                                  $status.text('<?php echo esc_js( __( 'Sending email...', 'lpr-backorder-allocator' ) ); ?>');
                                                  $.post(ajaxurl,{action:'lpr_force_eta_email',order_id:orderId,_wpnonce:nonce},function(resp){
                                                          $btn.prop('disabled', false).removeClass('lpr-loading');
                                                          if(resp && resp.success){
                                                                  $status.text(resp.data && resp.data.message ? resp.data.message : '<?php echo esc_js( __( 'ETA email sent.', 'lpr-backorder-allocator' ) ); ?>');
                                                                  return;
                                                          }
                                                          var msg = (resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to send ETA email.', 'lpr-backorder-allocator' ) ); ?>';
                                                          $status.text(msg);
                                                  }).fail(function(){
                                                          $btn.prop('disabled', false).removeClass('lpr-loading');
                                                          $status.text('<?php echo esc_js( __( 'Unable to send ETA email.', 'lpr-backorder-allocator' ) ); ?>');
                                                  });
                                          });
                                          $(document).on('click','.lpr-vip-trigger',function(e){
                                                  e.preventDefault();
                                                  var $btn = $(this);
                                                var orderId = $btn.data('order');
                                                var nonce = $btn.data('nonce');
                                                $btn.prop('disabled', true).addClass('lpr-loading');
                                                $.post(ajaxurl,{action:'lpr_vip_preview',order_id:orderId,_wpnonce:nonce},function(resp){
                                                        $btn.prop('disabled', false).removeClass('lpr-loading');
                                                        if(resp && resp.success && resp.data && resp.data.html){
                                                                showVipModal(resp.data.html);
                                                        }else if(resp && resp.data && resp.data.message){
                                                                window.alert(resp.data.message);
                                                        }else{
                                                                window.alert('<?php echo esc_js( __( 'Unable to load VIP preview.', 'lpr-backorder-allocator' ) ); ?>');
                                                        }
                                                }).fail(function(){
                                                        $btn.prop('disabled', false).removeClass('lpr-loading');
                                                        window.alert('<?php echo esc_js( __( 'Unable to load VIP preview.', 'lpr-backorder-allocator' ) ); ?>');
                                                });
                                        });

                                        $(document).on('click','.lpr-vip-cancel',function(e){
                                                e.preventDefault();
                                                $(this).closest('.lpr-vip-overlay').remove();
                                        });

                                        $(document).on('click','.lpr-vip-refresh',function(e){
                                                e.preventDefault();
                                                var $btn = $(this);
                                                var $modal = $btn.closest('.lpr-vip-modal');
                                                var orderId = $modal.data('order');
                                                var nonce = $modal.data('preview');
                                                if(!orderId || !nonce){
                                                        return;
                                                }
                                                var overrides = collectVipOverrides($modal);
                                                $btn.prop('disabled', true);
                                                $.post(ajaxurl,{action:'lpr_vip_preview',order_id:orderId,_wpnonce:nonce,source_overrides:JSON.stringify(overrides)},function(resp){
                                                        if(resp && resp.success && resp.data && resp.data.html){
                                                                showVipModal(resp.data.html);
                                                                return;
                                                        }
                                                        if(resp && resp.data && resp.data.message){
                                                                window.alert(resp.data.message);
                                                        }else{
                                                                window.alert('<?php echo esc_js( __( 'Unable to load VIP preview.', 'lpr-backorder-allocator' ) ); ?>');
                                                        }
                                                }).fail(function(){
                                                        window.alert('<?php echo esc_js( __( 'Unable to load VIP preview.', 'lpr-backorder-allocator' ) ); ?>');
                                                }).always(function(){
                                                        $btn.prop('disabled', false);
                                                });
                                        });

                                        $(document).on('click','.lpr-vip-confirm',function(e){
                                                e.preventDefault();
                                                var $btn = $(this);
                                                var $modal = $btn.closest('.lpr-vip-modal');
                                                var plan = $btn.data('plan');
                                                var nonce = $btn.data('nonce');
                                                var overrides = collectVipOverrides($modal);
                                                $btn.prop('disabled', true);
                                                $.post(ajaxurl,{action:'lpr_vip_confirm',plan_key:plan,_wpnonce:nonce,source_overrides:JSON.stringify(overrides)},function(resp){
                                                        if(resp && resp.success){
                                                                window.location.reload();
                                                                return;
                                                        }
                                                        $btn.prop('disabled', false);
                                                        if(resp && resp.data && resp.data.message){
                                                                window.alert(resp.data.message);
                                                        }else{
                                                                window.alert('<?php echo esc_js( __( 'Unable to apply VIP changes.', 'lpr-backorder-allocator' ) ); ?>');
                                                        }
                                                }).fail(function(){
                                                        $btn.prop('disabled', false);
                                                        window.alert('<?php echo esc_js( __( 'Unable to apply VIP changes.', 'lpr-backorder-allocator' ) ); ?>');
                                                });
                                        });
                                  })(jQuery);
                                  </script>
                                  <?php
                          }
                }

                /**
                 * Build email rows for backordered items on an order.
                 */
                public static function build_eta_email_rows( \WC_Order $order ): array {
                        if ( ! class_exists( __NAMESPACE__ . '\Backorder' ) ) {
                                return array();
                        }

                        $rows        = array();
                        $eta_meta    = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';
                        $settings    = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
                        $unallocated = (string) ( $settings['email_unallocated_label'] ?? __( 'Unallocated', 'lpr-backorder-allocator' ) );

                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                if ( ! $item instanceof \WC_Order_Item_Product ) {
                                        continue;
                                }

                                $force_qty = (int) $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation', true );

                                if ( ! Backorder::needs_allocation( $item ) && $force_qty <= 0 ) {
                                        continue;
                                }

                                $product = $item->get_product();
                                $sku     = $product instanceof \WC_Product ? $product->get_sku() : '';
                                $desired = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : max( 0, (int) $item->get_quantity() );
                                $allocated_qty = function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ? lpr_allocator_get_item_allocated_active( $item ) : 0;
                                $target_qty    = max( $desired, $force_qty );

                                $eta     = (string) $item->get_meta( $eta_meta, true );
                                $eta_h   = $eta ? lpr_allocator_format_store_date( $eta ) : $unallocated;

                                $allocation_label = '';
                                if ( $target_qty > 0 ) {
                                        if ( $allocated_qty >= $target_qty ) {
                                                $allocation_label = __( 'Allocated in full', 'lpr-backorder-allocator' );
                                        } elseif ( $allocated_qty > 0 ) {
                                                $allocation_label = sprintf(
                                                        /* translators: 1: allocated quantity, 2: ordered quantity */
                                                        __( 'Partially allocated (%1$d of %2$d)', 'lpr-backorder-allocator' ),
                                                        $allocated_qty,
                                                        $target_qty
                                                );
                                        } else {
                                                $allocation_label = __( 'Awaiting allocation', 'lpr-backorder-allocator' );
                                        }
                                }

                                $rows[] = array(
                                        'name'   => $item->get_name() . ( $sku ? ' [' . $sku . ']' : '' ),
                                        'prev'   => 'â€”',
                                        'new'    => $eta_h,
                                        'status' => $allocation_label,
                                );
                        }

                        return $rows;
                }

                /**
                 * AJAX: force-send the ETA email for backordered lines.
                 */
                public static function ajax_force_eta_email(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order_id = isset( $_POST['order_id'] ) ? absint( $_POST['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $nonce    = isset( $_POST['_wpnonce'] ) ? (string) $_POST['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( $order_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_force_eta_email_' . $order_id ) ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                wp_send_json_error( array( 'message' => __( 'Order not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                ETA::update_line_eta( $order_id );

                                // Refresh order data so recalculated line ETAs are reflected in the email rows.
                                $order = wc_get_order( $order_id );
                        }

                        $rows = self::build_eta_email_rows( $order );
                        if ( empty( $rows ) ) {
                                wp_send_json_error( array( 'message' => __( 'No backordered items to email.', 'lpr-backorder-allocator' ) ) );
                        }

                        $sent = class_exists( __NAMESPACE__ . '\ETA' ) ? ETA::send_eta_email( $order, array(), false, $rows ) : false;
                        if ( ! $sent ) {
                                wp_send_json_error( array( 'message' => __( 'Unable to send the ETA email.', 'lpr-backorder-allocator' ) ) );
                        }

                        wp_send_json_success( array( 'message' => __( 'ETA email sent.', 'lpr-backorder-allocator' ) ) );
                }

                /**
                 * AJAX: preview the ETA email for backordered lines.
                 */
                public static function ajax_force_eta_email_preview(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order_id = isset( $_POST['order_id'] ) ? absint( $_POST['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $nonce    = isset( $_POST['_wpnonce'] ) ? (string) $_POST['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( $order_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_force_eta_email_' . $order_id ) ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order = wc_get_order( $order_id );
                        if ( ! $order instanceof \WC_Order ) {
                                wp_send_json_error( array( 'message' => __( 'Order not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                ETA::update_line_eta( $order_id );
                                $order = wc_get_order( $order_id );
                        }

                        if ( ! class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                wp_send_json_error( array( 'message' => __( 'ETA email preview unavailable.', 'lpr-backorder-allocator' ) ) );
                        }

                        $preview = ETA::build_eta_email_preview( $order );

                        if ( empty( $preview ) || empty( $preview['body'] ) ) {
                                wp_send_json_error( array( 'message' => __( 'Unable to build email preview.', 'lpr-backorder-allocator' ) ) );
                        }

                        wp_send_json_success(
                                array(
                                        'subject' => $preview['subject'],
                                        'body'    => $preview['body'],
                                )
                        );
                }
        }
        Order_Allocations_Metabox::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Order_VIP_Prioritizer' ) ) {
        /**
         * VIP prioritization workflow (preview + confirm) for giving an order the earliest possible ETA.
         */
        class Order_VIP_Prioritizer {

                public static function init(): void {
                        add_action( 'wp_ajax_lpr_vip_preview', array( __CLASS__, 'ajax_preview' ) );
                        add_action( 'wp_ajax_lpr_vip_confirm', array( __CLASS__, 'ajax_confirm' ) );
                        add_filter( 'woocommerce_order_number', array( __CLASS__, 'add_badge_to_order_number' ), 10, 2 );
                        add_action( 'manage_shop_order_posts_custom_column', array( __CLASS__, 'render_admin_list_badge' ), 20, 2 );
                        add_action( 'woocommerce_admin_order_data_after_order_number', array( __CLASS__, 'render_admin_order_header_badge' ) );
                }

                /**
                 * Whether the VIP button should be visible for the order.
                 */
                public static function should_show_button( \WC_Order $order ): bool {
                        if ( ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                return false;
                        }

                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                $target_id = (int) $item->get_variation_id();
                                if ( $target_id <= 0 ) {
                                        $target_id = (int) $item->get_product_id();
                                }
                                if ( $target_id <= 0 ) {
                                        continue;
                                }

                                $incoming = Incoming_Stock_Indexer::get_product_details( $target_id );
                                if ( empty( $incoming ) ) {
                                        continue;
                                }

                                $desired_total  = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : max( 0, (int) $item->get_quantity() );
                                if ( $desired_total <= 0 ) {
                                        continue;
                                }

                                $allocated      = function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ? lpr_allocator_get_item_allocated_active( $item ) : 0;
                                $missing        = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ? lpr_allocator_calc_backorder_need( $item ) : max( 0, $desired_total - $allocated );
                                $earliest_in    = lpr_allocator_sanitize_ymd( (string) ( $incoming[0]['eta'] ?? '' ) );
                                $current_earlie = self::item_earliest_eta( $item );

                                if ( $missing > 0 ) {
                                        return true;
                                }

                                if ( $earliest_in && ( '' === $current_earlie || lpr_allocator_compare_dates( $current_earlie, $earliest_in ) > 0 ) ) {
                                        return true;
                                }
                        }

                        return false;
                }

                /**
                 * Whether the order is flagged as VIP.
                 */
                public static function is_vip_order( \WC_Order $order ): bool {
                        if ( ! $order instanceof \WC_Order ) {
                                return false;
                        }

                        $flag = $order->get_meta( '_lpr_vip_order', true );
                        if ( ! empty( $flag ) && 'no' !== $flag ) {
                                return true;
                        }

                        foreach ( array( '_vip_order', 'vip_order', 'vip' ) as $fallback ) {
                                $alt = $order->get_meta( $fallback, true );
                                if ( ! empty( $alt ) && 'no' !== $alt ) {
                                        return true;
                                }
                        }

                        return false;
                }

                /**
                 * Renderable VIP badge HTML.
                 */
                public static function vip_badge_html(): string {
                        return '<span class="lpr-badge lpr-badge-vip">' . esc_html__( 'VIP', 'lpr-backorder-allocator' ) . '</span>';
                }

                /**
                 * Append VIP badge to order numbers across admin/front-end surfaces.
                 */
                public static function add_badge_to_order_number( $number, $order ): string {
                        if ( is_admin() && ! wp_doing_ajax() ) {
                                return (string) $number;
                        }

                        if ( $order instanceof \WC_Order && self::is_vip_order( $order ) ) {
                                return (string) $number . ' ' . self::vip_badge_html();
                        }
                        return (string) $number;
                }

                /**
                 * Append VIP badge in the orders list after the order number.
                 */
                public static function render_admin_list_badge( string $column, $post_id ): void {
                        if ( 'order_number' !== $column ) {
                                return;
                        }

                        $order = \wc_get_order( $post_id );
                        if ( ! $order instanceof \WC_Order || ! self::is_vip_order( $order ) ) {
                                return;
                        }

                        echo ' ' . self::vip_badge_html();
                }

                /**
                 * Add VIP badge beside the order number on the order edit screen.
                 */
                public static function render_admin_order_header_badge( $order ): void {
                        if ( $order instanceof \WC_Order && self::is_vip_order( $order ) ) {
                                echo ' ' . self::vip_badge_html();
                        }
                }

                /**
                 * AJAX: preview VIP reallocations.
                 */
                public static function ajax_preview(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        $order_id = isset( $_POST['order_id'] ) ? absint( $_POST['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $nonce    = isset( $_POST['_wpnonce'] ) ? (string) $_POST['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        if ( $order_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_vip_' . $order_id ) ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }

                        $overrides_raw = isset( $_POST['source_overrides'] ) ? wp_unslash( (string) $_POST['source_overrides'] ) : '';
                        $overrides     = array();
                        if ( $overrides_raw ) {
                                $decoded = json_decode( $overrides_raw, true );
                                if ( is_array( $decoded ) ) {
                                        foreach ( $decoded as $item_id => $order_override ) {
                                                $iid = absint( $item_id );
                                                $oid = absint( $order_override );
                                                if ( $iid > 0 && $oid > 0 ) {
                                                        $overrides[ $iid ] = $oid;
                                                }
                                        }
                                }
                        }

                        $plan = self::build_plan( $order_id, $overrides );
                        if ( empty( $plan['items'] ) ) {
                                wp_send_json_error( array( 'message' => __( 'No eligible VIP moves found.', 'lpr-backorder-allocator' ) ) );
                        }

                        $key     = 'lpr_vip_plan_' . wp_generate_uuid4();
                        $payload = array(
                                'order_id' => (int) $order_id,
                                'plan'     => $plan,
                                'created'  => time(),
                        );
                        set_transient( $key, $payload, 10 * MINUTE_IN_SECONDS );

                        $html = self::render_preview_modal( $plan, $key, $nonce, wp_create_nonce( 'lpr_vip_' . $order_id ) );

                        wp_send_json_success( array(
                                'html' => $html,
                        ) );
                }

                /**
                 * AJAX: apply confirmed plan.
                 */
                public static function ajax_confirm(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                        }

                        $key   = isset( $_POST['plan_key'] ) ? sanitize_text_field( wp_unslash( $_POST['plan_key'] ) ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $nonce = isset( $_POST['_wpnonce'] ) ? (string) $_POST['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        $payload = $key ? get_transient( $key ) : false;
                        if ( ! $payload || ! is_array( $payload ) ) {
                                wp_send_json_error( array( 'message' => __( 'This VIP preview expired. Please retry.', 'lpr-backorder-allocator' ) ) );
                        }

                        $overrides_raw = isset( $_POST['source_overrides'] ) ? wp_unslash( (string) $_POST['source_overrides'] ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $overrides     = array();
                        if ( $overrides_raw ) {
                                $decoded = json_decode( $overrides_raw, true );
                                if ( is_array( $decoded ) ) {
                                        foreach ( $decoded as $item_id => $source_id ) {
                                                $iid = absint( $item_id );
                                                $sid = absint( $source_id );
                                                if ( $iid > 0 && $sid > 0 ) {
                                                        $overrides[ $iid ] = $sid;
                                                }
                                        }
                                }
                        }

                        $order_id = isset( $payload['order_id'] ) ? (int) $payload['order_id'] : 0;
                        if ( $order_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_vip_' . $order_id ) ) {
                                delete_transient( $key );
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }

                        $plan = isset( $payload['plan'] ) ? $payload['plan'] : array();
                        if ( ! empty( $overrides ) ) {
                                $rebuilt = self::build_plan( $order_id, $overrides );
                                if ( empty( $rebuilt['items'] ) ) {
                                        delete_transient( $key );
                                        wp_send_json_error( array( 'message' => __( 'Nothing to apply.', 'lpr-backorder-allocator' ) ) );
                                }
                                $plan = $rebuilt;
                        }
                        if ( empty( $plan['items'] ) ) {
                                delete_transient( $key );
                                wp_send_json_error( array( 'message' => __( 'Nothing to apply.', 'lpr-backorder-allocator' ) ) );
                        }

                        $ok = self::apply_plan( $plan );
                        delete_transient( $key );

                        if ( ! $ok ) {
                                wp_send_json_error( array( 'message' => __( 'Unable to apply VIP changes. Please retry.', 'lpr-backorder-allocator' ) ) );
                        }

                        wp_send_json_success();
                }

                /**
                 * Build the VIP plan for an order.
                 */
                protected static function build_plan( int $order_id, array $source_overrides = array() ): array {
                        $order = wc_get_order( $order_id );
                        if ( ! ( $order instanceof \WC_Order ) ) {
                                return array();
                        }

                        $items_plan      = array();
                        $backorder_lines = function_exists( __NAMESPACE__ . '\lpr_allocator_count_backorder_lines' ) ? lpr_allocator_count_backorder_lines( $order ) : 0;

                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                $target_id = (int) $item->get_variation_id();
                                if ( $target_id <= 0 ) {
                                        $target_id = (int) $item->get_product_id();
                                }
                                if ( $target_id <= 0 ) {
                                        continue;
                                }

                                $entries = class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ? Incoming_Stock_Indexer::get_product_details( $target_id ) : array();
                                if ( empty( $entries ) ) {
                                        continue;
                                }

                                $normalized = self::normalize_entries( $entries, $target_id, (int) $order->get_id() );
                                if ( empty( $normalized ) ) {
                                        continue;
                                }

                                $preferred_order = isset( $source_overrides[ (int) $item->get_id() ] ) ? (int) $source_overrides[ (int) $item->get_id() ] : 0;
                                if ( $preferred_order > 0 ) {
                                        $normalized = self::prioritize_borrowables( $normalized, $preferred_order );
                                }

                                $available_sources = self::list_borrowable_sources( $normalized );

                                $desired_total = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : max( 0, (int) $item->get_quantity() );
                                if ( $desired_total <= 0 ) {
                                        continue;
                                }

                                $current = function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ? lpr_allocator_get_item_allocated_active( $item ) : 0;
                                $missing = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ? lpr_allocator_calc_backorder_need( $item ) : max( 0, $desired_total - $current );

                                // Aim to fill earliest PO first.
                                $first      = $normalized[0];
                                $vip_po_map = self::current_po_map( $item );
                                $vip_on_first = isset( $vip_po_map[ $first['po_id'] ] ) ? max( 0, (int) $vip_po_map[ $first['po_id'] ] ) : 0;
                                $first_supply = $first['free'];
                                foreach ( $first['borrowable'] as $row ) {
                                        $first_supply += $row['qty'];
                                }
                                $desired_first = max( 0, min( $desired_total, $vip_on_first + $first_supply ) - $vip_on_first );
                                $needed        = max( $missing, $desired_first );

                                $displaced      = array();
                                $vip_allocs     = array();
                                $new_qty        = 0;
                                $needed_running = $needed;

                                foreach ( $normalized as $idx => &$entry ) {
                                        if ( $needed_running <= 0 ) {
                                                break;
                                        }

                                        $pulled = self::pull_from_entry( $entry, $needed_running, $order_id, $displaced );
                                        if ( $pulled > 0 ) {
                                                $vip_allocs[] = array(
                                                        'po_id'     => $entry['po_id'],
                                                        'po_number' => $entry['po_number'],
                                                        'eta'       => $entry['eta'],
                                                        'qty'       => $pulled,
                                                );
                                                $new_qty        += $pulled;
                                                $needed_running -= $pulled;
                                        }
                                }
                                unset( $entry );

                                if ( $new_qty <= 0 && empty( $displaced ) ) {
                                        continue;
                                }

                                $release_qty = max( 0, ( $current + $new_qty ) - $desired_total );

                                // Reassign displaced orders to later POs/backorder using remaining free stock.
                                $reassignments = self::reassign_displaced( $displaced, $normalized );
                                if ( empty( $reassignments ) && ! empty( $displaced ) ) {
                                        // Safety fallback: keep the raw displacement details if reassignment failed.
                                        $reassignments = $displaced;
                                }

                                        $items_plan[] = array(
                                                'item_id'             => (int) $item->get_id(),
                                                'product_id'          => $target_id,
                                                'name'                => $item->get_name(),
                                                'current_eta'         => self::item_earliest_eta( $item ),
                                                'new_eta'             => self::project_new_eta( $item, $vip_allocs ),
                                                'vip_allocs'          => $vip_allocs,
                                                'vip_release'         => $release_qty,
                                                'displacements'       => $reassignments,
                                                'sources'             => $available_sources,
                                                'selected_source'     => $preferred_order,
                                                'order_backorder_lines' => $backorder_lines,
                                        );
                                }

                        return array(
                                'order_id' => (int) $order_id,
                                'items'    => $items_plan,
                        );
                }

                /**
                 * Apply stored plan.
                 */
                protected static function apply_plan( array $plan ): bool {
                        if ( empty( $plan['order_id'] ) || empty( $plan['items'] ) ) {
                                return false;
                        }

                        $vip_order = wc_get_order( (int) $plan['order_id'] );
                        if ( ! ( $vip_order instanceof \WC_Order ) ) {
                                return false;
                        }

                        $affected_orders = array( (int) $vip_order->get_id() => true );

                        foreach ( $plan['items'] as $item_plan ) {
                                $item_id = isset( $item_plan['item_id'] ) ? (int) $item_plan['item_id'] : 0;
                                if ( $item_id <= 0 ) {
                                        continue;
                                }
                                $item = $vip_order->get_item( $item_id );
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                self::apply_allocations_to_item( $vip_order, $item, $item_plan );

                                // Apply displacements for other orders.
                                foreach ( $item_plan['displacements'] as $disp ) {
                                        $lost_order_id = isset( $disp['order_id'] ) ? (int) $disp['order_id'] : 0;
                                        $lost_item_id  = isset( $disp['item_id'] ) ? (int) $disp['item_id'] : 0;
                                        if ( $lost_order_id <= 0 || $lost_item_id <= 0 ) {
                                                continue;
                                        }
                                        $lost_order = wc_get_order( $lost_order_id );
                                        if ( ! ( $lost_order instanceof \WC_Order ) ) {
                                                continue;
                                        }
                                        $lost_item = $lost_order->get_item( $lost_item_id );
                                        if ( ! ( $lost_item instanceof \WC_Order_Item_Product ) ) {
                                                continue;
                                        }

                                        $qty_taken = isset( $disp['qty_taken'] ) ? max( 0, (int) $disp['qty_taken'] ) : 0;
                                        $from_po   = isset( $disp['from_po'] ) ? (int) $disp['from_po'] : 0;
                                        $release_reason = __( 'Allocation moved to higher-priority VIP order.', 'lpr-backorder-allocator' );
                                        if ( $qty_taken > 0 && $from_po > 0 ) {
                                                $released = self::release_from_po( $lost_item, $from_po, $qty_taken, $release_reason );
                                                if ( $released > 0 ) {
                                                        lpr_allocator_add_release_note( $lost_order, $lost_item, (int) $released, $release_reason );
                                                }
                                        }

                                        if ( ! empty( $disp['new_allocs'] ) ) {
                                                foreach ( $disp['new_allocs'] as $add ) {
                                                        $qty_add = isset( $add['qty'] ) ? max( 0, (int) $add['qty'] ) : 0;
                                                        $po_id   = isset( $add['po_id'] ) ? (int) $add['po_id'] : 0;
                                                        if ( $qty_add > 0 && $po_id > 0 ) {
                                                                $alloc_reason = __( 'VIP displacement allocation.', 'lpr-backorder-allocator' );

                                                                self::add_allocation_row( $lost_order, $lost_item, $po_id, (string) ( $add['po_number'] ?? '' ), (string) ( $add['eta'] ?? '' ), $qty_add, $alloc_reason );
                                                        }
                                                }
                                        }

                                        $note = sprintf(
                                                /* translators: 1: qty, 2: product name, 3: ETA or backorder */
                                                __( 'Allocation adjusted by VIP order: moved %1$dx %2$s to later supply (new ETA: %3$s).', 'lpr-backorder-allocator' ),
                                                (int) $qty_taken,
                                                $lost_item->get_name(),
                                                ! empty( $disp['new_eta'] ) ? lpr_allocator_format_store_date( (string) $disp['new_eta'] ) : __( 'backorder', 'lpr-backorder-allocator' )
                                        );
                                        $lost_order->add_order_note( $note, false, true );
                                        $lost_order->save();
                                        $affected_orders[ (int) $lost_order->get_id() ] = true;
                                }
                        }

                        // Refresh ETA for all touched orders and resync PO line tallies.
                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                foreach ( array_keys( $affected_orders ) as $oid ) {
                                        ETA::update_line_eta( (int) $oid );
                                }
                        }

                        foreach ( array_keys( $affected_orders ) as $oid ) {
                                if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                        lpr_allocator_reapply_po_allocations_for_order( (int) $oid );
                                }
                        }

                        $vip_order->update_meta_data( '_lpr_vip_order', 'yes' );
                        $vip_order->save();

                        return true;
                }

                /**
                 * Apply VIP allocations and release adjustments for a specific item.
                 */
                protected static function apply_allocations_to_item( \WC_Order $order, \WC_Order_Item_Product $item, array $plan ): void {
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                $allocs = array();
                        }

                        $added_total = 0;
                        foreach ( $plan['vip_allocs'] as $add ) {
                                $qty_add = isset( $add['qty'] ) ? max( 0, (int) $add['qty'] ) : 0;
                                $po_id   = isset( $add['po_id'] ) ? (int) $add['po_id'] : 0;
                                if ( $qty_add <= 0 || $po_id <= 0 ) {
                                        continue;
                                }

                                $timestamp = current_time( 'mysql' );

                                $row = array(
                                        'po_id'         => $po_id,
                                        'po_number'     => isset( $add['po_number'] ) ? (string) $add['po_number'] : '',
                                        'qty_allocated' => (int) $qty_add,
                                        'eta'           => isset( $add['eta'] ) ? (string) $add['eta'] : '',
                                        'status'        => 'reserved',
                                        'status_changed_at' => $timestamp,
                                        'allocated_at'  => $timestamp,
                                );

                                $allocs[] = $row;
                                lpr_allocator_index_po_allocation( $po_id, (int) $order->get_id(), (int) $item->get_id() );
                                $added_total += $qty_add;
                        }

                        // Release from latest allocations to keep totals aligned with order quantity.
                        $release_qty = isset( $plan['vip_release'] ) ? max( 0, (int) $plan['vip_release'] ) : 0;
                        if ( $release_qty > 0 ) {
                        $released = array(
                                'allocs'   => $allocs,
                                'released' => 0,
                        );

                        $released = self::release_from_latest( $allocs, $release_qty );
                        $allocs   = $released['allocs'];

                        if ( $released['released'] > 0 ) {
                                $release_reason = __( 'VIP prioritization freed later allocation rows to avoid over-allocation.', 'lpr-backorder-allocator' );

                                lpr_allocator_add_release_note( $order, $item, (int) $released['released'], $release_reason );

                                        lpr_allocator_log_event(
                                                'allocation_released',
                                                array(
                                                        'order_id' => $order->get_id(),
                                                        'item_id'  => $item->get_id(),
                                                        'qty'      => (int) $released['released'],
                                                        'po_id'    => 'mixed',
                                                        'reason'   => $release_reason,
                                                )
                                        );
                        }
                        }

                        $item->update_meta_data( $meta_key, $allocs );
                        $item->save();

                        if ( $added_total > 0 ) {
                                $note = sprintf(
                                        /* translators: 1: qty, 2: product name */
                                        __( 'VIP prioritization pulled %1$dx %2$s to the earliest available PO.', 'lpr-backorder-allocator' ),
                                        (int) $added_total,
                                        $item->get_name()
                                );
                                $order->add_order_note( $note, false, true );
                        }
                }

                /**
                 * Release allocation quantities from the latest ETA rows.
                 *
                 * @param array $allocs
                 * @param int   $qty
                 * @return array
                 */
                protected static function release_from_latest( array $allocs, int $qty ): array {
                        if ( $qty <= 0 ) {
                                return array(
                                        'allocs'   => $allocs,
                                        'released' => 0,
                                );
                        }

                        usort(
                                $allocs,
                                static function ( $a, $b ) {
                                        $ea = isset( $a['eta'] ) ? (string) $a['eta'] : '';
                                        $eb = isset( $b['eta'] ) ? (string) $b['eta'] : '';
                                        if ( $ea === $eb ) {
                                                return 0;
                                        }
                                        if ( '' === $ea ) {
                                                return 1;
                                        }
                                        if ( '' === $eb ) {
                                                return -1;
                                        }
                                        return lpr_allocator_compare_dates( $eb, $ea ); // latest first
                                }
                        );

                        $released = 0;

                        foreach ( $allocs as &$row ) {
                                if ( $qty <= 0 ) {
                                        break;
                                }
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }
                                $row_qty = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                if ( $row_qty <= 0 ) {
                                        continue;
                                }
                                if ( $qty >= $row_qty ) {
                                        lpr_allocator_touch_allocation_status( $row, 'released' );
                                        $qty      -= $row_qty;
                                        $released += $row_qty;
                                } else {
                                        $row['qty_allocated'] = $row_qty - $qty;
                                        $qty                  = 0;
                                }
                        }
                        unset( $row );

                        return array(
                                'allocs'   => $allocs,
                                'released' => $released,
                        );
                }

                /**
                 * Release a specific quantity tied to a PO from an item.
                 */
                protected static function release_from_po( \WC_Order_Item_Product $item, int $po_id, int $qty, string $reason = '' ): int {
                        if ( $po_id <= 0 || $qty <= 0 ) {
                                return 0;
                        }
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                return 0;
                        }

                        $released = 0;

                        foreach ( $allocs as &$row ) {
                                if ( $qty <= 0 ) {
                                        break;
                                }
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }
                                $row_po  = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                $row_qty = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                if ( $row_po !== $po_id || $row_qty <= 0 ) {
                                        continue;
                                }
                                if ( $qty >= $row_qty ) {
                                        lpr_allocator_touch_allocation_status( $row, 'released' );
                                        $qty      -= $row_qty;
                                        $released += $row_qty;
                                } else {
                                        $row['qty_allocated'] = $row_qty - $qty;
                                        $qty                  = 0;
                                }
                        }
                        unset( $row );

                        $item->update_meta_data( $meta_key, $allocs );
                        $item->save();

                        if ( $released > 0 ) {
                                lpr_allocator_log_event(
                                        'allocation_released',
                                        array(
                                                'order_id' => $item->get_order_id(),
                                                'item_id'  => $item->get_id(),
                                                'po_id'    => $po_id,
                                                'qty'      => (int) $released,
                                                'reason'   => $reason ? $reason : 'Allocation release',
                                        )
                                );
                        }

                        return $released;
                }

                /**
                 * Add a fresh allocation row.
                 */
                protected static function add_allocation_row( \WC_Order $order, \WC_Order_Item_Product $item, int $po_id, string $po_number, string $eta, int $qty, string $reason = '' ): void {
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                $allocs = array();
                        }

                        $timestamp = current_time( 'mysql' );

                        $allocs[] = array(
                                'po_id'         => $po_id,
                                'po_number'     => $po_number,
                                'qty_allocated' => (int) $qty,
                                'eta'           => $eta,
                                'status'        => 'reserved',
                                'status_changed_at' => $timestamp,
                                'allocated_at'  => $timestamp,
                        );

                        $item->update_meta_data( $meta_key, $allocs );
                        $item->save();

                        lpr_allocator_index_po_allocation( $po_id, (int) $order->get_id(), (int) $item->get_id() );

                        lpr_allocator_log_event(
                                'allocation_reserved',
                                array(
                                        'order_id'  => $order->get_id(),
                                        'item_id'   => $item->get_id(),
                                        'po_id'     => $po_id,
                                        'po_number' => $po_number,
                                        'qty'       => (int) $qty,
                                        'eta'       => $eta,
                                        'reason'    => $reason ? $reason : 'Allocation recorded',
                                )
                        );
                }

                /**
                 * Generate preview modal HTML.
                 */
                protected static function render_preview_modal( array $plan, string $plan_key, string $nonce, string $preview_nonce ): string {
                        ob_start();
                        ?>
                        <div class="lpr-vip-modal" data-order="<?php echo esc_attr( $plan['order_id'] ); ?>" data-preview="<?php echo esc_attr( $preview_nonce ); ?>">
                                <header>
                                        <h3><?php echo esc_html__( 'VIP prioritization preview', 'lpr-backorder-allocator' ); ?></h3>
                                        <a href="#" class="lpr-vip-cancel" aria-label="<?php esc_attr_e( 'Close', 'lpr-backorder-allocator' ); ?>">&times;</a>
                                </header>
                                <div class="lpr-vip-body">
                                        <table>
                                                <thead>
                                                        <tr>
                                                                <th><?php echo esc_html__( 'Product', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'VIP current ETA', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'VIP new ETA', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'Qty to move', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'Choose order to pull from', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'Order losing allocation', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'Losing order ETA', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'New ETA after move', 'lpr-backorder-allocator' ); ?></th>
                                                                <th><?php echo esc_html__( 'Qty taken', 'lpr-backorder-allocator' ); ?></th>
                                                        </tr>
                                                </thead>
                                                <tbody>
                                                <?php foreach ( $plan['items'] as $item ) :
                                                        $vip_qty    = 0;
                                                        $sources    = ! empty( $item['sources'] ) && is_array( $item['sources'] ) ? $item['sources'] : array();
                                                        $selected   = isset( $item['selected_source'] ) ? (int) $item['selected_source'] : 0;
                                                        $current_d  = $item['current_eta'] ? lpr_allocator_format_store_date( $item['current_eta'] ) : 'â€”';
                                                        $new_eta_d  = $item['new_eta'] ? lpr_allocator_format_store_date( $item['new_eta'] ) : 'â€”';
                                                        foreach ( $item['vip_allocs'] as $a ) {
                                                                $vip_qty += (int) ( $a['qty'] ?? 0 );
                                                        }
                                                        $rows = ! empty( $item['displacements'] ) && is_array( $item['displacements'] ) ? $item['displacements'] : array();
                                                        if ( empty( $rows ) ) :
                                                                ?>
                                                                <tr>
                                                                        <td><?php echo esc_html( $item['name'] ); ?></td>
                                                                        <td><?php echo esc_html( $current_d ); ?></td>
                                                                        <td><?php echo esc_html( $new_eta_d ); ?></td>
                                                                        <td><?php echo esc_html( (string) $vip_qty ); ?></td>
                                                                        <td>
                                                                                <select class="lpr-vip-source" data-item="<?php echo esc_attr( $item['item_id'] ); ?>">
                                                                                        <option value=""><?php esc_html_e( 'Auto (latest first)', 'lpr-backorder-allocator' ); ?></option>
                                                                                        <?php foreach ( $sources as $source ) :
                                                                                                $eta_display = ! empty( $source['eta'] ) ? lpr_allocator_format_store_date( (string) $source['eta'] ) : 'â€”';
                                                                                                ?>
                                                                                                <option value="<?php echo esc_attr( $source['order_id'] ); ?>" <?php selected( $selected, (int) $source['order_id'] ); ?>>
                                                                                                        <?php echo esc_html( '#' . ( $source['order_number'] ?? $source['order_id'] ) . ' (' . ( $eta_display ?: 'â€”' ) . ')' ); ?>
                                                                                                </option>
                                                                                        <?php endforeach; ?>
                                                                                </select>
                                                                        </td>
                                                                        <td colspan="4"><?php echo esc_html__( 'No other orders will lose allocation for this move.', 'lpr-backorder-allocator' ); ?></td>
                                                                </tr>
                                                                <?php
                                                        else :
                                                                foreach ( $rows as $row ) :
                                                                $loss_eta = isset( $row['current_eta'] ) ? lpr_allocator_format_store_date( (string) $row['current_eta'] ) : '';
                                                                $new_eta  = isset( $row['new_eta'] ) ? lpr_allocator_format_store_date( (string) $row['new_eta'] ) : '';
                                                                ?>
                                                                <tr>
                                                                        <td><?php echo esc_html( $item['name'] ); ?></td>
                                                                        <td><?php echo esc_html( $current_d ); ?></td>
                                                                        <td><?php echo esc_html( $new_eta_d ); ?></td>
                                                                        <td><?php echo esc_html( (string) $vip_qty ); ?></td>
                                                                        <td>
                                                                                <select class="lpr-vip-source" data-item="<?php echo esc_attr( $item['item_id'] ); ?>">
                                                                                        <option value=""><?php esc_html_e( 'Auto (latest first)', 'lpr-backorder-allocator' ); ?></option>
                                                                                        <?php foreach ( $sources as $source ) :
                                                                                                $eta_display = ! empty( $source['eta'] ) ? lpr_allocator_format_store_date( (string) $source['eta'] ) : 'â€”';
                                                                                                ?>
                                                                                                <option value="<?php echo esc_attr( $source['order_id'] ); ?>" <?php selected( $selected, (int) $source['order_id'] ); ?>>
                                                                                                        <?php echo esc_html( '#' . ( $source['order_number'] ?? $source['order_id'] ) . ' (' . ( $eta_display ?: 'â€”' ) . ')' ); ?>
                                                                                                </option>
                                                                                        <?php endforeach; ?>
                                                                                </select>
                                                                        </td>
                                                                        <td><?php echo esc_html( $row['order_number'] ?? 'â€”' ); ?></td>
                                                                        <td><?php echo esc_html( $loss_eta ?: 'â€”' ); ?></td>
                                                                        <td><?php echo esc_html( $new_eta ?: __( 'backorder', 'lpr-backorder-allocator' ) ); ?></td>
                                                                        <td><?php echo esc_html( isset( $row['qty_taken'] ) ? (string) $row['qty_taken'] : '0' ); ?></td>
                                                                </tr>
                                                        <?php endforeach; endif; ?>
                                                <?php endforeach; ?>
                                                </tbody>
                                        </table>
                                        <p><?php echo esc_html__( 'Select a specific order to pull allocation from or leave auto selected to use the latest orders. No changes have been made yet.', 'lpr-backorder-allocator' ); ?></p>
                                </div>
                                <div class="lpr-actions">
                                        <button type="button" class="button lpr-vip-refresh"><?php echo esc_html__( 'Update preview', 'lpr-backorder-allocator' ); ?></button>
                                        <button type="button" class="button button-secondary lpr-vip-cancel"><?php echo esc_html__( 'Cancel', 'lpr-backorder-allocator' ); ?></button>
                                        <button type="button" class="button button-primary lpr-vip-confirm" data-plan="<?php echo esc_attr( $plan_key ); ?>" data-nonce="<?php echo esc_attr( $nonce ); ?>"><?php echo esc_html__( 'Confirm', 'lpr-backorder-allocator' ); ?></button>
                                </div>
                        </div>
                        <?php
                        return ob_get_clean();
                }

                /**
                 * Normalize incoming entries for a product.
                 */
                protected static function normalize_entries( array $entries, int $target_id, int $vip_order_id ): array {
                        $normalized = array();

                        foreach ( $entries as $entry ) {
                                $po_id     = isset( $entry['po_id'] ) ? (int) $entry['po_id'] : 0;
                                $po_number = isset( $entry['po_number'] ) ? (string) $entry['po_number'] : '';
                                $eta       = lpr_allocator_sanitize_ymd( (string) ( $entry['eta'] ?? '' ) );
                                $free      = isset( $entry['qty_free'] ) ? max( 0, (int) $entry['qty_free'] ) : 0;

                                if ( $po_id <= 0 || '' === $eta ) {
                                        continue;
                                }

                                $normalized[] = array(
                                        'po_id'      => $po_id,
                                        'po_number'  => $po_number,
                                        'eta'        => $eta,
                                        'free'       => $free,
                                        'borrowable' => self::collect_po_allocations( $po_id, $target_id, $vip_order_id ),
                                );
                        }

                        usort(
                                $normalized,
                                static function ( $a, $b ) {
                                        $ae = $a['eta'] ?? '';
                                        $be = $b['eta'] ?? '';
                                        if ( $ae === $be ) {
                                                return ( $a['po_id'] ?? 0 ) <=> ( $b['po_id'] ?? 0 );
                                        }
                                        if ( '' === $ae ) {
                                                return 1;
                                        }
                                        if ( '' === $be ) {
                                                return -1;
                                        }
                                        return lpr_allocator_compare_dates( $ae, $be );
                                }
                        );

                        return $normalized;
                }

                /**
                 * Collect allocations for a PO/product that could be borrowed (latest orders first).
                 */
                protected static function collect_po_allocations( int $po_id, int $target_id, int $vip_order_id ): array {
                        $borrowable = array();

                        if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_po_allocation_index' ) ) {
                                return $borrowable;
                        }

                        $po_status = get_post_status( $po_id );
                        if ( ! in_array( $po_status, lpr_allocator_live_po_statuses(), true ) ) {
                                return $borrowable;
                        }

                        $index = lpr_allocator_get_po_allocation_index( $po_id );
                        foreach ( $index as $entry ) {
                                $oid = isset( $entry['order_id'] ) ? (int) $entry['order_id'] : 0;
                                $iid = isset( $entry['item_id'] ) ? (int) $entry['item_id'] : 0;
                                if ( $oid <= 0 || $iid <= 0 || $oid === $vip_order_id ) {
                                        continue;
                                }
                                $order = wc_get_order( $oid );
                                if ( ! ( $order instanceof \WC_Order ) ) {
                                        continue;
                                }
                                if ( 'completed' === $order->get_status() ) {
                                        continue;
                                }
                                $item = $order->get_item( $iid );
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                $match = false;
                                $vid   = (int) $item->get_variation_id();
                                $pid   = (int) $item->get_product_id();
                                if ( $vid > 0 ) {
                                        $match = ( $vid === $target_id );
                                } else {
                                        $match = ( $pid === $target_id );
                                }
                                if ( ! $match ) {
                                        continue;
                                }

                                $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                                $allocs   = $item->get_meta( $meta_key, true );
                                if ( ! is_array( $allocs ) ) {
                                        continue;
                                }

                                $qty_on_po = 0;
                                foreach ( $allocs as $row ) {
                                        $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                        if ( 'released' === $status ) {
                                                continue;
                                        }
                                        $row_po = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                        if ( $row_po !== $po_id ) {
                                                continue;
                                        }
                                        $qty_on_po += isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                }

                                if ( $qty_on_po <= 0 ) {
                                        continue;
                                }

                                $borrowable[] = array(
                                        'order_id'     => $oid,
                                        'item_id'      => $iid,
                                        'qty'          => $qty_on_po,
                                        'order_date'   => $order->get_date_created() ? $order->get_date_created()->getTimestamp() : 0,
                                        'order_number' => $order->get_order_number(),
                                        'current_eta'  => self::item_earliest_eta( $item ),
                                        'po_id'        => $po_id,
                                );
                        }

                        usort(
                                $borrowable,
                                static function ( $a, $b ) {
                                        return ( $b['order_date'] ?? 0 ) <=> ( $a['order_date'] ?? 0 );
                                }
                        );

                        return $borrowable;
                }

                /**
                 * Move a preferred order to the top of the borrowable queue.
                 */
                protected static function prioritize_borrowables( array $entries, int $preferred_order_id ): array {
                        if ( $preferred_order_id <= 0 ) {
                                return $entries;
                        }

                        foreach ( $entries as &$entry ) {
                                if ( empty( $entry['borrowable'] ) || ! is_array( $entry['borrowable'] ) ) {
                                        continue;
                                }

                                usort(
                                        $entry['borrowable'],
                                        static function ( $a, $b ) use ( $preferred_order_id ) {
                                                $a_id = (int) ( $a['order_id'] ?? 0 );
                                                $b_id = (int) ( $b['order_id'] ?? 0 );

                                                if ( $a_id === $b_id ) {
                                                        return 0;
                                                }

                                                if ( $a_id === $preferred_order_id ) {
                                                        return -1;
                                                }
                                                if ( $b_id === $preferred_order_id ) {
                                                        return 1;
                                                }

                                                return ( $b['order_date'] ?? 0 ) <=> ( $a['order_date'] ?? 0 );
                                        }
                                );
                        }
                        unset( $entry );

                        return $entries;
                }

                /**
                 * Provide a flattened list of unique orders that can be borrowed from.
                 */
                protected static function list_borrowable_sources( array $entries ): array {
                        $sources = array();

                        foreach ( $entries as $entry ) {
                                if ( empty( $entry['borrowable'] ) || ! is_array( $entry['borrowable'] ) ) {
                                        continue;
                                }
                                foreach ( $entry['borrowable'] as $row ) {
                                        $oid = isset( $row['order_id'] ) ? (int) $row['order_id'] : 0;
                                        if ( $oid <= 0 || isset( $sources[ $oid ] ) ) {
                                                continue;
                                        }

                                        $sources[ $oid ] = array(
                                                'order_id'     => $oid,
                                                'order_number' => (string) ( $row['order_number'] ?? '' ),
                                                'eta'          => (string) ( $row['current_eta'] ?? '' ),
                                                'qty'          => isset( $row['qty'] ) ? (int) $row['qty'] : 0,
                                        );
                                }
                        }

                        return array_values( $sources );
                }

                /**
                 * Pull quantity from a PO entry (free first, then latest orders on that PO).
                 */
                protected static function pull_from_entry( array &$entry, int $needed, int $vip_order_id, array &$displaced ): int {
                        $allocated = 0;
                        if ( $needed <= 0 ) {
                                return 0;
                        }

                        $use_free = min( $needed, $entry['free'] );
                        $entry['free'] -= $use_free;
                        $needed        -= $use_free;
                        $allocated     += $use_free;

                        foreach ( $entry['borrowable'] as &$row ) {
                                if ( $needed <= 0 ) {
                                        break;
                                }
                                $take = min( $needed, $row['qty'] );
                                if ( $take <= 0 ) {
                                        continue;
                                }

                                $row['qty'] -= $take;
                                $needed     -= $take;
                                $allocated  += $take;

                                $displaced[] = array(
                                        'order_id'     => $row['order_id'],
                                        'item_id'      => $row['item_id'],
                                        'order_number' => $row['order_number'],
                                        'qty_taken'    => $take,
                                        'current_eta'  => $row['current_eta'],
                                        'from_po'      => $entry['po_id'],
                                );
                        }
                        unset( $row );

                        return $allocated;
                }

                /**
                 * Reassign displaced quantities to later POs or backorder.
                 */
                protected static function reassign_displaced( array $displaced, array &$entries ): array {
                        $result = array();

                        foreach ( $displaced as $row ) {
                                $qty = isset( $row['qty_taken'] ) ? max( 0, (int) $row['qty_taken'] ) : 0;
                                if ( $qty <= 0 ) {
                                        continue;
                                }

                                $new_eta   = '';
                                $new_alloc = array();

                                // Find the index of the PO we took from to only use later POs.
                                $start_index = 0;
                                foreach ( $entries as $idx => $entry ) {
                                        if ( (int) $entry['po_id'] === (int) $row['from_po'] ) {
                                                $start_index = $idx + 1;
                                                break;
                                        }
                                }

                                for ( $i = $start_index; $i < count( $entries ) && $qty > 0; $i++ ) {
                                        $avail = $entries[ $i ]['free'];
                                        if ( $avail <= 0 ) {
                                                continue;
                                        }
                                        $take = min( $qty, $avail );
                                        $entries[ $i ]['free'] -= $take;
                                        $qty                   -= $take;

                                        $new_alloc[] = array(
                                                'po_id'     => $entries[ $i ]['po_id'],
                                                'po_number' => $entries[ $i ]['po_number'],
                                                'eta'       => $entries[ $i ]['eta'],
                                                'qty'       => $take,
                                        );

                                        if ( '' === $new_eta ) {
                                                $new_eta = $entries[ $i ]['eta'];
                                        }
                                }

                                if ( $qty > 0 ) {
                                        $new_eta = '';
                                }

                                $row['new_eta']   = $new_eta;
                                $row['new_allocs'] = $new_alloc;
                                $result[]          = $row;
                        }

                        return $result;
                }

                /**
                 * Map current allocations per PO for an item.
                 */
                protected static function current_po_map( \WC_Order_Item_Product $item ): array {
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                return array();
                        }
                        $map = array();
                        foreach ( $allocs as $row ) {
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }
                                $po_id = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                if ( $po_id <= 0 ) {
                                        continue;
                                }
                                $qty = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                if ( $qty <= 0 ) {
                                        continue;
                                }
                                if ( ! isset( $map[ $po_id ] ) ) {
                                        $map[ $po_id ] = 0;
                                }
                                $map[ $po_id ] += $qty;
                        }
                        return $map;
                }

                /**
                 * Calculate earliest ETA for an item.
                 */
                protected static function item_earliest_eta( \WC_Order_Item_Product $item ): string {
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        $earliest = '';
                        if ( is_array( $allocs ) ) {
                                foreach ( $allocs as $row ) {
                                        $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                        if ( 'released' === $status ) {
                                                continue;
                                        }
                                        $eta_row = '';
                                        if ( ! empty( $row['eta'] ) ) {
                                                $eta_row = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                        }
                                        if ( '' === $eta_row && ! empty( $row['po_id'] ) ) {
                                                $eta_row = lpr_allocator_sanitize_ymd( (string) get_post_meta( (int) $row['po_id'], defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                                        }
                                        if ( '' === $eta_row ) {
                                                continue;
                                        }
                                        if ( '' === $earliest || lpr_allocator_compare_dates( $eta_row, $earliest ) < 0 ) {
                                                $earliest = $eta_row;
                                        }
                                }
                        }
                        return $earliest;
                }

                /**
                 * Estimate new ETA after applying allocations.
                 */
                protected static function project_new_eta( \WC_Order_Item_Product $item, array $vip_allocs ): string {
                        $eta = self::item_earliest_eta( $item );
                        foreach ( $vip_allocs as $row ) {
                                $eta_row = lpr_allocator_sanitize_ymd( (string) ( $row['eta'] ?? '' ) );
                                if ( '' === $eta_row ) {
                                        continue;
                                }
                                if ( '' === $eta || lpr_allocator_compare_dates( $eta_row, $eta ) < 0 ) {
                                        $eta = $eta_row;
                                }
                        }
                        return $eta;
                }
        }
        Order_VIP_Prioritizer::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Requested_Delivery_Date_Box' ) ) {
        /**
         * Order admin metabox to capture a requested delivery date.
         */
        class Requested_Delivery_Date_Box {

                public static function init(): void {
                        add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 25 );
                        add_action( 'add_meta_boxes_shop_order', array( __CLASS__, 'register_box' ), 25 );
                        add_action( 'add_meta_boxes_woocommerce_page_wc-orders', array( __CLASS__, 'register_box' ), 25 );

                        add_action( 'woocommerce_process_shop_order_meta', array( __CLASS__, 'save_meta' ), 20, 2 );
                        add_action( 'woocommerce_before_order_object_save', array( __CLASS__, 'maybe_save_meta_from_object' ), 20, 2 );
                }

                public static function register_box(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        add_meta_box(
                                'lpr_requested_delivery',
                                __( 'Requested Delivery Date', 'lpr-backorder-allocator' ),
                                array( __CLASS__, 'render_box' ),
                                'shop_order',
                                'side',
                                'default'
                        );

                        add_meta_box(
                                'lpr_requested_delivery',
                                __( 'Requested Delivery Date', 'lpr-backorder-allocator' ),
                                array( __CLASS__, 'render_box' ),
                                'woocommerce_page_wc-orders',
                                'side',
                                'default'
                        );
                }

                public static function render_box( $post_or_screen ): void {
                        if ( ! function_exists( 'wc_get_order' ) ) {
                                return;
                        }

                        $order_id = self::resolve_order_id( $post_or_screen );
                        $order    = wc_get_order( $order_id );
                        $value    = '';
                        if ( $order instanceof \WC_Order ) {
                                $value = (string) $order->get_meta( defined( __NAMESPACE__ . '\ORDER_META_REQUESTED_DELIVERY' ) ? ORDER_META_REQUESTED_DELIVERY : '_lpr_requested_delivery_date', true );
                        }

                        wp_nonce_field( 'lpr_requested_delivery', 'lpr_requested_delivery_nonce' );

                                        woocommerce_wp_text_input(
                                                array(
                                                        'id'                => 'lpr_requested_delivery',
                                                        'name'              => 'lpr_requested_delivery',
                                                        'type'              => 'text',
                                                        'label'             => __( 'Requested delivery date (dd-mm-yyyy)', 'lpr-backorder-allocator' ),
                                                        'class'             => 'short',
                                                        'value'             => lpr_allocator_sanitize_ymd( $value ),
                                                        'custom_attributes' => array(
                                                                'pattern'     => '\\d{2}-\\d{2}-\\d{4}',
                                                                'placeholder' => 'DD-MM-YYYY',
                                                        ),
                                                )
                                        );
                        echo '<p class="description">' . esc_html__( 'We aim to have the order ready at least 14 days before this date. Leave blank for ASAP.', 'lpr-backorder-allocator' ) . '</p>';
                }

                public static function save_meta( int $order_id, $order = null ): void {
                        self::persist_request( $order_id, $order );
                }

                public static function maybe_save_meta_from_object( $order, $data_store ): void { // phpcs:ignore WordPress.NamingConventions.ValidVariableName.PropertyNotSnakeCase
                        unset( $data_store );
                        if ( $order instanceof \WC_Order ) {
                                self::persist_request( (int) $order->get_id(), $order );
                        }
                }

                protected static function persist_request( int $order_id, $order = null ): void {
                        if ( $order_id <= 0 ) {
                                return;
                        }

                        if ( empty( $_POST['lpr_requested_delivery_nonce'] ) || ! wp_verify_nonce( wp_unslash( $_POST['lpr_requested_delivery_nonce'] ), 'lpr_requested_delivery' ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                                return;
                        }

                        $raw      = isset( $_POST['lpr_requested_delivery'] ) ? (string) wp_unslash( $_POST['lpr_requested_delivery'] ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $val      = lpr_allocator_sanitize_ymd( $raw );
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_META_REQUESTED_DELIVERY' ) ? ORDER_META_REQUESTED_DELIVERY : '_lpr_requested_delivery_date';
                        $prev     = '';

                        if ( $order instanceof \WC_Order ) {
                                $prev = (string) $order->get_meta( $meta_key, true );
                                $order->update_meta_data( $meta_key, $val );
                                self::after_request_change( (int) $order->get_id(), $prev, $val );
                                return;
                        }

                        $prev = (string) get_post_meta( $order_id, $meta_key, true );
                        if ( '' === $val ) {
                                delete_post_meta( $order_id, $meta_key );
                        } else {
                                update_post_meta( $order_id, $meta_key, $val );
                        }

                        self::after_request_change( $order_id, $prev, $val );
                }

                protected static function after_request_change( int $order_id, string $previous, string $current ): void {
                        if ( $previous === $current ) {
                                return;
                        }

                        if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                ETA::update_line_eta( $order_id );
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                lpr_allocator_reapply_po_allocations_for_order( $order_id );
                        }

                        if ( class_exists( __NAMESPACE__ . '\Auto_PO_Allocator' ) ) {
                                Auto_PO_Allocator::run();
                        }
                }


                protected static function resolve_order_id( $context ): int {
                        $order_id = 0;
                        if ( $context instanceof \WP_Post ) {
                                $order_id = (int) $context->ID;
                        }
                        if ( $order_id <= 0 && isset( $_GET['id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                                $order_id = absint( $_GET['id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        }
                        return $order_id;
                }
        }
        Requested_Delivery_Date_Box::init();
}

/* SELF-CHECK:
- Added Backorder::needs_allocation(WC_Order_Item_Product) using settings order_statuses, product->backorders_allowed(), and Backordered meta / is_on_backorder($qty).
- Added ETA::update_line_eta($order_id) to compute earliest d-m-Y ETA across non-released allocations and persist to _lpr_line_eta; hooked on order save (classic + HPOS) with re-entrancy guard.
- Added admin-only "Allocations & ETA" metabox for orders (classic + HPOS screen ids). Shows per-line ETA or "Unallocated" and lists allocation rows (PO #, qty, ETA, status).
- All declarations are guarded; HPOS-safe (Woo CRUD only); no frontend hooks; no stock writes; no wildcard meta queries.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() && ! lpr_allocator_is_incoming_request() ) {
        return;
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_product_option_label' ) ) {
	/**
	 * Build a readable option label for a product/variation.
	 *
	 * @param int $id Product or variation ID.
	 * @return string
	 */
	function lpr_allocator_product_option_label( int $id ): string {
		if ( ! function_exists( 'wc_get_product' ) ) {
			return '#' . $id;
		}
		$product = wc_get_product( $id );
		if ( ! $product instanceof \WC_Product ) {
			return '#' . $id;
		}
		$name = wp_strip_all_tags( $product->get_formatted_name() );
		$sku  = $product->get_sku();
		if ( $sku ) {
			$name .= ' (' . $sku . ')';
		}
		return $name;
	}
}

if ( ! class_exists( __NAMESPACE__ . '\Supplier_PO_Live_Product_UI' ) ) {
	/**
	 * Overrides the PO Lines metabox to use Woo's live product (and variations) search.
	 * Does not alter storage format; on save, existing handler in Supplier_PO_CPT::save_post remains in charge.
	 */
	class Supplier_PO_Live_Product_UI {

		public static function init(): void {
			// Swap the original PO Lines metabox for our live-search version (run after original registration).
			add_action( 'add_meta_boxes', array( __CLASS__, 'swap_lines_metabox' ), 100 );
			// Enqueue Woo enhanced select on our CPT screen.
			add_action( 'admin_enqueue_scripts', array( __CLASS__, 'enqueue_assets' ) );
			// Preprocess posted lines (server-side safety): map select_id -> product_id/variation_id before original save handler runs.
			add_action( 'save_post', array( __CLASS__, 'preprocess_save' ), 5, 2 );
		}

		/**
		 * Remove original lines box and add our enhanced one.
		 */
		public static function swap_lines_metabox(): void {
			remove_meta_box( 'lpr_po_lines', defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po', 'normal' );
			add_meta_box(
				'lpr_po_lines',
				__( 'PO Lines (Live Product Search)', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_lines_metabox_live' ),
				defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
				'normal',
				'default'
			);
		}

		/**
		 * Enqueue WooCommerce enhanced select assets on our CPT screen.
		 */
		public static function enqueue_assets( $hook ): void {
			$screen = function_exists( 'get_current_screen' ) ? get_current_screen() : null;
			if ( $screen && isset( $screen->post_type ) && $screen->post_type === ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) ) {
				// Core Woo assets (already registered by Woo).
				wp_enqueue_style( 'woocommerce_admin_styles' );
				wp_enqueue_script( 'wc-enhanced-select' ); // loads SelectWoo + init event
			}
		}

		/**
		 * Render the enhanced PO lines box with live product search.
		 */
		public static function render_lines_metabox_live( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_lines_action', 'lpr_po_lines_nonce' );
                        $lines = lpr_allocator_refresh_po_allocation_state( (int) $post->ID );
                        if ( ! is_array( $lines ) ) {
                                $lines = array();
                        }

			?>
			<style>
				#lpr_po_lines table { width: 100%; border-collapse: collapse; }
				#lpr_po_lines th, #lpr_po_lines td { border-bottom: 1px solid #ddd; padding: 6px; text-align:left; vertical-align: top; }
				#lpr_po_lines .actions { text-align: right; margin-top: 8px; }
				#lpr_po_lines input[type="number"] { width: 110px; }
				#lpr_po_lines input[type="text"] { width: 170px; }
				#lpr_po_lines .lpr-product-cell .select2-container { min-width: 320px; }
			</style>
			<table class="widefat striped" id="lpr-po-lines-table">
				<thead>
					<tr>
						<th><?php echo esc_html__( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Ordered', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Allocated', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'ETA Override (d-m-Y)', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Received', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<?php
					$idx = 0;
					foreach ( $lines as $line ) :
						$product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
						$variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
						$chosen_id    = $variation_id > 0 ? $variation_id : $product_id;
						$qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
						$qty_alloc    = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
                                                $eta_override = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
						$qty_recv     = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;

						$label = $chosen_id ? lpr_allocator_product_option_label( $chosen_id ) : '';
						?>
						<tr>
							<td class="lpr-product-cell">
								<select
									class="wc-product-search lpr-product-select"
									name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][select_ui]"
									data-placeholder="<?php echo esc_attr__( 'Search for a productâ€¦', 'lpr-backorder-allocator' ); ?>"
									data-action="woocommerce_json_search_products_and_variations"
									data-minimum_input_length="1"
									data-allow_clear="true"
									style="min-width: 320px;"
								>
									<?php if ( $chosen_id ) : ?>
										<option value="<?php echo esc_attr( (string) $chosen_id ); ?>" selected="selected">
											<?php echo esc_html( $label ); ?>
										</option>
									<?php endif; ?>
								</select>
								<input type="hidden" class="lpr-select-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][select_id]" value="<?php echo esc_attr( (string) $chosen_id ); ?>" />
								<input type="hidden" class="lpr-product-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][product_id]" value="<?php echo esc_attr( (string) $product_id ); ?>" />
								<input type="hidden" class="lpr-variation-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][variation_id]" value="<?php echo esc_attr( (string) $variation_id ); ?>" />
							</td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_ordered]" value="<?php echo esc_attr( (string) $qty_ordered ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_allocated]" value="<?php echo esc_attr( (string) $qty_alloc ); ?>" /></td>
                                                        <td><input type="text" class="short" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][eta_override]" value="<?php echo esc_attr( $eta_override ); ?>" placeholder="DD-MM-YYYY" pattern="\d{2}-\d{2}-\d{4}" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_received]" value="<?php echo esc_attr( (string) $qty_recv ); ?>" /></td>
							<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></button></td>
						</tr>
						<?php
						$idx++;
					endforeach;
					?>
				</tbody>
			</table>
			<div class="actions">
				<button type="button" class="button button-secondary" id="lpr-add-line"><?php echo esc_html__( 'Add Line', 'lpr-backorder-allocator' ); ?></button>
			</div>
			<script>
				(function($){
					function initEnhancedSelect(context){
						$(document.body).trigger('wc-enhanced-select-init');
						// Bind change to keep hidden IDs in sync for each row.
						$(context).find('select.lpr-product-select').off('change.lpr').on('change.lpr', function(){
							var $sel = $(this),
								val  = $sel.val() || '';
							var $row = $sel.closest('tr');
							$row.find('input.lpr-select-id').val(val);
							// Optimistic client-side guess: set product_id to selected id; server will correct to variation_id if needed.
							$row.find('input.lpr-product-id').val(val);
							$row.find('input.lpr-variation-id').val('');
						});
					}
					function nextIndex($tbody){
						let max = -1;
						$tbody.find('tr').each(function(){
							const first = $(this).find('input[name^="lpr_po_lines["], select[name^="lpr_po_lines["]').first();
							const m = first.attr('name') && first.attr('name').match(/^lpr_po_lines\[(\d+)\]/);
							if(m){ max = Math.max(max, parseInt(m[1],10)); }
						});
						return max + 1;
					}
					const $tbody = $('#lpr-po-lines-table').find('tbody');
					$('#lpr-add-line').on('click', function(e){
						e.preventDefault();
						const i = nextIndex($tbody);
                                                const rowHtml =
                                                        '<tr>' +
                                                                '<td class="lpr-product-cell">' +
                                                                        '<select class="wc-product-search lpr-product-select" name="lpr_po_lines['+i+'][select_ui]" data-placeholder="<?php echo esc_js( __( 'Search for a productâ€¦', 'lpr-backorder-allocator' ) ); ?>" data-action="woocommerce_json_search_products_and_variations" data-minimum_input_length="1" data-allow_clear="true" style="min-width:320px;"></select>' +
									'<input type="hidden" class="lpr-select-id" name="lpr_po_lines['+i+'][select_id]" value="" />' +
									'<input type="hidden" class="lpr-product-id" name="lpr_po_lines['+i+'][product_id]" value="" />' +
									'<input type="hidden" class="lpr-variation-id" name="lpr_po_lines['+i+'][variation_id]" value="" />' +
								'</td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_ordered]" value="0" /></td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_allocated]" value="0" /></td>' +
'<td><input type="text" class="short" name="lpr_po_lines['+i+'][eta_override]" value="" placeholder="DD-MM-YYYY" pattern="\\d{2}-\\d{2}-\\d{4}" /></td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_received]" value="0" /></td>' +
								'<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_js( __( 'Remove', 'lpr-backorder-allocator' ) ); ?></button></td>' +
                                                        '</tr>';
                                                const $row = $(rowHtml).appendTo($tbody);
                                                initEnhancedSelect($row);
                                        });
					$tbody.on('click', '.lpr-remove-line', function(e){
						e.preventDefault();
						$(this).closest('tr').remove();
					});
					// Initialize existing selects.
					initEnhancedSelect($tbody);
					// Ensure hidden select_id is populated before submit.
					$('#post').on('submit', function(){
						$tbody.find('select.lpr-product-select').each(function(){
							var val = $(this).val() || '';
							var $row = $(this).closest('tr');
							$row.find('input.lpr-select-id').val(val);
							if(!val){
								// If empty ensure IDs are cleared to prevent stale values.
								$row.find('input.lpr-product-id, input.lpr-variation-id').val('');
							}
						});
					});
				})(jQuery);
			</script>
			<p class="description">
				<?php echo esc_html__( 'Use the live search to pick any product or variation. Received defaults to 0. Allocation is a ledger only; no stock writes.', 'lpr-backorder-allocator' ); ?>
			</p>
			<?php
		}

		/**
		 * Server-side safety: translate posted select_id into product_id or variation_id
		 * so the existing Supplier_PO_CPT::save_post logic can validate & persist correctly.
		 */
		public static function preprocess_save( int $post_id, \WP_Post $post ): void {
			if ( ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) || wp_is_post_revision( $post_id ) ) {
				return;
			}
			if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			// Only proceed if our nonce is present/valid (same as main save handler).
			if ( empty( $_POST['lpr_po_lines_nonce'] ) || ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_lines_nonce'] ) ), 'lpr_po_lines_action' ) ) {
				return;
			}
			if ( empty( $_POST['lpr_po_lines'] ) || ! is_array( $_POST['lpr_po_lines'] ) ) {
				return;
			}
			$lines = &$_POST['lpr_po_lines']; // phpcs:ignore WordPress.Security.NonceVerification.Missing
			foreach ( $lines as $idx => &$row ) {
				if ( ! is_array( $row ) ) {
					continue;
				}
				$sel_id = isset( $row['select_id'] ) ? absint( $row['select_id'] ) : 0;
				// Only normalize when both product_id and variation_id are empty or zero.
				$pid    = isset( $row['product_id'] ) ? absint( $row['product_id'] ) : 0;
				$vid    = isset( $row['variation_id'] ) ? absint( $row['variation_id'] ) : 0;

				if ( $sel_id && 0 === $pid && 0 === $vid && function_exists( 'wc_get_product' ) ) {
					$p = wc_get_product( $sel_id );
					if ( $p instanceof \WC_Product ) {
						if ( $p->is_type( 'variation' ) ) {
							$row['variation_id'] = (string) $sel_id;
							$row['product_id']   = '';
						} else {
							$row['product_id']   = (string) $sel_id;
							$row['variation_id'] = '';
						}
					}
				}
			}
			unset( $row ); // break reference
		}
	}
	Supplier_PO_Live_Product_UI::init();
}

/* SELF-CHECK:
- Added Supplier_PO_Live_Product_UI class to replace the PO Lines metabox with a fast live product/variation search using Woo's `wc-enhanced-select` and the `woocommerce_json_search_products_and_variations` AJAX endpoint (covers all product types & variations).
- Kept storage contract intact: we still save meta `_lpr_po_lines` lines with `{product_id|variation_id, qty_ordered, qty_allocated, eta_override, qty_received}`. We do not write stock.
- Implemented `preprocess_save()` (priority 5) to map posted `select_id` to `product_id` or `variation_id` server-side so the existing `Supplier_PO_CPT::save_post()` validation & persistence continue to work without re-declaration. Also includes nonce/cap checks.
- Enqueued Woo admin assets only on the Supplier PO screen; no frontend hooks; admin/cron-only check kept at file top.
- Performance: relies on Wooâ€™s optimized JSON search; no wildcard meta_query in our code; batch UI handling only. HPOS-safe (CRUD via wc_get_product); no raw SQL.
- Security: capabilities checked, nonces verified, all user input sanitized/escaped.
- Helper function added `lpr_allocator_product_option_label()` (guarded) for preselected labels.
- Existing features intact: Settings tab (WooCommerce â†’ Settings â†’ Backorders), CPT "Supplier POs" admin screens (list + edit with live search), Order admin metabox "Allocations & ETA".
- Avoided re-declarations by using a new class and removing+re-adding only the specific metabox via hooks.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() && ! lpr_allocator_is_incoming_request() ) {
        return;
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ) {
/**
 * Calculate remaining backordered qty for an order item (ledger-aware).
 * Uses forced-allocation meta or recorded Backordered quantity from order time;
 * ignores live product stock state.
 *
 * @param \WC_Order_Item_Product $item
 * @return int Remaining units needing allocation (>=0).
 */
        function lpr_allocator_calc_backorder_need( \WC_Order_Item_Product $item ): int {
                if ( ! $item instanceof \WC_Order_Item_Product ) {
                        return 0;
                }
                $qty = max( 0, (int) $item->get_quantity() );
                $product = $item->get_product();
                if ( ! ( $product instanceof \WC_Product ) ) {
                        return 0;
                }

                // Desired backorder amount from item meta if present.
                $desired = lpr_allocator_calc_backorder_desired( $item );

                // Subtract existing active allocations (non-released).
                $allocs = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
		$allocated_active = 0;
		if ( is_array( $allocs ) ) {
			foreach ( $allocs as $row ) {
				$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
				if ( 'released' === $status ) {
					continue;
				}
				$allocated_active += isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
			}
		}

		$need = max( 0, $desired - $allocated_active );
		// Hard cap to line item qty for safety.
		$need = min( $need, $qty );

		return $need;
	}
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_count_backorder_lines' ) ) {
        /**
         * Count how many line items on an order are still on backorder (need allocation or awaiting PO supply).
         */
        function lpr_allocator_count_backorder_lines( \WC_Order $order ): int {
                if ( ! ( $order instanceof \WC_Order ) ) {
                        return 0;
                }

                $count = 0;

                foreach ( $order->get_items( 'line_item' ) as $item ) {
                        if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                continue;
                        }

                        $need = lpr_allocator_calc_backorder_need( $item );
                        if ( $need > 0 ) {
                                $count++;
                                continue;
                        }

                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                continue;
                        }

                        foreach ( $allocs as $row ) {
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }
                                if ( isset( $row['qty_allocated'] ) && (int) $row['qty_allocated'] > 0 ) {
                                        $count++;
                                        break;
                                }
                        }
                }

                return $count;
        }
}

if ( ! class_exists( __NAMESPACE__ . '\PO_FIFO_Allocator' ) ) {
	/**
	 * FIFO allocator that assigns PO quantities to backordered order items (ledger only).
	 */
	class PO_FIFO_Allocator {

		/**
		 * Hook registrations.
		 */
		public static function init(): void {
			// Admin-post handler for the Allocate button.
			add_action( 'admin_post_lpr_allocate_po', array( __CLASS__, 'handle_allocate_request' ) );

			// Action Scheduler consumer (async). Group: lpr-allocator.
			add_action( 'lpr_allocator_allocate_po', array( __CLASS__, 'allocate_po' ), 10, 1 );
		}

		/**
		 * Handle Allocate button click from PO screen.
		 */
		public static function handle_allocate_request(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			$po_id = isset( $_GET['po_id'] ) ? absint( $_GET['po_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			if ( $po_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_allocate_po_' . $po_id ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}

			$redirect = get_edit_post_link( $po_id, 'url' );
			$queued   = false;

			// Prefer async queue; fallback to inline if Action Scheduler unavailable.
			if ( function_exists( 'as_enqueue_async_action' ) ) {
				as_enqueue_async_action( 'lpr_allocator_allocate_po', array( 'po_id' => $po_id ), 'lpr-allocator' );
				$queued = true;
			} elseif ( function_exists( 'as_schedule_single_action' ) ) {
				as_schedule_single_action( time(), 'lpr_allocator_allocate_po', array( 'po_id' => $po_id ), 'lpr-allocator' );
				$queued = true;
			} else {
				// Inline execution.
				self::allocate_po( $po_id );
			}

			wp_safe_redirect( add_query_arg( array( 'lpr_alloc' => $queued ? 'queued' : 'done' ), $redirect ) );
			exit;
		}

		/**
		 * Allocate a single PO across backordered items in FIFO order.
		 *
		 * @param int $po_id
		 * @return void
		 */
                public static function allocate_po( int $po_id ): void {
                        $po = get_post( $po_id );
                        if ( ! ( $po instanceof \WP_Post ) || ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $po->post_type ) {
                                return;
                        }

                        if ( ! in_array( $po->post_status, lpr_allocator_live_po_statuses(), true ) ) {
                                return;
                        }

			// Load PO lines and header defaults.
			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) || empty( $lines ) ) {
				return;
			}
			$po_number = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
			$po_eta    = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true );

			$affected_orders = array(); // order_id => true

			// Process each PO line independently with a per-SKU lock to avoid contention.
			foreach ( $lines as $idx => $line ) {
				$qty_ordered   = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
				$qty_allocated = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
				$eta_override  = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
				$variation_id  = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
				$product_id    = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;

				// Choose target (prioritize variation).
				$target_id = $variation_id > 0 ? $variation_id : $product_id;
				if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
					continue;
				}

				$remaining_for_line = max( 0, $qty_ordered - $qty_allocated );
				if ( $remaining_for_line <= 0 ) {
					continue;
				}

				$product = wc_get_product( $target_id );
				if ( ! ( $product instanceof \WC_Product ) ) {
					continue;
				}
				$sku = $product->get_sku();
				$lock_key = 'lpr_alloc_lock_' . md5( $sku ? 'sku:' . $sku : 'id:' . $target_id );
				if ( get_transient( $lock_key ) ) {
					// Another process is working this SKU; skip this line for now.
					continue;
				}
				set_transient( $lock_key, 1, 60 ); // short-lived lock

				try {
					$allocated_total = self::allocate_for_single_line(
						$po_id,
						$po_number,
						$po_eta,
						$target_id,
						$remaining_for_line,
						$eta_override,
						$affected_orders
					);

					// Increment line's qty_allocated and persist back to meta array.
					if ( $allocated_total > 0 ) {
						$lines[ $idx ]['qty_allocated'] = $qty_allocated + $allocated_total;
					}
				} finally {
					delete_transient( $lock_key );
				}
                        }

                        // Re-sync qty_allocated using the ledger/index to avoid regressions when orders leave scope.
                        $lines = lpr_allocator_recalculate_po_lines_from_allocations( $po_id, $lines );

                        // Persist updated lines only once.
                        update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );

			// Recompute ETAs for all affected orders (one pass).
			if ( ! empty( $affected_orders ) && class_exists( __NAMESPACE__ . '\ETA' ) ) {
				foreach ( array_keys( $affected_orders ) as $oid ) {
					ETA::update_line_eta( (int) $oid );
				}
			}
		}

		/**
		 * Allocate a single PO line across backordered order items in FIFO order.
		 *
		 * @param int      $po_id
		 * @param string   $po_number
		 * @param string   $po_eta_header
		 * @param int      $target_product_or_variation_id
		 * @param int      $remaining_for_line
		 * @param string   $eta_override
		 * @param string[] $affected_orders Reference accumulator.
		 * @return int Total quantity allocated from this line.
		 */
                protected static function allocate_for_single_line( int $po_id, string $po_number, string $po_eta_header, int $target_product_or_variation_id, int $remaining_for_line, string $eta_override, array &$affected_orders ): int {
                        if ( $remaining_for_line <= 0 ) {
                                return 0;
                        }

                        $eta_for_line = $eta_override ? $eta_override : lpr_allocator_sanitize_ymd( $po_eta_header );

                        // Build FIFO queue of candidate line items needing allocation.
                        $queue = self::build_fifo_queue( $target_product_or_variation_id, $remaining_for_line, $eta_for_line );

                        $allocated_total = 0;
                        $meta_key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $today_dt        = current_time( 'mysql' );
                        $eta_to_store    = $eta_for_line;

                        foreach ( $queue as $entry ) {
                                if ( $remaining_for_line <= 0 ) {
                                        break;
				}
				$order = wc_get_order( $entry['order_id'] );
				if ( ! ( $order instanceof \WC_Order ) ) {
					continue;
				}

				// Locate the target item by id.
				$target_item = null;
				foreach ( $order->get_items( 'line_item' ) as $it ) {
					if ( $it->get_id() === $entry['item_id'] ) {
						$target_item = $it;
						break;
					}
				}
				if ( ! ( $target_item instanceof \WC_Order_Item_Product ) ) {
					continue;
				}

				$need_for_item = lpr_allocator_calc_backorder_need( $target_item );
				if ( $need_for_item <= 0 ) {
					continue;
				}

				$allocate_now = min( $need_for_item, $remaining_for_line );
				if ( $allocate_now <= 0 ) {
					continue;
				}

				// Append ledger row.
				$allocs = $target_item->get_meta( $meta_key_allocs, true );
				if ( ! is_array( $allocs ) ) {
					$allocs = array();
				}
                                $allocs[] = array(
                                        'po_id'         => $po_id,
                                        'po_number'     => $po_number,
                                        'qty_allocated' => (int) $allocate_now,
                                        'eta'           => $eta_to_store,
                                        'status'        => 'reserved',
                                        'status_changed_at' => $today_dt,
                                        'allocated_at'  => $today_dt,
                                );
                                $target_item->update_meta_data( $meta_key_allocs, $allocs );
                                $target_item->save();

                                lpr_allocator_index_po_allocation( $po_id, (int) $order->get_id(), (int) $target_item->get_id() );

				// Note: private order note.
				$product     = $target_item->get_product();
				$sku         = $product instanceof \WC_Product ? $product->get_sku() : '';
				$line_name   = $target_item->get_name();
				$eta_display = $eta_to_store ? $eta_to_store : ( $po_eta_header ?: '-' );
                                $note = sprintf(
                                        /* translators: 1: qty, 2: item name, 3: SKU, 4: PO number, 5: ETA */
                                        __( 'Allocated %1$dx %2$s%3$s from PO #%4$s (ETA %5$s).', 'lpr-backorder-allocator' ),
					(int) $allocate_now,
					$line_name,
					$sku ? ' [' . $sku . ']' : '',
					$po_number ? $po_number : (string) $po_id,
                                        $eta_display
                                );
                                $order->add_order_note( $note, false, true );

                                lpr_allocator_log_event(
                                        'allocation_reserved',
                                        array(
                                                'order_id'   => $order->get_id(),
                                                'item_id'    => $target_item->get_id(),
                                                'product_id' => $target_product_or_variation_id,
                                                'qty'        => (int) $allocate_now,
                                                'po_id'      => $po_id,
                                                'po_number'  => $po_number,
                                                'eta'        => $eta_to_store,
                                                'reason'     => 'FIFO allocation to cover backorder demand',
                                        )
                                );

                                $affected_orders[ (int) $order->get_id() ] = true;

                                $remaining_for_line -= $allocate_now;
                                $allocated_total    += $allocate_now;
                        }

                        // Upgrade existing allocations on later POs when this earlier PO still has free qty.
                        if ( $remaining_for_line > 0 && '' !== $eta_for_line ) {
                                $improvement_candidates = self::collect_eta_improvement_candidates( $target_product_or_variation_id, $eta_for_line );

                                foreach ( $improvement_candidates as $candidate ) {
                                        if ( $remaining_for_line <= 0 ) {
                                                break;
                                        }

                                        $order = wc_get_order( $candidate['order_id'] );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        $target_item = $order->get_item( $candidate['item_id'] );
                                        if ( ! ( $target_item instanceof \WC_Order_Item_Product ) ) {
                                                continue;
                                        }

                                        $move_qty = min( (int) $candidate['qty'], $remaining_for_line );
                                        if ( $move_qty <= 0 ) {
                                                continue;
                                        }

                                        $moved = self::reallocate_from_later_po( $order, $target_item, $move_qty, $eta_to_store, $po_id, $po_number );
                                        if ( $moved > 0 ) {
                                                $affected_orders[ (int) $order->get_id() ] = true;
                                                $remaining_for_line -= $moved;
                                                $allocated_total    += $moved;
                                        }
                                }
                        }

                        // Consider reallocation for orders with a requested delivery date where this PO still meets the window
                        // but is later than their current allocation. Only move stock when it frees earlier supply that can serve
                        // unallocated orders or improve later ETAs.
                        if ( $remaining_for_line > 0 && '' !== $eta_for_line ) {
                                $realloc_candidates = self::collect_reallocation_candidates( $target_product_or_variation_id, $eta_for_line, $remaining_for_line );

                                foreach ( $realloc_candidates as $candidate ) {
                                        if ( $remaining_for_line <= 0 ) {
                                                break;
                                        }

                                        if ( ! self::has_priority_demand_for_eta( $target_product_or_variation_id, $candidate['earliest_eta'], $candidate['order_id'], $candidate['item_id'] ) ) {
                                                continue;
                                        }

                                        $order = wc_get_order( $candidate['order_id'] );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        $target_item = $order->get_item( $candidate['item_id'] );
                                        if ( ! ( $target_item instanceof \WC_Order_Item_Product ) ) {
                                                continue;
                                        }

                                        $move_qty = min( (int) $candidate['qty'], $remaining_for_line );
                                        if ( $move_qty <= 0 ) {
                                                continue;
                                        }

                                        $moved = self::reallocate_to_later_po( $order, $target_item, $move_qty, $eta_to_store, $po_id, $po_number );
                                        if ( $moved > 0 ) {
                                                $affected_orders[ (int) $order->get_id() ] = true;
                                                $remaining_for_line -= $moved;
                                                $allocated_total    += $moved;
                                        }
                                }
                        }

                        return $allocated_total;
                }

                /**
                 * Build a FIFO queue of order items needing allocation for a given product/variation.
                 * Sorted by requested ready-by date (ASAP first, then earliest ready_by), then paid date ASC (fallback created),
                 * then created ASC, then order ID ASC.
                 * Always evaluates every eligible order (paginated) so prioritisation is not biased by creation time.
                 *
                 * @param int    $target_id
                 * @param int    $required_total
                 * @param string $po_eta_for_line Current PO ETA (header or override) for eligibility checks.
                 * @return array[] Each item: [order_id, item_id, need, paid_ts, created_ts, ready_by]
                 */
                protected static function build_fifo_queue( int $target_id, int $required_total, string $po_eta_for_line ): array {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $statuses = array();
                        foreach ( (array) $settings['order_statuses'] as $st ) {
                                $statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
                        }

                        $queue = array();
                        $page  = 1;
                        $limit = 50;

                        do {
                                $args = array(
                                        'status'  => $statuses,
                                        'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date', // created date ASC. We'll re-sort by paid date later.
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
                                if ( empty( $order_ids ) ) {
                                        break;
                                }

                                foreach ( $order_ids as $oid ) {
                                        $order = wc_get_order( $oid );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }
                                        $paid     = $order->get_date_paid();
                                        $created  = $order->get_date_created();
                                        $paid_ts  = $paid ? (int) $paid->getTimestamp() : null;
                                        $created_ts = $created ? (int) $created->getTimestamp() : 0;
                                        $ready_by    = self::requested_ready_by( $order );
                                        $backorder_lines = function_exists( __NAMESPACE__ . '\lpr_allocator_count_backorder_lines' ) ? lpr_allocator_count_backorder_lines( $order ) : 0;
                                        if ( $backorder_lines <= 0 ) {
                                                continue; // No backorders left on this order.
                                        }

                                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                                        continue;
                                                }
						$itm_vid = (int) $item->get_variation_id();
						$itm_pid = (int) $item->get_product_id();
						$match   = ( $itm_vid > 0 ) ? ( $itm_vid === $target_id ) : ( $itm_pid === $target_id );
                                                if ( ! $match ) {
                                                        continue;
                                                }
                                                if ( class_exists( __NAMESPACE__ . '\Backorder' ) && ! Backorder::needs_allocation( $item ) ) {
                                                        continue;
                                                }
                                                $need = lpr_allocator_calc_backorder_need( $item );
                                                if ( $need <= 0 ) {
                                                        continue;
                                                }

                                                $defer_to_later_supply = $ready_by && $po_eta_for_line && lpr_allocator_compare_dates( $po_eta_for_line, $ready_by ) < 0 && self::has_later_supply_within_window( $target_id, $po_eta_for_line, $ready_by );
                                                if ( $defer_to_later_supply && $backorder_lines > 1 ) {
                                                        // Keep multi-product backorders in the earliest possible PO.
                                                        $defer_to_later_supply = false;
                                                }
                                                if ( $defer_to_later_supply ) {
                                                        continue;
                                                }

                                                if ( $ready_by && $po_eta_for_line && lpr_allocator_compare_dates( $po_eta_for_line, $ready_by ) > 0 ) {
                                                        // PO would arrive after the requested readiness window.
                                                        continue;
                                                }

                                                $queue[] = array(
                                                        'order_id'   => (int) $oid,
                                                        'item_id'    => (int) $item->get_id(),
                                                        'need'       => (int) $need,
                                                        'paid_ts'    => $paid_ts,
                                                        'created_ts' => $created_ts,
                                                        'ready_by'   => $ready_by,
                                                        'backorder_lines' => $backorder_lines,
                                                );
                                        }
                                }

                                $page++;
                        } while ( true );

			if ( empty( $queue ) ) {
				return array();
			}

                        usort(
                                $queue,
                                static function ( $a, $b ) {
                                        $ar = isset( $a['ready_by'] ) ? (string) $a['ready_by'] : '';
                                        $br = isset( $b['ready_by'] ) ? (string) $b['ready_by'] : '';
                                        if ( $ar !== $br ) {
                                                if ( '' === $ar ) {
                                                        return -1; // ASAP orders first.
                                                }
                                                if ( '' === $br ) {
                                                        return 1;
                                                }
                                                return lpr_allocator_compare_dates( $ar, $br );
                                        }

                                        $ap = isset( $a['paid_ts'] ) && null !== $a['paid_ts'] ? (int) $a['paid_ts'] : (int) $a['created_ts'];
                                        $bp = isset( $b['paid_ts'] ) && null !== $b['paid_ts'] ? (int) $b['paid_ts'] : (int) $b['created_ts'];
                                        if ( $ap !== $bp ) {
                                                return $ap <=> $bp;
                                        }
                                        if ( (int) $a['created_ts'] !== (int) $b['created_ts'] ) {
                                                return (int) $a['created_ts'] <=> (int) $b['created_ts'];
                                        }
                                        return (int) $a['order_id'] <=> (int) $b['order_id'];
                                }
                        );

                        return $queue;
                }

                /**
                 * Requested ready-by date (requested delivery minus 14 days) or empty string.
                 */
                protected static function requested_ready_by( \WC_Order $order ): string {
                        $requested = '';
                        if ( defined( __NAMESPACE__ . '\ORDER_META_REQUESTED_DELIVERY' ) ) {
                                $requested = (string) $order->get_meta( ORDER_META_REQUESTED_DELIVERY, true );
                        } else {
                                $requested = (string) $order->get_meta( '_lpr_requested_delivery_date', true );
                        }

                        $requested = lpr_allocator_sanitize_ymd( $requested );
                        if ( '' === $requested ) {
                                return '';
                        }

                        $ts = lpr_allocator_date_to_timestamp( $requested );
                        if ( $ts <= 0 ) {
                                return '';
                        }

                        return gmdate( 'd-m-Y', $ts - ( 14 * DAY_IN_SECONDS ) );
                }

                /**
                 * Collect allocated items that would get an earlier ETA by moving to the current PO.
                 *
                 * @param int    $target_id
                 * @param string $po_eta_for_line
                 * @return array[]
                 */
                protected static function collect_eta_improvement_candidates( int $target_id, string $po_eta_for_line ): array {
                        if ( '' === $po_eta_for_line ) {
                                return array();
                        }

                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $statuses = array();
                        foreach ( (array) $settings['order_statuses'] as $st ) {
                                $statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
                        }

                        $candidates = array();
                        $page       = 1;
                        $limit      = 50;

                        do {
                                $args = array(
                                        'status'  => $statuses,
                                        'limit'   => $limit,
                                        'page'    => $page,
                                        'orderby' => 'date',
                                        'order'   => 'ASC',
                                        'return'  => 'ids',
                                        'type'    => 'shop_order',
                                );
                                $order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
                                if ( empty( $order_ids ) ) {
                                        break;
                                }

                                foreach ( $order_ids as $oid ) {
                                        $order = wc_get_order( $oid );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        $ready_by = self::requested_ready_by( $order );
                                        if ( $ready_by && lpr_allocator_compare_dates( $po_eta_for_line, $ready_by ) > 0 ) {
                                                continue; // PO would miss readiness window.
                                        }

                                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                                        continue;
                                                }
                                                $itm_vid = (int) $item->get_variation_id();
                                                $itm_pid = (int) $item->get_product_id();
                                                $match   = ( $itm_vid > 0 ) ? ( $itm_vid === $target_id ) : ( $itm_pid === $target_id );
                                                if ( ! $match ) {
                                                        continue;
                                                }

                                                $summary = self::active_allocation_summary( $item );
                                                if ( $summary['total_qty'] <= 0 || '' === $summary['earliest_eta'] ) {
                                                        continue;
                                                }

                                                if ( lpr_allocator_compare_dates( $summary['earliest_eta'], $po_eta_for_line ) <= 0 ) {
                                                        continue; // Already as good or better.
                                                }

                                                $candidates[] = array(
                                                        'order_id' => (int) $oid,
                                                        'item_id'  => (int) $item->get_id(),
                                                        'qty'      => (int) $summary['total_qty'],
                                                );
                                        }
                                }

                                $page++;
                        } while ( count( $order_ids ) === $limit );

                        return $candidates;
                }

                /**
                 * Whether a later open PO can satisfy the requested date while this PO is earlier than needed.
                 */
                protected static function has_later_supply_within_window( int $target_id, string $po_eta_for_line, string $ready_by ): bool {
                        if ( '' === $po_eta_for_line || '' === $ready_by || ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                return false;
                        }

                        $entries = Incoming_Stock_Indexer::get_product_details( $target_id );
                        if ( empty( $entries ) ) {
                                return false;
                        }

                        foreach ( $entries as $entry ) {
                                $eta = lpr_allocator_sanitize_ymd( (string) ( $entry['eta'] ?? '' ) );
                                if ( '' === $eta ) {
                                        continue;
                                }

                                if ( lpr_allocator_compare_dates( $eta, $po_eta_for_line ) > 0 && lpr_allocator_compare_dates( $eta, $ready_by ) <= 0 && (int) ( $entry['qty_free'] ?? 0 ) > 0 ) {
                                        return true;
                                }
                        }

                        return false;
                }

                /**
                 * Identify orders that can be reallocated to this PO while respecting requested delivery windows.
                 *
                 * @param int    $target_id
                 * @param string $po_eta_for_line
                 * @param int    $max_qty Optional quantity cap for early exit once enough stock is found.
                 * @return array[]
                 */
                protected static function collect_reallocation_candidates( int $target_id, string $po_eta_for_line, int $max_qty = 0 ): array {
                        if ( '' === $po_eta_for_line ) {
                                return array();
                        }

                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $statuses = array();
                        foreach ( (array) $settings['order_statuses'] as $st ) {
                                $statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
                        }

                        $candidates      = array();
                        $page            = 1;
                        $limit           = 50;
                        $collected_qty   = 0;
                        $should_cap_qty  = $max_qty > 0;
                        $should_continue = true;

                        do {
                                $args = array(
                                        'status'  => $statuses,
                                        'limit'   => $limit,
                                        'page'    => $page,
                                        'orderby' => 'date',
                                        'order'   => 'ASC',
                                        'return'  => 'ids',
                                        'type'    => 'shop_order',
                                );
                                $order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
                                if ( empty( $order_ids ) ) {
                                        break;
                                }

                                foreach ( $order_ids as $oid ) {
                                        $order = wc_get_order( $oid );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        $ready_by = self::requested_ready_by( $order );
                                        if ( '' === $ready_by ) {
                                                continue; // only move orders that explicitly provided a requested date.
                                        }
                                        if ( lpr_allocator_compare_dates( $po_eta_for_line, $ready_by ) > 0 ) {
                                                continue; // PO would miss the readiness window.
                                        }
                                        $backorder_lines = function_exists( __NAMESPACE__ . '\lpr_allocator_count_backorder_lines' ) ? lpr_allocator_count_backorder_lines( $order ) : 0;
                                        if ( $backorder_lines > 1 ) {
                                                continue; // Multi-product backorders should keep the earlier allocation.
                                        }

                                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                                        continue;
                                                }
                                                $itm_vid = (int) $item->get_variation_id();
                                                $itm_pid = (int) $item->get_product_id();
                                                $match   = ( $itm_vid > 0 ) ? ( $itm_vid === $target_id ) : ( $itm_pid === $target_id );
                                                if ( ! $match ) {
                                                        continue;
                                                }

                                                // If the item still needs allocation, let the primary queue handle it.
                                                $need = lpr_allocator_calc_backorder_need( $item );
                                                if ( $need > 0 ) {
                                                        continue;
                                                }

                                                $summary = self::active_allocation_summary( $item );
                                                if ( $summary['total_qty'] <= 0 || '' === $summary['earliest_eta'] ) {
                                                        continue;
                                                }

                                                // Only move if this PO is later (but still acceptable) than the current ETA.
                                                if ( lpr_allocator_compare_dates( $po_eta_for_line, $summary['earliest_eta'] ) <= 0 ) {
                                                        continue;
                                                }

                                                $qty_for_item = (int) $summary['total_qty'];

                                                $candidates[] = array(
                                                        'order_id'        => (int) $oid,
                                                        'item_id'         => (int) $item->get_id(),
                                                        'qty'             => $qty_for_item,
                                                        'earliest_eta'    => $summary['earliest_eta'],
                                                        'backorder_lines' => $backorder_lines,
                                                );

                                                if ( $should_cap_qty ) {
                                                        $collected_qty += $qty_for_item;

                                                        if ( $collected_qty >= $max_qty ) {
                                                                $should_continue = false;
                                                                break 2;
                                                        }
                                                }
                                          }
                                  }

                                  $page++;
                        } while ( $should_continue && count( $order_ids ) === $limit );

                        return $candidates;
                }

                /**
                 * Summarize active allocations for an item.
                 *
                 * @param \WC_Order_Item_Product $item
                 * @return array{total_qty:int,earliest_eta:string,active_rows:array<int,array{index:int,qty:int,eta:string}>,allocs:array}
                 */
                protected static function active_allocation_summary( \WC_Order_Item_Product $item ): array {
                        $meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs   = $item->get_meta( $meta_key, true );
                        if ( ! is_array( $allocs ) ) {
                                $allocs = array();
                        }

                        $summary = array(
                                'total_qty'    => 0,
                                'earliest_eta' => '',
                                'active_rows'  => array(),
                                'allocs'       => $allocs,
                        );

                        foreach ( $allocs as $idx => $row ) {
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }

                                $qty = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                if ( $qty <= 0 ) {
                                        continue;
                                }

                                $eta_row = '';
                                if ( ! empty( $row['eta'] ) ) {
                                        $eta_row = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                }
                                if ( '' === $eta_row ) {
                                        $po_id = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
                                        if ( $po_id > 0 ) {
                                                $eta_row = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                                        }
                                }

                                $summary['total_qty'] += $qty;
                                $summary['active_rows'][] = array(
                                        'index' => (int) $idx,
                                        'qty'   => $qty,
                                        'eta'   => $eta_row,
                                );

                                if ( '' !== $eta_row && ( '' === $summary['earliest_eta'] || lpr_allocator_compare_dates( $eta_row, $summary['earliest_eta'] ) < 0 ) ) {
                                        $summary['earliest_eta'] = $eta_row;
                                }
                        }

                        usort(
                                $summary['active_rows'],
                                static function ( $a, $b ) {
                                        $ae = isset( $a['eta'] ) ? (string) $a['eta'] : '';
                                        $be = isset( $b['eta'] ) ? (string) $b['eta'] : '';
                                        if ( $ae === $be ) {
                                                return 0;
                                        }
                                        if ( '' === $ae ) {
                                                return 1;
                                        }
                                        if ( '' === $be ) {
                                                return -1;
                                        }
                                        return lpr_allocator_compare_dates( $ae, $be );
                                }
                        );

                        return $summary;
                }

                /**
                 * Determine if freeing earlier stock would benefit another order (unallocated or with a later ETA).
                 */
                protected static function has_priority_demand_for_eta( int $target_id, string $eta_threshold, int $exclude_order_id, int $exclude_item_id ): bool {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $statuses = array();
                        foreach ( (array) $settings['order_statuses'] as $st ) {
                                $statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
                        }

                        $page  = 1;
                        $limit = 50;

                        do {
                                $args = array(
                                        'status'  => $statuses,
                                        'limit'   => $limit,
                                        'page'    => $page,
                                        'orderby' => 'date',
                                        'order'   => 'ASC',
                                        'return'  => 'ids',
                                        'type'    => 'shop_order',
                                );
                                $order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
                                if ( empty( $order_ids ) ) {
                                        break;
                                }

                                foreach ( $order_ids as $oid ) {
                                        $order = wc_get_order( $oid );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                                        continue;
                                                }
                                                if ( (int) $order->get_id() === $exclude_order_id && (int) $item->get_id() === $exclude_item_id ) {
                                                        continue;
                                                }

                                                $itm_vid = (int) $item->get_variation_id();
                                                $itm_pid = (int) $item->get_product_id();
                                                $match   = ( $itm_vid > 0 ) ? ( $itm_vid === $target_id ) : ( $itm_pid === $target_id );
                                                if ( ! $match ) {
                                                        continue;
                                                }

                                                $need = lpr_allocator_calc_backorder_need( $item );
                                                if ( $need > 0 ) {
                                                        return true; // unallocated order can use freed stock.
                                                }

                                                $summary = self::active_allocation_summary( $item );
                                                if ( $summary['total_qty'] > 0 && '' !== $summary['earliest_eta'] && lpr_allocator_compare_dates( $summary['earliest_eta'], $eta_threshold ) > 0 ) {
                                                        return true; // could improve ETA.
                                                }
                                        }
                                }

                                $page++;
                        } while ( count( $order_ids ) === $limit );

                        return false;
                }

                /**
                 * Move an allocated item to the current PO, releasing earlier stock.
                 */
                protected static function reallocate_to_later_po( \WC_Order $order, \WC_Order_Item_Product $item, int $move_qty, string $eta_to_store, int $po_id, string $po_number ): int {
                        if ( $move_qty <= 0 ) {
                                return 0;
                        }

                        $meta_key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $summary         = self::active_allocation_summary( $item );
                        if ( $summary['total_qty'] <= 0 ) {
                                return 0;
                        }

                        $allocs             = $summary['allocs'];
                        $remaining_to_move  = $move_qty;

                        foreach ( $summary['active_rows'] as $row ) {
                                if ( $remaining_to_move <= 0 ) {
                                        break;
                                }
                                $idx      = $row['index'];
                                $row_qty  = isset( $allocs[ $idx ]['qty_allocated'] ) ? max( 0, (int) $allocs[ $idx ]['qty_allocated'] ) : 0;
                                if ( $row_qty <= 0 ) {
                                        continue;
                                }

                                if ( $remaining_to_move >= $row_qty ) {
                                        lpr_allocator_touch_allocation_status( $allocs[ $idx ], 'released' );
                                        $remaining_to_move -= $row_qty;
                                } else {
                                        $allocs[ $idx ]['qty_allocated'] = $row_qty - $remaining_to_move;
                                        $remaining_to_move               = 0;
                                }
                        }

                        $moved_qty = $move_qty - max( 0, $remaining_to_move );
                        if ( $moved_qty <= 0 ) {
                                return 0;
                        }

                        $timestamp = current_time( 'mysql' );

                        $allocs[] = array(
                                'po_id'         => $po_id,
                                'po_number'     => $po_number,
                                'qty_allocated' => (int) $moved_qty,
                                'eta'           => $eta_to_store,
                                'status'        => 'reserved',
                                'status_changed_at' => $timestamp,
                                'allocated_at'  => $timestamp,
                        );

                        $item->update_meta_data( $meta_key_allocs, $allocs );
                        $item->save();

                        lpr_allocator_index_po_allocation( $po_id, (int) $order->get_id(), (int) $item->get_id() );

                        $product   = $item->get_product();
                        $sku       = $product instanceof \WC_Product ? $product->get_sku() : '';
                        $line_name = $item->get_name();
                        $note = sprintf(
                                /* translators: 1: qty, 2: item name, 3: SKU, 4: PO number, 5: ETA */
                                __( 'Released and reallocated %1$dx %2$s%3$s to PO #%4$s (ETA %5$s) to honor requested delivery.', 'lpr-backorder-allocator' ),
                                (int) $moved_qty,
                                $line_name,
                                $sku ? ' [' . $sku . ']' : '',
                                $po_number ? $po_number : (string) $po_id,
                                $eta_to_store ? $eta_to_store : 'â€”'
                        );
                        $order->add_order_note( $note, false, true );

                        lpr_allocator_log_event(
                                'allocation_reallocated_later',
                                array(
                                        'order_id'  => $order->get_id(),
                                        'item_id'   => $item->get_id(),
                                        'qty'       => (int) $moved_qty,
                                        'po_id'     => $po_id,
                                        'po_number' => $po_number,
                                        'eta'       => $eta_to_store,
                                        'reason'    => 'Requested delivery window adjustment',
                                )
                        );

                        // Refresh PO line tallies after releasing earlier allocations.
                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                lpr_allocator_reapply_po_allocations_for_order( (int) $order->get_id() );
                        }

                        return $moved_qty;
                }

                /**
                 * Move an allocated item from a later PO to the current (earlier) PO without hurting other orders.
                 */
                protected static function reallocate_from_later_po( \WC_Order $order, \WC_Order_Item_Product $item, int $move_qty, string $eta_to_store, int $po_id, string $po_number ): int {
                        if ( $move_qty <= 0 ) {
                                return 0;
                        }

                        $meta_key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $summary         = self::active_allocation_summary( $item );
                        if ( $summary['total_qty'] <= 0 ) {
                                return 0;
                        }

                        $allocs            = $summary['allocs'];
                        $remaining_to_move = $move_qty;
                        $rows              = array_reverse( $summary['active_rows'] );

                        foreach ( $rows as $row ) {
                                if ( $remaining_to_move <= 0 ) {
                                        break;
                                }

                                $row_eta = isset( $row['eta'] ) ? (string) $row['eta'] : '';
                                if ( '' !== $row_eta && '' !== $eta_to_store && lpr_allocator_compare_dates( $row_eta, $eta_to_store ) <= 0 ) {
                                        continue; // Do not pull from allocations that already have an equal or better ETA.
                                }

                                $idx     = $row['index'];
                                $row_qty = isset( $allocs[ $idx ]['qty_allocated'] ) ? max( 0, (int) $allocs[ $idx ]['qty_allocated'] ) : 0;
                                if ( $row_qty <= 0 ) {
                                        continue;
                                }

                                if ( $remaining_to_move >= $row_qty ) {
                                        lpr_allocator_touch_allocation_status( $allocs[ $idx ], 'released' );
                                        $remaining_to_move -= $row_qty;
                                } else {
                                        $allocs[ $idx ]['qty_allocated'] = $row_qty - $remaining_to_move;
                                        $remaining_to_move               = 0;
                                }
                        }

                        $moved_qty = $move_qty - max( 0, $remaining_to_move );
                        if ( $moved_qty <= 0 ) {
                                return 0;
                        }

                        $timestamp = current_time( 'mysql' );

                        $allocs[] = array(
                                'po_id'         => $po_id,
                                'po_number'     => $po_number,
                                'qty_allocated' => (int) $moved_qty,
                                'eta'           => $eta_to_store,
                                'status'        => 'reserved',
                                'status_changed_at' => $timestamp,
                                'allocated_at'  => $timestamp,
                        );

                        $item->update_meta_data( $meta_key_allocs, $allocs );
                        $item->save();

                        lpr_allocator_index_po_allocation( $po_id, (int) $order->get_id(), (int) $item->get_id() );

                        $product   = $item->get_product();
                        $sku       = $product instanceof \WC_Product ? $product->get_sku() : '';
                        $line_name = $item->get_name();
                        $note = sprintf(
                                /* translators: 1: qty, 2: item name, 3: SKU, 4: PO number, 5: ETA */
                                __( 'Released and reallocated %1$dx %2$s%3$s to earlier PO #%4$s (ETA %5$s) to improve delivery.', 'lpr-backorder-allocator' ),
                                (int) $moved_qty,
                                $line_name,
                                $sku ? ' [' . $sku . ']' : '',
                                $po_number ? $po_number : (string) $po_id,
                                $eta_to_store ? $eta_to_store : 'â€”'
                        );
                        $order->add_order_note( $note, false, true );

                        lpr_allocator_log_event(
                                'allocation_reallocated_earlier',
                                array(
                                        'order_id'  => $order->get_id(),
                                        'item_id'   => $item->get_id(),
                                        'qty'       => (int) $moved_qty,
                                        'po_id'     => $po_id,
                                        'po_number' => $po_number,
                                        'eta'       => $eta_to_store,
                                        'reason'    => 'Improved delivery ETA for customer request',
                                )
                        );

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                lpr_allocator_reapply_po_allocations_for_order( (int) $order->get_id() );
                        }

                        return $moved_qty;
                }
        }
        PO_FIFO_Allocator::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Auto_PO_Allocator' ) ) {
        /**
         * Recurring job to allocate all open Supplier POs using the FIFO allocator.
         */
class Auto_PO_Allocator {

const ACTION_HOOK     = 'lpr_allocator_auto_allocate_open_pos';
const MAX_STORED_JOBS = 10;
const BATCH_SIZE      = 3;
const BATCH_SPACING_SECONDS = 15;

public static function init(): void {
add_action( 'init', array( __CLASS__, 'maybe_schedule' ) );
add_action( self::ACTION_HOOK, array( __CLASS__, 'run' ), 10, 3 );
add_action( 'transition_post_status', array( __CLASS__, 'handle_po_status_change' ), 10, 3 );
add_action( 'before_delete_post', array( __CLASS__, 'handle_po_delete' ) );
}

                public static function reset_schedule(): void {
                        if ( function_exists( 'as_unschedule_all_actions' ) ) {
                                as_unschedule_all_actions( self::ACTION_HOOK, null, 'lpr-allocator' );
                        } else {
                                self::clear_wp_cron_events();
                        }
                        self::maybe_schedule( true );
                }

                protected static function clear_wp_cron_events(): void {
                        if ( ! function_exists( '_get_cron_array' ) ) {
                                wp_clear_scheduled_hook( self::ACTION_HOOK );
                                return;
                        }

                        $crons = _get_cron_array();
                        if ( empty( $crons ) ) {
                                return;
                        }

                        foreach ( $crons as $timestamp => $cron ) {
                                if ( empty( $cron[ self::ACTION_HOOK ] ) ) {
                                        continue;
                                }

                                foreach ( $cron[ self::ACTION_HOOK ] as $event ) {
                                        $args = isset( $event['args'] ) ? $event['args'] : array();
                                        wp_unschedule_event( $timestamp, self::ACTION_HOOK, $args );
                                }
                        }
                }

                protected static function get_interval(): int {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
                        $interval = isset( $settings['auto_allocation_interval'] ) ? (int) $settings['auto_allocation_interval'] : 0;
                        $interval = max( 0, $interval );
                        return $interval;
                }

protected static function default_state(): array {
return array(
'jobs'                   => array(),
'last_finished_at'       => '',
'last_full_reallocation' => '',
'pending'                => 0,
);
}

                protected static function get_state(): array {
                        $state = get_option( defined( __NAMESPACE__ . '\\AUTO_ALLOCATOR_STATE_OPTION' ) ? AUTO_ALLOCATOR_STATE_OPTION : 'lpr_allocator_auto_alloc_state', array() );
                        if ( ! is_array( $state ) ) {
                                $state = array();
                        }

                        $state = array_replace( self::default_state(), $state );

                        if ( ! is_array( $state['jobs'] ) ) {
                                $state['jobs'] = array();
                        }

                        return $state;
                }

                protected static function trim_jobs( array $jobs ): array {
                        if ( empty( $jobs ) ) {
                                return array();
                        }

                        uasort(
                                $jobs,
                                static function ( $a, $b ) {
                                        $start_a = isset( $a['started_at'] ) ? (string) $a['started_at'] : '';
                                        $start_b = isset( $b['started_at'] ) ? (string) $b['started_at'] : '';

                                        return strcmp( $start_b, $start_a );
                                }
                        );

                        return array_slice( $jobs, 0, self::MAX_STORED_JOBS, true );
                }

                protected static function persist_state( array $state ): void {
                        $state['jobs'] = self::trim_jobs( isset( $state['jobs'] ) && is_array( $state['jobs'] ) ? $state['jobs'] : array() );
                        update_option( defined( __NAMESPACE__ . '\\AUTO_ALLOCATOR_STATE_OPTION' ) ? AUTO_ALLOCATOR_STATE_OPTION : 'lpr_allocator_auto_alloc_state', $state, false );
                }

protected static function start_job(): string {
$job_id = uniqid( 'lpr_auto_alloc_', true );
$state  = self::get_state();
$now    = current_time( 'mysql' );

$state['jobs'][ $job_id ] = array(
'id'          => $job_id,
'page'        => 1,
'processed'   => 0,
'last_po_id'  => 0,
'updated_at'  => $now,
'finished_at' => '',
'started_at'  => $now,
'status'      => 'running',
'pending'     => 0,
'total'       => 0,
);

self::persist_state( $state );

                        return $job_id;
                }

                protected static function ensure_job_id( string $job_id ): string {
                        if ( '' !== $job_id ) {
                                return $job_id;
                        }

                        return self::start_job();
                }

		protected static function record_job_progress( string $job_id, int $page, int $po_id = 0 ): void {
			$state = self::get_state();
			$now   = current_time( 'mysql' );

			if ( ! isset( $state['jobs'][ $job_id ] ) ) {
				$state['jobs'][ $job_id ] = array(
					'id'          => $job_id,
					'page'        => $page,
					'processed'   => 0,
					'last_po_id'  => 0,
					'updated_at'  => $now,
					'finished_at' => '',
					'started_at'  => $now,
					'status'      => 'running',
					'pending'     => 0,
					'total'       => 0,
				);
			}

			$state['jobs'][ $job_id ]['page']       = $page;
			$state['jobs'][ $job_id ]['updated_at'] = $now;
			$state['jobs'][ $job_id ]['status']     = 'running';
			$state['jobs'][ $job_id ]['processed']  = isset( $state['jobs'][ $job_id ]['processed'] ) ? (int) $state['jobs'][ $job_id ]['processed'] : 0;
			$state['jobs'][ $job_id ]['pending']    = isset( $state['jobs'][ $job_id ]['pending'] ) ? max( 0, (int) $state['jobs'][ $job_id ]['pending'] ) : 0;
			$state['jobs'][ $job_id ]['total']      = isset( $state['jobs'][ $job_id ]['total'] ) ? max( 0, (int) $state['jobs'][ $job_id ]['total'] ) : 0;

			if ( $po_id > 0 ) {
				$state['jobs'][ $job_id ]['processed'] += 1;
				$state['jobs'][ $job_id ]['last_po_id'] = $po_id;
				if ( $state['jobs'][ $job_id ]['pending'] > 0 ) {
					$state['jobs'][ $job_id ]['pending'] -= 1;
				}
			}

			self::persist_state( $state );
		}

                protected static function record_job_queue_size( string $job_id, int $queued ): void {
                        $state = self::get_state();
                        if ( ! isset( $state['jobs'][ $job_id ] ) ) {
                                return;
                        }

			$now = current_time( 'mysql' );

			$state['jobs'][ $job_id ]['pending']    = max( 0, $queued );
			$state['jobs'][ $job_id ]['total']      = max( 0, $queued );
			$state['jobs'][ $job_id ]['updated_at'] = $now;
			$state['jobs'][ $job_id ]['status']     = $queued > 0 ? 'running' : 'completed';

			if ( 0 === $queued ) {
				$state['jobs'][ $job_id ]['finished_at']       = $now;
				$state['last_finished_at']                      = $now;
				if ( ! empty( $state['jobs'][ $job_id ]['processed'] ) ) {
					$state['last_full_reallocation'] = $now;
				}
			}

                        self::persist_state( $state );
                }

                protected static function maybe_finish_job( string $job_id ): void {
                        $state = self::get_state();

                        if ( empty( $state['jobs'][ $job_id ] ) ) {
                                return;
                        }

                        $pending   = isset( $state['jobs'][ $job_id ]['pending'] ) ? (int) $state['jobs'][ $job_id ]['pending'] : 0;
                        $processed = isset( $state['jobs'][ $job_id ]['processed'] ) ? (int) $state['jobs'][ $job_id ]['processed'] : 0;
                        $total     = isset( $state['jobs'][ $job_id ]['total'] ) ? (int) $state['jobs'][ $job_id ]['total'] : 0;

                        if ( $pending <= 0 && $total > 0 && $processed >= $total ) {
                                self::record_job_finish( $job_id );
                        }
                }

		protected static function record_job_finish( string $job_id ): void {
			$state = self::get_state();
			if ( ! isset( $state['jobs'][ $job_id ] ) ) {
				return;
			}

			$finished = current_time( 'mysql' );
			$state['jobs'][ $job_id ]['status']       = 'completed';
			$state['jobs'][ $job_id ]['finished_at']  = $finished;
			$state['jobs'][ $job_id ]['updated_at']   = $finished;
			$state['jobs'][ $job_id ]['pending']      = 0;
			$state['last_finished_at']                = $finished;

			if ( (int) $state['jobs'][ $job_id ]['processed'] > 0 ) {
				$state['last_full_reallocation'] = $finished;
			}

			self::persist_state( $state );
		}

				public static function get_status_snapshot(): array {
			$state       = self::get_state();
			$jobs        = isset( $state['jobs'] ) && is_array( $state['jobs'] ) ? $state['jobs'] : array();
			$unfinished  = array();
			$last_finish = isset( $state['last_finished_at'] ) ? (string) $state['last_finished_at'] : '';

			foreach ( $jobs as $job ) {
				$status = isset( $job['status'] ) ? (string) $job['status'] : '';
				if ( 'completed' !== $status ) {
					$unfinished[] = $job;
				}
				if ( 'completed' === $status && ! empty( $job['finished_at'] ) ) {
					if ( '' === $last_finish || strcmp( (string) $job['finished_at'], $last_finish ) > 0 ) {
						$last_finish = (string) $job['finished_at'];
					}
				}
			}

			uasort(
			$unfinished,
			static function ( $a, $b ) {
					$start_a = isset( $a['started_at'] ) ? (string) $a['started_at'] : '';
					$start_b = isset( $b['started_at'] ) ? (string) $b['started_at'] : '';

					return strcmp( $start_b, $start_a );
			}
			);

			$unfinished = array_slice( $unfinished, 0, 5 );

			return array(
				'last_finished_at'       => $last_finish,
				'unfinished_jobs'        => $unfinished,
				'last_full_reallocation' => isset( $state['last_full_reallocation'] ) ? (string) $state['last_full_reallocation'] : '',
			);
		}

				public static function format_datetime( string $mysql ): string {
                        $mysql = trim( $mysql );
                        if ( '' === $mysql ) {
                                return 'â€”';
                        }

                        $ts = strtotime( $mysql );
                        if ( false === $ts ) {
                                return 'â€”';
                        }

                        $date_fmt = get_option( 'date_format', 'Y-m-d' );
                        $time_fmt = get_option( 'time_format', 'H:i' );

                        return function_exists( 'date_i18n' ) ? date_i18n( $date_fmt . ' ' . $time_fmt, $ts ) : date( $date_fmt . ' ' . $time_fmt, $ts );
                }

                		/**
		 * Queue a single allocation pass in the background (prefers Action Scheduler).
		 */
		protected static function queue_allocation_pass( int $page = 1, string $job_id = '' ): bool {
			$page   = max( 1, $page );
			$job_id = self::ensure_job_id( $job_id );
			$args   = array(
				'page'   => $page,
				'job_id' => $job_id,
				'po_id'  => 0,
			);

                        // Use Action Scheduler when available for async execution.
                        if ( function_exists( 'as_enqueue_async_action' ) ) {
                                $queued = as_enqueue_async_action( self::ACTION_HOOK, $args, 'lpr-allocator', true );
                                if ( $queued ) {
                                        return true;
                                }
                        }
                        if ( function_exists( 'as_schedule_single_action' ) ) {
                                if ( function_exists( 'as_next_scheduled_action' ) && as_next_scheduled_action( self::ACTION_HOOK, $args, 'lpr-allocator' ) ) {
                                        return true;
                                }

                                return (bool) as_schedule_single_action( time() + 5, self::ACTION_HOOK, $args, 'lpr-allocator' );
                        }

                        // Fallback to WP-Cron single event if Action Scheduler is unavailable.
                        if ( ! wp_next_scheduled( self::ACTION_HOOK, $args ) ) {
                                return (bool) wp_schedule_single_event( time() + 5, self::ACTION_HOOK, $args );
                        }

                        return true;
		}

		/**
		 * Retrieve all open PO IDs ordered by ETA/date.
		 */
                protected static function get_open_po_ids( int $per_page = 20 ): array {
			$statuses = array( defined( __NAMESPACE__ . '\\PO_STATUS_OPEN' ) ? PO_STATUS_OPEN : 'open' );
			if ( defined( __NAMESPACE__ . '\\PO_STATUS_PARTIAL' ) ) {
				$statuses[] = PO_STATUS_PARTIAL;
			}

			$orderby_filter = static function ( $orderby, $query_obj ) {
				global $wpdb;

				if ( ! $query_obj instanceof \WP_Query || ! $query_obj->get( 'lpr_eta_sort' ) ) {
					return $orderby;
				}

				$meta_order = "STR_TO_DATE({$wpdb->postmeta}.meta_value, '%d-%m-%Y') ASC";

				return implode( ', ', array( $meta_order, "{$wpdb->posts}.post_date ASC", "{$wpdb->posts}.ID ASC" ) );
			};

			add_filter( 'posts_orderby', $orderby_filter, 10, 2 );

			$page     = 1;
			$po_ids   = array();
			$has_more = true;

			while ( $has_more ) {
				$query = new \WP_Query(
					array(
						'post_type'      => defined( __NAMESPACE__ . '\\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
						'post_status'    => $statuses,
						'posts_per_page' => $per_page,
						'paged'          => $page,
						'fields'         => 'ids',
						'no_found_rows'  => true,
						'meta_key'       => defined( __NAMESPACE__ . '\\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date',
						'orderby'        => array(
							'meta_value' => 'ASC',
							'date'       => 'ASC',
							'ID'         => 'ASC',
						),
						'order'          => 'ASC',
						'lpr_eta_sort'   => true,
					)
				);

				if ( empty( $query->posts ) ) {
					break;
				}

				foreach ( $query->posts as $po_id ) {
					$po_ids[] = (int) $po_id;
				}

				$has_more = count( $query->posts ) === $per_page;
				$page++;
			}

			remove_filter( 'posts_orderby', $orderby_filter, 10 );

                        return $po_ids;
                }

                public static function get_open_po_count(): int {
                        return count( self::get_open_po_ids( 20 ) );
                }

                protected static function process_po_allocation( int $po_id, string $job_id, int $page ): void {
                        if ( $po_id <= 0 ) {
                                return;
                        }

                        self::record_job_progress( $job_id, $page, $po_id );

                        if ( class_exists( __NAMESPACE__ . '\\PO_FIFO_Allocator' ) ) {
                                PO_FIFO_Allocator::allocate_po( (int) $po_id );
                        }
                }

                protected static function queue_po_batch_action( array $po_ids, string $job_id, int $delay_seconds ): bool {
                        $po_ids = array_values(
                                array_filter(
                                        array_map( 'intval', $po_ids ),
                                        static function ( int $po_id ): bool {
                                                return $po_id > 0;
                                        }
                                )
                        );

                        if ( empty( $po_ids ) ) {
                                return false;
                        }

                        $args       = array(
                                'page'   => 1,
                                'job_id' => $job_id,
                                'po_ids' => $po_ids,
                        );
                        $delay      = max( 0, $delay_seconds );
                        $timestamp  = time() + $delay;

                        if ( function_exists( 'as_schedule_single_action' ) ) {
                                return (bool) as_schedule_single_action( $timestamp, self::ACTION_HOOK, $args, 'lpr-allocator', true );
                        }

                        // Fallback to WP-Cron single event if Action Scheduler is unavailable.
                        if ( ! wp_next_scheduled( self::ACTION_HOOK, $args ) ) {
                                return (bool) wp_schedule_single_event( $timestamp, self::ACTION_HOOK, $args );
                        }

                        return true;
                }

                protected static function queue_single_po_action( int $po_id, string $job_id ): bool {
                        $args = array(
                                'page'   => 1,
                                'job_id' => $job_id,
				'po_id'  => $po_id,
			);

                        // Use Action Scheduler when available for async execution.
                        if ( function_exists( 'as_enqueue_async_action' ) ) {
                                $queued = as_enqueue_async_action( self::ACTION_HOOK, $args, 'lpr-allocator', true );
                                if ( $queued ) {
                                        return true;
                                }
                        }

                        if ( function_exists( 'as_schedule_single_action' ) ) {
                                if ( function_exists( 'as_next_scheduled_action' ) && as_next_scheduled_action( self::ACTION_HOOK, $args, 'lpr-allocator' ) ) {
                                        return true;
                                }

                                return (bool) as_schedule_single_action( time() + 5, self::ACTION_HOOK, $args, 'lpr-allocator' );
                        }

                        // Fallback to WP-Cron single event if Action Scheduler is unavailable.
                        if ( ! wp_next_scheduled( self::ACTION_HOOK, $args ) ) {
                                return (bool) wp_schedule_single_event( time() + 5, self::ACTION_HOOK, $args );
                        }

                        return true;
                }

                /**
                 * Queue all open POs as grouped jobs spaced apart to guarantee execution.
                 */
                protected static function queue_open_po_actions( string $job_id, array $po_ids = array() ): int {
                        if ( empty( $po_ids ) ) {
                                $po_ids = self::get_open_po_ids( 20 );
                        }

                        $total = count( $po_ids );

                        self::record_job_queue_size( $job_id, $total );

                        if ( 0 === $total ) {
                                return 0;
                        }

                        $queued = 0;
                        $delay  = 0;

                        foreach ( array_chunk( $po_ids, self::BATCH_SIZE ) as $chunk ) {
                                if ( self::queue_po_batch_action( $chunk, $job_id, $delay ) ) {
                                        $queued += count( $chunk );
                                } else {
                                        foreach ( $chunk as $po_id ) {
                                                if ( self::queue_single_po_action( (int) $po_id, $job_id ) ) {
                                                        $queued++;
                                                }
                                        }
                                }

                                $delay += self::BATCH_SPACING_SECONDS;
                        }

                        self::maybe_finish_job( $job_id );

                        return $queued;
                }

                /**
                 * Force a full reallocation run immediately, chunking PO allocations in timed batches.
                 */
                public static function force_reallocate_open_pos(): array {
                        $job_id = self::start_job();
                        $po_ids = self::get_open_po_ids( 20 );

                        self::record_job_progress( $job_id, 1 );

                        $queued = self::queue_open_po_actions( $job_id, $po_ids );

                        if ( 0 === $queued ) {
                                self::record_job_finish( $job_id );
                        }

                        return array(
                                'job_id' => $job_id,
                                'queued' => $queued,
                                'total'  => count( $po_ids ),
                        );
                }

                public static function maybe_schedule( bool $force = false ): void {
                        $interval = self::get_interval();

                        if ( $interval <= 0 ) {
                                if ( $force && function_exists( 'as_unschedule_all_actions' ) ) {
                                        as_unschedule_all_actions( self::ACTION_HOOK, null, 'lpr-allocator' );
                                } elseif ( $force ) {
                                        self::clear_wp_cron_events();
                                }
                                return;
                        }

                        if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_next_scheduled_action' ) ) {
                                if ( $force && function_exists( 'as_unschedule_all_actions' ) ) {
                                        as_unschedule_all_actions( self::ACTION_HOOK, null, 'lpr-allocator' );
                                }
                                $next = as_next_scheduled_action( self::ACTION_HOOK, array(), 'lpr-allocator' );
                                if ( ! $next ) {
                                        as_schedule_recurring_action( time() + 60, $interval, self::ACTION_HOOK, array(), 'lpr-allocator', true );
                                }
                        } else {
                                if ( $force ) {
                                        self::clear_wp_cron_events();
                                }
                                if ( ! wp_next_scheduled( self::ACTION_HOOK ) ) {
                                        wp_schedule_single_event( time() + $interval, self::ACTION_HOOK );
                                }
                        }
                }

                
                public static function run( int $page = 1, string $job_id = '', $po_arg = 0 ): void {
                        $page   = max( 1, $page );
                        $job_id = self::ensure_job_id( $job_id );

                        if ( is_array( $po_arg ) ) {
                                $po_ids = array_values(
                                        array_filter(
                                                array_map( 'intval', $po_arg ),
                                                static function ( int $po_id ): bool {
                                                        return $po_id > 0;
                                                }
                                        )
                                );

                                foreach ( $po_ids as $po_id ) {
                                        self::process_po_allocation( (int) $po_id, $job_id, $page );
                                }

                                self::maybe_finish_job( $job_id );
                                return;
                        }

                        $po_id = (int) $po_arg;

                        if ( $po_id > 0 ) {
                                self::process_po_allocation( $po_id, $job_id, $page );
                                self::maybe_finish_job( $job_id );
                                return;
                        }

                        self::record_job_progress( $job_id, $page );

                        $queued = self::queue_open_po_actions( $job_id );

                        if ( 0 === $queued ) {
                                self::record_job_finish( $job_id );
                        }

                        $interval = self::get_interval();
                        if ( $interval <= 0 ) {
                                return;
                        }

                        if ( ! function_exists( 'as_schedule_recurring_action' ) && ! wp_next_scheduled( self::ACTION_HOOK ) ) {
                                wp_schedule_single_event( time() + $interval, self::ACTION_HOOK );
                        }
                }

                /**
                 * Run an immediate allocation pass when a PO leaves a live status.
                 */
                public static function handle_po_status_change( string $new_status, string $old_status, \WP_Post $post ): void {
                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }

                        $live = lpr_allocator_live_po_statuses();
                        if ( in_array( $new_status, $live, true ) && in_array( $old_status, $live, true ) ) {
                                return;
                        }

                        self::queue_allocation_pass();
                        self::maybe_schedule( true );
                }

                /**
                 * Keep allocations in sync when a PO is deleted.
                 */
                public static function handle_po_delete( int $post_id ): void {
                        $post = get_post( $post_id );
                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_remove_po_allocations_from_orders' ) ) {
                                lpr_allocator_remove_po_allocations_from_orders( (int) $post_id );
                        }

                        self::queue_allocation_pass();
                        self::maybe_schedule( true );
                }
        }
        Auto_PO_Allocator::init();
}

if ( ! class_exists( __NAMESPACE__ . '\PO_Allocate_Button_UI' ) ) {
        /**
         * Adds an "Allocate" button to the Supplier PO edit screen (Publish box) and admin notices.
         */
        class PO_Allocate_Button_UI {

		public static function init(): void {
			add_action( 'post_submitbox_misc_actions', array( __CLASS__, 'render_button' ) );
			add_action( 'admin_notices', array( __CLASS__, 'maybe_notice' ) );
		}

		/**
		 * Render button inside the submit box on the Supplier PO edit screen.
		 */
		public static function render_button(): void {
			global $post;
			if ( ! ( $post instanceof \WP_Post ) ) {
				return;
			}
			if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}

			$nonce  = wp_create_nonce( 'lpr_allocate_po_' . $post->ID );
			$url    = add_query_arg(
				array(
					'action'   => 'lpr_allocate_po',
					'po_id'    => (int) $post->ID,
					'_wpnonce' => $nonce,
				),
				admin_url( 'admin-post.php' )
			);

			// Small helper text and primary button.
			echo '<div class="misc-pub-section lpr-alloc">';
			echo '<a href="' . esc_url( $url ) . '" class="button button-primary">' . esc_html__( 'Allocate', 'lpr-backorder-allocator' ) . '</a>';
			echo '<span style="margin-left:8px;opacity:.8;">' . esc_html__( 'Assigns PO quantities to backordered orders (FIFO). No stock changes.', 'lpr-backorder-allocator' ) . '</span>';
			echo '</div>';
		}

		/**
		 * Show status notice after allocation trigger.
		 */
		public static function maybe_notice(): void {
			if ( empty( $_GET['lpr_alloc'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				return;
			}
			$state = sanitize_key( wp_unslash( $_GET['lpr_alloc'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( 'queued' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'PO allocation queued. It will process shortly.', 'lpr-backorder-allocator' ) . '</p></div>';
			} elseif ( 'done' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'PO allocation completed.', 'lpr-backorder-allocator' ) . '</p></div>';
			}
		}
	}
        PO_Allocate_Button_UI::init();
}

if ( ! class_exists( __NAMESPACE__ . '\PO_Receive_Stock_UI' ) ) {
        /**
         * Adds an "Adjust stock" button + modal to receive PO quantities into inventory.
         */
        class PO_Receive_Stock_UI {

                const ACTION_HOOK = 'lpr_allocator_receive_po';

                public static function init(): void {
                        add_action( 'post_submitbox_misc_actions', array( __CLASS__, 'render_button' ) );
                        add_action( 'admin_footer', array( __CLASS__, 'print_modal_assets' ) );
                        add_action( 'wp_ajax_lpr_po_receive_lines', array( __CLASS__, 'ajax_lines' ) );
                        add_action( 'wp_ajax_nopriv_lpr_po_receive_lines', array( __CLASS__, 'ajax_lines' ) );
                        add_action( 'wp_ajax_lpr_po_receive_apply', array( __CLASS__, 'ajax_apply' ) );
                        add_action( 'wp_ajax_nopriv_lpr_po_receive_apply', array( __CLASS__, 'ajax_apply' ) );
                        add_action( 'add_meta_boxes', array( __CLASS__, 'register_log_box' ), 40 );
                        add_action( self::ACTION_HOOK, array( __CLASS__, 'process_receipt' ), 10, 2 );
                }

                /**
                 * Render the Adjust stock trigger on the PO submit box.
                 */
                public static function render_button(): void {
                        global $post;

                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        $nonce = wp_create_nonce( 'lpr_receive_po_' . $post->ID );

                        echo '<div class="misc-pub-section lpr-receive-stock">';
                        echo '<button type="button" class="button button-secondary lpr-open-receive" data-po="' . esc_attr( (string) $post->ID ) . '" data-nonce="' . esc_attr( $nonce ) . '">' . esc_html__( 'Adjust stock', 'lpr-backorder-allocator' ) . '</button>';
                        echo '<span style="margin-left:8px;opacity:.8;">' . esc_html__( 'Receive stock for each PO line.', 'lpr-backorder-allocator' ) . '</span>';
                        echo '</div>';
                }

                /**
                 * Print modal styles + JS once on the PO edit screen.
                 */
                public static function print_modal_assets(): void {
                        $screen = function_exists( 'get_current_screen' ) ? get_current_screen() : null;
                        if ( ! self::should_load_assets( $screen ) ) {
                                return;
                        }
                        ?>
                        <style>
                                .lpr-po-receive-overlay{position:fixed;inset:0;z-index:100000;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:20px;}
                                .lpr-po-receive-modal{background:#fff;max-width:900px;width:100%;border-radius:6px;box-shadow:0 10px 40px rgba(0,0,0,.25);overflow:hidden;}
                                .lpr-po-receive-modal header{padding:14px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between;}
                                .lpr-po-receive-modal header h3{margin:0;font-size:16px;}
                                .lpr-po-receive-modal .lpr-body{max-height:60vh;overflow:auto;padding:16px;}
                                .lpr-po-receive-modal table{width:100%;border-collapse:collapse;}
                                .lpr-po-receive-modal th,.lpr-po-receive-modal td{padding:8px;border-bottom:1px solid #eee;text-align:left;vertical-align:top;}
                                .lpr-po-receive-modal .lpr-actions{padding:12px 16px;border-top:1px solid #eee;text-align:right;}
                                .lpr-po-receive-modal .lpr-status{margin:0 0 10px;font-style:italic;opacity:.8;}
                        </style>
                        <script>
                        (function($){
                                function escapeHtml(str){
                                        return $('<div>').text(str || '').html();
                                }

                                function renderRows(lines){
                                        if(!lines || !lines.length){
                                                return '<p><?php echo esc_js( __( 'No PO lines found.', 'lpr-backorder-allocator' ) ); ?></p>';
                                        }
                                        var html = '<table class="widefat striped"><thead><tr>'+
                                                '<th><?php echo esc_js( __( 'Product', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Ordered', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Live stock', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Already received', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Qty to receive now', 'lpr-backorder-allocator' ) ); ?></th>'+
                                        '</tr></thead><tbody>';
                                        lines.forEach(function(line){
                                                var stock = (line.stock === null || typeof line.stock === 'undefined') ? '<?php echo esc_js( 'â€”' ); ?>' : line.stock;
                                                var remaining = typeof line.remaining === 'number' ? line.remaining : 0;
                                                var disable = remaining <= 0;
                                                var desc = disable ? '<div class="description"><?php echo esc_js( __( 'Fully received', 'lpr-backorder-allocator' ) ); ?></div>' : '<div class="description">'+remaining+' <?php echo esc_js( __( 'remaining', 'lpr-backorder-allocator' ) ); ?></div>';
                                                html += '<tr>'+
                                                        '<td>'+line.product+'</td>'+
                                                        '<td>'+line.ordered+'</td>'+
                                                        '<td>'+stock+'</td>'+
                                                        '<td>'+line.received+'</td>'+
                                                        '<td><input type="number" min="0" step="1" class="lpr-receive-input" data-idx="'+line.idx+'" data-stock="'+stock+'" data-ordered="'+line.ordered+'" data-received="'+line.received+'" data-remaining="'+remaining+'" value="0" '+(disable ? 'disabled' : '')+' max="'+remaining+'" style="width:120px;" />'+desc+'</td>'+
                                                '</tr>';
                                        });
                                        html += '</tbody></table>';
                                        return html;
                                }

                                function openModal(poId, nonce, lines){
                                        $('.lpr-po-receive-overlay').remove();
                                        var bodyHtml = renderRows(lines);
                                        var tpl = '<div class="lpr-po-receive-overlay">'+
                                                '<div class="lpr-po-receive-modal" data-po="'+poId+'" data-nonce="'+nonce+'">'+
                                                        '<header><h3><?php echo esc_js( __( 'Receive stock', 'lpr-backorder-allocator' ) ); ?></h3><a href="#" class="lpr-po-receive-close">&times;</a></header>'+
                                                        '<div class="lpr-body">'+
                                                                '<p class="lpr-status"></p>'+
                                                                '<div class="lpr-entry-view">'+
                                                                        '<div class="lpr-entry-rows">'+ bodyHtml +'</div>'+
                                                                        '<div class="lpr-receive-note-block" style="margin-top:12px;">'+
                                                                                '<label for="lpr-receive-note">'+<?php echo wp_json_encode( __( 'Receipt note (optional)', 'lpr-backorder-allocator' ) ); ?>+'</label>'+
                                                                                '<textarea id="lpr-receive-note" class="widefat lpr-receive-note" rows="2" placeholder="'+<?php echo wp_json_encode( __( 'Add a note for this receipt (optional)', 'lpr-backorder-allocator' ) ); ?>+'"></textarea>'+
                                                                                '<p class="description" style="margin-top:4px;">'+<?php echo wp_json_encode( __( 'Saved to the receipt log.', 'lpr-backorder-allocator' ) ); ?>+'</p>'+
                                                                        '</div>'+
                                                                '</div>'+
                                                                '<div class="lpr-preview-view" style="display:none;"></div>'+
                                                        '</div>'+
                                                        '<div class="lpr-actions">'+
                                                                '<button type="button" class="button button-primary lpr-submit-receive"><?php echo esc_js( __( 'Receive stock', 'lpr-backorder-allocator' ) ); ?></button>'+
                                                                '<button type="button" class="button button-primary lpr-confirm-receive" style="display:none;"><?php echo esc_js( __( 'Confirm', 'lpr-backorder-allocator' ) ); ?></button>'+
                                                                '<button type="button" class="button lpr-edit-receive" style="margin-left:8px;display:none;"><?php echo esc_js( __( 'Back', 'lpr-backorder-allocator' ) ); ?></button>'+
                                                                '<button type="button" class="button lpr-po-receive-cancel" style="margin-left:8px;"><?php echo esc_js( __( 'Cancel', 'lpr-backorder-allocator' ) ); ?></button>'+
                                                        '</div>'+
                                                '</div>'+
                                        '</div>';
                                        var $overlay = $(tpl).appendTo('body');
                                        $overlay.fadeIn(120);
                                }

                                function fetchLines(poId, nonce){
                                        return $.post(ajaxurl, {action:'lpr_po_receive_lines', po_id: poId, nonce: nonce});
                                }

                                function applyReceive(poId, nonce, payload, note){
                                        return $.post(ajaxurl, {action:'lpr_po_receive_apply', po_id: poId, nonce: nonce, lines: payload, note: note});
                                }

                                function showPreview($modal, rows){
                                        var html = '<h4><?php echo esc_js( __( 'Review receipt', 'lpr-backorder-allocator' ) ); ?></h4>';
                                        html += '<table class="widefat striped"><thead><tr>'+
                                                '<th><?php echo esc_js( __( 'Product', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Current stock', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'Quantity to receive now', 'lpr-backorder-allocator' ) ); ?></th>'+
                                                '<th><?php echo esc_js( __( 'New stock', 'lpr-backorder-allocator' ) ); ?></th>'+
                                        '</tr></thead><tbody>';

                                        rows.forEach(function(row){
                                                var current = (row.stock === null || row.stock === '' || typeof row.stock === 'undefined') ? '<?php echo esc_js( 'â€”' ); ?>' : row.stock;
                                                var newStock = current === '<?php echo esc_js( 'â€”' ); ?>' ? '<?php echo esc_js( 'â€”' ); ?>' : (parseInt(current, 10) + row.qty);
                                                html += '<tr>'+
                                                        '<td>'+row.product+'</td>'+
                                                        '<td>'+current+'</td>'+
                                                        '<td>'+row.qty+'</td>'+
                                                        '<td>'+newStock+'</td>'+
                                                '</tr>';
                                        });

                                        html += '</tbody></table>';
                                        var note = $.trim($modal.find('.lpr-receive-note').val() || '');
                                        $modal.data('receiptNote', note);
                                        if(note){
                                                html += '<p><strong><?php echo esc_js( __( 'Note', 'lpr-backorder-allocator' ) ); ?>:</strong> '+escapeHtml(note)+'</p>';
                                        }
                                        $modal.data('previewRows', rows);
                                        $modal.find('.lpr-preview-view').html(html).show();
                                        $modal.find('.lpr-entry-view').hide();
                                        $modal.find('.lpr-submit-receive').hide();
                                        $modal.find('.lpr-confirm-receive, .lpr-edit-receive').show();
                                        $modal.find('.lpr-status').text('');
                                }

                                function showEntry($modal){
                                        $modal.removeData('previewRows');
                                        $modal.find('.lpr-preview-view').hide().empty();
                                        $modal.find('.lpr-entry-view').show();
                                        $modal.find('.lpr-confirm-receive, .lpr-edit-receive').hide();
                                        $modal.find('.lpr-submit-receive').show();
                                }

                                $(document).on('click', '.lpr-open-receive', function(e){
                                        e.preventDefault();
                                        var $btn = $(this);
                                        var poId = $btn.data('po');
                                        var nonce = $btn.data('nonce');
                                        if(!poId || !nonce){ return; }
                                        $btn.prop('disabled', true);
                                        fetchLines(poId, nonce).done(function(resp){
                                                if(resp && resp.success && resp.data && resp.data.lines){
                                                        openModal(poId, nonce, resp.data.lines);
                                                }else{
                                                        window.alert((resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to load PO lines.', 'lpr-backorder-allocator' ) ); ?>');
                                                }
                                        }).fail(function(){
                                                window.alert('<?php echo esc_js( __( 'Unable to load PO lines.', 'lpr-backorder-allocator' ) ); ?>');
                                        }).always(function(){
                                                $btn.prop('disabled', false);
                                        });
                                });

                                $(document).on('click', '.lpr-po-receive-close, .lpr-po-receive-cancel', function(e){
                                        e.preventDefault();
                                        $(this).closest('.lpr-po-receive-overlay').fadeOut(120, function(){ $(this).remove(); });
                                });

                                $(document).on('click', '.lpr-po-receive-overlay', function(e){
                                        if($(e.target).hasClass('lpr-po-receive-overlay')){
                                                $(this).fadeOut(120, function(){ $(this).remove(); });
                                        }
                                });

                                $(document).on('click', '.lpr-edit-receive', function(e){
                                        e.preventDefault();
                                        var $modal = $(this).closest('.lpr-po-receive-modal');
                                        showEntry($modal);
                                        $modal.find('.lpr-status').text('');
                                });

                                $(document).on('click', '.lpr-submit-receive', function(e){
                                        e.preventDefault();
                                        var $modal = $(this).closest('.lpr-po-receive-modal');
                                        var rows = [];
                                        var adjusted = false;

                                        $modal.find('.lpr-receive-input').each(function(){
                                                var $input = $(this);
                                                if($input.is(':disabled')){ return; }
                                                var remaining = parseInt($input.data('remaining'), 10) || 0;
                                                var qty = parseInt($input.val(), 10);
                                                if(isNaN(qty) || qty < 0){ qty = 0; }
                                                if(qty > remaining){ qty = remaining; $input.val(remaining); adjusted = true; }
                                                if(qty <= 0){ return; }

                                                var product = $input.closest('tr').find('td').first().text();
                                                rows.push({
                                                        idx: $input.data('idx'),
                                                        qty: qty,
                                                        stock: $input.data('stock'),
                                                        product: product
                                                });
                                        });

                                        if(adjusted){
                                                $modal.find('.lpr-status').text('<?php echo esc_js( __( 'Quantities reduced to the remaining ordered amount.', 'lpr-backorder-allocator' ) ); ?>');
                                        } else {
                                                $modal.find('.lpr-status').text('');
                                        }

                                        if(!rows.length){
                                                $modal.find('.lpr-status').text('<?php echo esc_js( __( 'Enter a quantity to receive.', 'lpr-backorder-allocator' ) ); ?>');
                                                return;
                                        }

                                        showPreview($modal, rows);
                                });

                                $(document).on('click', '.lpr-confirm-receive', function(e){
                                        e.preventDefault();
                                        var $modal = $(this).closest('.lpr-po-receive-modal');
                                        var rows = $modal.data('previewRows') || [];
                                        var note = $modal.data('receiptNote') || '';
                                        if(!rows.length){
                                                $modal.find('.lpr-status').text('<?php echo esc_js( __( 'No quantities to apply.', 'lpr-backorder-allocator' ) ); ?>');
                                                return;
                                        }

                                        var payload = {};
                                        rows.forEach(function(row){ payload[row.idx] = row.qty; });
                                        var poId = $modal.data('po');
                                        var nonce = $modal.data('nonce');

                                        $modal.find('button').prop('disabled', true);
                                        applyReceive(poId, nonce, payload, note).done(function(resp){
                                                var data = (resp && resp.data) ? resp.data : {};
                                                var successMsg = data.message || '<?php echo esc_js( __( 'Job scheduled. Stock will update asynchronously.', 'lpr-backorder-allocator' ) ); ?>';

                                                if(resp && resp.success){
                                                        if(data.lines){
                                                                var newTable = renderRows(data.lines);
                                                                $modal.find('.lpr-entry-rows').html(newTable);
                                                                $modal.find('.lpr-receive-note').val('');
                                                                $modal.removeData('receiptNote');
                                                                showEntry($modal);
                                                        }
                                                        $modal.find('.lpr-status').text(successMsg);
                                                        return;
                                                }

                                                var msg = data.message || '<?php echo esc_js( __( 'Job not scheduled. Unable to apply received quantities.', 'lpr-backorder-allocator' ) ); ?>';
                                                if(data.details && data.details.length){
                                                        msg += ' ' + data.details.join(' ');
                                                }
                                                if(data.lines){
                                                        $modal.find('.lpr-entry-rows').html(renderRows(data.lines));
                                                        showEntry($modal);
                                                }
                                                $modal.find('.lpr-status').text(msg);
                                        }).fail(function(){
                                                $modal.find('.lpr-status').text('<?php echo esc_js( __( 'Job not scheduled. Unable to apply received quantities.', 'lpr-backorder-allocator' ) ); ?>');
                                        }).always(function(){
                                                $modal.find('button').prop('disabled', false);
                                        });
                                });
                        })(jQuery);
                        </script>
                        <?php
                }

                /**
                 * Determine if receive assets should be enqueued on the current screen.
                 *
                 * @param \WP_Screen|null $screen
                 * @return bool
                 */
                protected static function should_load_assets( $screen ): bool { // phpcs:ignore Universal.NamingConventions.NoReservedKeywordParameterNames
                        if ( ! $screen ) {
                                return false;
                        }

                        $po_screen = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
                        if ( isset( $screen->post_type ) && $screen->post_type === $po_screen ) {
                                return true;
                        }

                        return isset( $screen->id ) && false !== strpos( (string) $screen->id, 'lpr-incoming-pos' );
                }

                /**
                 * Register the Received stock log meta box.
                 */
                public static function register_log_box(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        add_meta_box(
                                'lpr_po_receipts',
                                __( 'Received stock', 'lpr-backorder-allocator' ),
                                array( __CLASS__, 'render_log_box' ),
                                defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                'normal',
                                'low'
                        );
                }

                /**
                 * Render receipt history.
                 *
                 * @param \WP_Post $post
                 */
                public static function render_log_box( \WP_Post $post ): void {
                        $receipts = self::get_receipts( (int) $post->ID );

                        echo '<details class="lpr-po-receipts" open>';
                        echo '<summary><strong>' . esc_html__( 'Received stock', 'lpr-backorder-allocator' ) . '</strong></summary>';

                        if ( empty( $receipts ) ) {
                                echo '<p>' . esc_html__( 'No receipts have been logged for this PO.', 'lpr-backorder-allocator' ) . '</p>';
                                echo '</details>';
                                return;
                        }

                        usort(
                                $receipts,
                                static function ( $a, $b ) {
                                        return strcmp( $b['created_at'] ?? '', $a['created_at'] ?? '' );
                                }
                        );

                        $labels = array();
                        $get_label = function ( int $product_id, int $variation_id ) use ( &$labels ): string {
                                $target = $variation_id > 0 ? $variation_id : $product_id;
                                if ( $target <= 0 ) {
                                        return __( 'Unknown product', 'lpr-backorder-allocator' );
                                }
                                if ( isset( $labels[ $target ] ) ) {
                                        return $labels[ $target ];
                                }
                                $label = '#' . $target;
                                if ( function_exists( 'wc_get_product' ) ) {
                                        $product = wc_get_product( $target );
                                        if ( $product instanceof \WC_Product ) {
                                                $label = lpr_allocator_product_option_label( $target );
                                                $label = wp_strip_all_tags( $label );
                                        }
                                }
                                $labels[ $target ] = $label;
                                return $label;
                        };

                        echo '<div class="lpr-po-receipts-list">';
                        foreach ( $receipts as $receipt ) {
                                $status   = self::resolve_receipt_status( $receipt );
                                $datetime = ! empty( $receipt['created_at'] ) ? mysql2date( get_option( 'date_format' ) . ' ' . get_option( 'time_format' ), $receipt['created_at'] ) : '';
                                $job      = ! empty( $receipt['action_id'] ) ? '#' . absint( $receipt['action_id'] ) : __( 'n/a', 'lpr-backorder-allocator' );
                                echo '<div class="lpr-po-receipt-entry">';
                                echo '<p><strong>' . esc_html( $datetime ) . '</strong> â€” ' . esc_html( ucfirst( $status ) ) . ' (' . esc_html__( 'Job', 'lpr-backorder-allocator' ) . ' ' . esc_html( $job ) . ')</p>';
                                if ( ! empty( $receipt['message'] ) ) {
                                        echo '<p><em>' . esc_html( (string) $receipt['message'] ) . '</em></p>';
                                }

                                $rows = ! empty( $receipt['logs'] ) ? $receipt['logs'] : array();
                                if ( empty( $rows ) && ! empty( $receipt['lines'] ) ) {
                                        foreach ( $receipt['lines'] as $line ) {
                                                $rows[] = array(
                                                        'product_id'   => (int) ( $line['product_id'] ?? 0 ),
                                                        'variation_id' => (int) ( $line['variation_id'] ?? 0 ),
                                                        'qty'          => (int) ( $line['qty'] ?? 0 ),
                                                        'stock_before' => null,
                                                        'stock_after'  => null,
                                                );
                                        }
                                }

                                echo '<table class="widefat fixed striped" style="margin-top:8px;">';
                                echo '<thead><tr><th>' . esc_html__( 'Product', 'lpr-backorder-allocator' ) . '</th><th>' . esc_html__( 'Qty received', 'lpr-backorder-allocator' ) . '</th><th>' . esc_html__( 'Stock before', 'lpr-backorder-allocator' ) . '</th><th>' . esc_html__( 'Stock after', 'lpr-backorder-allocator' ) . '</th></tr></thead>';
                                echo '<tbody>';
                                foreach ( $rows as $row ) {
                                        $before = isset( $row['stock_before'] ) ? (string) $row['stock_before'] : 'â€”';
                                        $after  = isset( $row['stock_after'] ) ? (string) $row['stock_after'] : 'â€”';
                                        echo '<tr>';
                                        echo '<td>' . esc_html( $get_label( (int) ( $row['product_id'] ?? 0 ), (int) ( $row['variation_id'] ?? 0 ) ) ) . '</td>';
                                        echo '<td>' . esc_html( (string) max( 0, (int) ( $row['qty'] ?? 0 ) ) ) . '</td>';
                                        echo '<td>' . esc_html( $before ) . '</td>';
                                        echo '<td>' . esc_html( $after ) . '</td>';
                                        echo '</tr>';
                                }
                                echo '</tbody>';
                                echo '</table>';
                                echo '</div>';
                        }
                        echo '</div>';
                        echo '</details>';
                }

                /**
                 * Resolve the display status for a receipt.
                 *
                 * @param array $receipt
                 * @return string
                 */
                protected static function resolve_receipt_status( array $receipt ): string {
                        $status = isset( $receipt['status'] ) ? (string) $receipt['status'] : 'pending';

                        if ( 'pending' === $status && ! empty( $receipt['action_id'] ) && function_exists( 'as_get_scheduled_action' ) ) {
                                try {
                                        $action = as_get_scheduled_action( (int) $receipt['action_id'] );
                                        if ( $action && is_object( $action ) && method_exists( $action, 'get_status' ) ) {
                                                $status = (string) $action->get_status();
                                        }
                                } catch ( \Exception $e ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedCatch
                                        // Keep stored status.
                                }
                        }

                        if ( 'complete' === $status ) {
                                $status = 'completed';
                        }

                        return $status;
                }

                /**
                 * Fetch stored receipt log.
                 */
                protected static function get_receipts( int $po_id ): array {
                        $receipts = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_RECEIPTS' ) ? PO_META_RECEIPTS : '_lpr_po_receipts', true );
                        if ( ! is_array( $receipts ) ) {
                                return array();
                        }

                        return $receipts;
                }

                /**
                 * Persist receipt log.
                 */
                protected static function save_receipts( int $po_id, array $receipts ): void {
                        update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_RECEIPTS' ) ? PO_META_RECEIPTS : '_lpr_po_receipts', array_values( $receipts ) );
                }

                /**
                 * Queue an Action Scheduler job for a PO receipt.
                 */
                protected static function enqueue_action( int $po_id, string $receipt_id ): int {
                        try {
                                if ( function_exists( 'as_enqueue_async_action' ) ) {
                                        return (int) as_enqueue_async_action( self::ACTION_HOOK, array( $po_id, $receipt_id ), 'lpr-allocator' );
                                }
                                if ( function_exists( 'as_schedule_single_action' ) ) {
                                        return (int) as_schedule_single_action( time(), self::ACTION_HOOK, array( $po_id, $receipt_id ), 'lpr-allocator', true );
                                }
                        } catch ( \Exception $e ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedCatch
                                // Surface failure via zero return.
                        }

                        return 0;
                }

                /**
                 * Action Scheduler runner: increase stock and update receipt logs.
                 */
                public static function process_receipt( int $po_id, string $receipt_id ): void {
                        $receipts       = self::get_receipts( $po_id );
                        $receipt_index  = null;
                        $receipt_lines  = array();
                        foreach ( $receipts as $i => $receipt ) {
                                if ( isset( $receipt['id'] ) && $receipt_id === (string) $receipt['id'] ) {
                                        $receipt_index = $i;
                                        $receipt_lines = isset( $receipt['lines'] ) && is_array( $receipt['lines'] ) ? $receipt['lines'] : array();
                                        if ( 'completed' === (string) ( $receipt['status'] ?? '' ) ) {
                                                return;
                                        }
                                        break;
                                }
                        }

                        if ( null === $receipt_index ) {
                                return;
                        }

                        if ( defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) && PO_STATUS_CLOSED === get_post_status( $po_id ) ) {
                                $receipts[ $receipt_index ]['status']  = 'canceled';
                                $receipts[ $receipt_index ]['message'] = isset( $receipts[ $receipt_index ]['message'] ) ? (string) $receipts[ $receipt_index ]['message'] : '';
                                $receipts[ $receipt_index ]['logs']    = isset( $receipts[ $receipt_index ]['logs'] ) && is_array( $receipts[ $receipt_index ]['logs'] ) ? $receipts[ $receipt_index ]['logs'] : array();
                                $receipts[ $receipt_index ]['message'] = trim( $receipts[ $receipt_index ]['message'] . ' ' . __( 'Receipt canceled because the PO is closed.', 'lpr-backorder-allocator' ) );
                                self::save_receipts( $po_id, $receipts );
                                return;
                        }

                        $po_lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( ! is_array( $po_lines ) ) {
                                $po_lines = array();
                        }

                        $errors        = array();
                        $targets       = array();
                        $revert_lines  = array();
                        $line_logs     = array();
                        $line_sequence = array();

                        if ( empty( $receipt_lines ) ) {
                                $errors[] = __( 'No lines to process for this receipt.', 'lpr-backorder-allocator' );
                        }

                        foreach ( $receipt_lines as $entry ) {
                                $idx = (int) ( $entry['idx'] ?? -1 );
                                $qty = max( 0, (int) ( $entry['qty'] ?? 0 ) );
                                if ( $idx < 0 || $qty <= 0 ) {
                                        continue;
                                }

                                if ( ! isset( $po_lines[ $idx ] ) ) {
                                        $errors[] = sprintf( __( 'Line %d no longer exists on this PO.', 'lpr-backorder-allocator' ), $idx );
                                        continue;
                                }

                                $ordered         = isset( $po_lines[ $idx ]['qty_ordered'] ) ? max( 0, (int) $po_lines[ $idx ]['qty_ordered'] ) : 0;
                                $current_received = isset( $po_lines[ $idx ]['qty_received'] ) ? max( 0, (int) $po_lines[ $idx ]['qty_received'] ) : 0;
                                $prev_received   = isset( $entry['qty_before'] ) ? max( 0, (int) $entry['qty_before'] ) : 0;
                                $expected        = $prev_received + $qty;
                                $revert_lines[ $idx ] = $prev_received;

                                if ( $expected > $ordered ) {
                                        $errors[] = sprintf( __( 'Line %d exceeds its ordered quantity.', 'lpr-backorder-allocator' ), $idx );
                                        continue;
                                }

                                if ( $current_received < $expected ) {
                                        $errors[] = sprintf( __( 'Line %d was modified and no longer matches the queued receipt.', 'lpr-backorder-allocator' ), $idx );
                                        continue;
                                }

                                $target = isset( $entry['variation_id'] ) && (int) $entry['variation_id'] > 0 ? (int) $entry['variation_id'] : (int) ( $entry['product_id'] ?? 0 );
                                if ( $target <= 0 ) {
                                        $errors[] = sprintf( __( 'Line %d is missing a product reference.', 'lpr-backorder-allocator' ), $idx );
                                        continue;
                                }

                                if ( ! isset( $targets[ $target ] ) ) {
                                        $product = function_exists( 'wc_get_product' ) ? wc_get_product( $target ) : null;
                                        if ( ! ( $product instanceof \WC_Product ) ) {
                                                $errors[] = sprintf( __( 'Product %d no longer exists.', 'lpr-backorder-allocator' ), $target );
                                                continue;
                                        }

                                        $before = function_exists( 'wc_stock_amount' ) ? wc_stock_amount( $product->get_stock_quantity() ) : (int) $product->get_stock_quantity();
                                        $targets[ $target ] = array(
                                                'product'   => $product,
                                                'before'    => $before,
                                                'qty_total' => 0,
                                        );
                                }

                                $targets[ $target ]['qty_total'] += $qty;
                                $line_sequence[] = array(
                                        'target'       => $target,
                                        'product_id'   => (int) ( $entry['product_id'] ?? 0 ),
                                        'variation_id' => (int) ( $entry['variation_id'] ?? 0 ),
                                        'qty'          => $qty,
                                );
                        }

                        if ( ! empty( $errors ) ) {
                                self::mark_receipt_failed( $po_id, $receipts, $receipt_index, $errors, $revert_lines, $po_lines );
                                return;
                        }

                        $applied = array();
                        foreach ( $targets as $target => $data ) {
                                try {
                                        $after_raw = function_exists( 'wc_update_product_stock' ) ? wc_update_product_stock( $data['product'], $data['qty_total'], 'increase' ) : null;
                                        $after     = function_exists( 'wc_stock_amount' ) ? wc_stock_amount( $after_raw ) : (int) $after_raw;
                                } catch ( \WC_Data_Exception $e ) {
                                        $errors[] = $e->getMessage();
                                        break;
                                }

                                $applied[ $target ] = array(
                                        'before' => $data['before'],
                                        'after'  => $after,
                                        'qty'    => $data['qty_total'],
                                );
                        }

                        if ( ! empty( $errors ) ) {
                                foreach ( $applied as $target => $data ) {
                                        try {
                                                if ( function_exists( 'wc_update_product_stock' ) ) {
                                                        wc_update_product_stock( $targets[ $target ]['product'], $data['qty'], 'decrease' );
                                                }
                                        } catch ( \Exception $e ) { // phpcs:ignore Generic.CodeAnalysis.EmptyStatement.DetectedCatch
                                                // Best-effort revert.
                                        }
                                }

                                self::mark_receipt_failed( $po_id, $receipts, $receipt_index, $errors, $revert_lines, $po_lines );
                                return;
                        }

                        $running = array();
                        foreach ( $line_sequence as $line ) {
                                $target = $line['target'];
                                if ( ! isset( $applied[ $target ] ) ) {
                                        continue;
                                }
                                $before              = isset( $running[ $target ] ) ? $running[ $target ] : $applied[ $target ]['before'];
                                $after               = $before + $line['qty'];
                                $running[ $target ]  = $after;
                                $line_logs[]         = array(
                                        'product_id'   => $line['product_id'],
                                        'variation_id' => $line['variation_id'],
                                        'qty'          => $line['qty'],
                                        'stock_before' => $before,
                                        'stock_after'  => $after,
                                );
                        }

                        $receipts[ $receipt_index ]['status']       = 'completed';
                        $receipts[ $receipt_index ]['logs']         = $line_logs;
                        $receipts[ $receipt_index ]['completed_at'] = current_time( 'mysql' );
                        $receipts[ $receipt_index ]['message']      = (string) ( $receipts[ $receipt_index ]['message'] ?? '' );
                        self::save_receipts( $po_id, $receipts );

                        if ( class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                Incoming_Stock_Indexer::refresh_all();
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_maybe_close_po' ) ) {
                                lpr_allocator_maybe_close_po( $po_id );
                        }
                }

                /**
                 * Mark a receipt as failed and restore received quantities.
                 *
                 * @param int   $po_id
                 * @param array $receipts
                 * @param int   $receipt_index
                 * @param array $errors
                 * @param array $revert_lines idx => qty_before
                 * @param array $po_lines
                 */
                protected static function mark_receipt_failed( int $po_id, array $receipts, int $receipt_index, array $errors, array $revert_lines, array $po_lines ): void {
                        $changed = false;
                        foreach ( $revert_lines as $idx => $prev_received ) {
                                if ( ! isset( $po_lines[ $idx ] ) ) {
                                        continue;
                                }
                                $po_lines[ $idx ]['qty_received'] = max( 0, (int) $prev_received );
                                $changed                           = true;
                        }

                        if ( $changed ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $po_lines );
                                if ( class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                        Incoming_Stock_Indexer::refresh_all();
                                }
                        }

                        $current_message = isset( $receipts[ $receipt_index ]['message'] ) ? (string) $receipts[ $receipt_index ]['message'] : '';
                        $error_message   = implode( ' ', array_unique( array_map( 'wp_strip_all_tags', $errors ) ) );

                        $receipts[ $receipt_index ]['status']  = 'failed';
                        $receipts[ $receipt_index ]['message'] = trim( $current_message . ' ' . $error_message );
                        self::save_receipts( $po_id, $receipts );
                }

                /**
                 * Build PO line payload for the modal.
                 *
                 * @param int $po_id
                 * @return array<int, array<string, mixed>>
                 */
                public static function collect_lines( int $po_id ): array {
                        $raw = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( ! is_array( $raw ) ) {
                                return array();
                        }

                        $out = array();
                        foreach ( $raw as $idx => $line ) {
                                $ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                $received = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
                                $target   = isset( $line['variation_id'] ) && (int) $line['variation_id'] > 0 ? (int) $line['variation_id'] : (int) ( $line['product_id'] ?? 0 );
                                if ( $ordered <= 0 || $target <= 0 ) {
                                        continue;
                                }

                                $product = function_exists( 'wc_get_product' ) ? wc_get_product( $target ) : null;
                                $label   = $product ? lpr_allocator_product_option_label( $target ) : '#' . $target;
                                $label   = wp_strip_all_tags( $label );
                                $stock   = null;
                                if ( $product instanceof \WC_Product ) {
                                        $stock = function_exists( 'wc_stock_amount' ) ? wc_stock_amount( $product->get_stock_quantity() ) : (int) $product->get_stock_quantity();
                                }

                                $out[] = array(
                                        'idx'       => (int) $idx,
                                        'product'   => esc_html( $label ),
                                        'ordered'   => $ordered,
                                        'received'  => $received,
                                        'stock'     => $stock,
                                        'remaining' => max( 0, $ordered - $received ),
                                );
                        }

                        return $out;
                }

                /**
                 * AJAX: fetch modal rows with live stock.
                 */
                public static function ajax_lines(): void {
                        $po_id = isset( $_POST['po_id'] ) ? absint( $_POST['po_id'] ) : 0;
                        $nonce = isset( $_POST['nonce'] ) ? (string) wp_unslash( $_POST['nonce'] ) : '';
                        $mobile_ok = class_exists( __NAMESPACE__ . '\\Incoming_Mobile_Inbox' ) ? Incoming_Mobile_Inbox::authorize_ajax_request( $po_id ) : false;

                        if ( ! $po_id ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }
                        if ( ! $mobile_ok ) {
                                if ( ! wp_verify_nonce( $nonce, 'lpr_receive_po_' . $po_id ) ) {
                                        wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                                }
                                if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                        wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                                }
                        }

                        $post = get_post( $po_id );
                        if ( ! ( $post instanceof \WP_Post ) || ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                wp_send_json_error( array( 'message' => __( 'PO not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) && PO_STATUS_CLOSED === $post->post_status ) {
                                wp_send_json_error( array( 'message' => __( 'This PO is closed.', 'lpr-backorder-allocator' ) ) );
                        }

                        $lines = self::collect_lines( $po_id );
                        wp_send_json_success( array( 'lines' => $lines ) );
                }

                /**
                 * AJAX: apply received quantities and queue inventory adjustments via Action Scheduler.
                 */
                public static function ajax_apply(): void {
                        $po_id = isset( $_POST['po_id'] ) ? absint( $_POST['po_id'] ) : 0;
                        $nonce = isset( $_POST['nonce'] ) ? (string) wp_unslash( $_POST['nonce'] ) : '';
                        $mobile_ok = class_exists( __NAMESPACE__ . '\\Incoming_Mobile_Inbox' ) ? Incoming_Mobile_Inbox::authorize_ajax_request( $po_id ) : false;

                        if ( ! $po_id ) {
                                wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                        }
                        if ( ! $mobile_ok ) {
                                if ( ! wp_verify_nonce( $nonce, 'lpr_receive_po_' . $po_id ) ) {
                                        wp_send_json_error( array( 'message' => __( 'Invalid request.', 'lpr-backorder-allocator' ) ) );
                                }
                                if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                        wp_send_json_error( array( 'message' => __( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ) );
                                }
                        }

                        $post = get_post( $po_id );
                        if ( ! ( $post instanceof \WP_Post ) || ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                wp_send_json_error( array( 'message' => __( 'PO not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) && PO_STATUS_CLOSED === $post->post_status ) {
                                wp_send_json_error( array( 'message' => __( 'This PO is closed and cannot receive stock.', 'lpr-backorder-allocator' ) ) );
                        }

                        if ( ! function_exists( 'as_enqueue_async_action' ) && ! function_exists( 'as_schedule_single_action' ) ) {
                                wp_send_json_error( array( 'message' => __( 'Action Scheduler is required to receive stock.', 'lpr-backorder-allocator' ) ) );
                        }

                        $submitted = isset( $_POST['lines'] ) ? (array) $_POST['lines'] : array();
                        $note_raw  = isset( $_POST['note'] ) ? (string) wp_unslash( $_POST['note'] ) : '';
                        $note      = sanitize_textarea_field( $note_raw );
                        $lines     = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( ! is_array( $lines ) ) {
                                $lines = array();
                        }

                        $changed        = false;
                        $errors         = array();
                        $receipt_lines  = array();
                        foreach ( $submitted as $idx => $qty ) {
                                $idx = (int) $idx;
                                if ( ! isset( $lines[ $idx ] ) ) {
                                        continue;
                                }
                                $qty_now  = max( 0, (int) $qty );
                                $ordered  = isset( $lines[ $idx ]['qty_ordered'] ) ? max( 0, (int) $lines[ $idx ]['qty_ordered'] ) : 0;
                                $received = isset( $lines[ $idx ]['qty_received'] ) ? max( 0, (int) $lines[ $idx ]['qty_received'] ) : 0;
                                if ( $ordered <= 0 || $qty_now <= 0 ) {
                                        continue;
                                }
                                $remaining = max( 0, $ordered - $received );
                                if ( $remaining <= 0 ) {
                                        continue;
                                }

                                if ( $qty_now > $remaining ) {
                                        $label = isset( $lines[ $idx ]['product_id'] ) ? (string) $lines[ $idx ]['product_id'] : (string) $idx;
                                        if ( isset( $lines[ $idx ]['variation_id'] ) && (int) $lines[ $idx ]['variation_id'] > 0 ) {
                                                $label = (string) $lines[ $idx ]['variation_id'];
                                        }
                                        $errors[] = sprintf(
                                                /* translators: 1: product identifier, 2: remaining quantity */
                                                __( 'Line %1$s exceeds the remaining quantity (%2$d).', 'lpr-backorder-allocator' ),
                                                esc_html( $label ),
                                                $remaining
                                        );
                                        continue;
                                }

                                $lines[ $idx ]['qty_received'] = $received + $qty_now;
                                $changed                       = true;

                                $receipt_lines[] = array(
                                        'idx'          => $idx,
                                        'product_id'   => (int) ( $lines[ $idx ]['product_id'] ?? 0 ),
                                        'variation_id' => (int) ( $lines[ $idx ]['variation_id'] ?? 0 ),
                                        'qty_ordered'  => $ordered,
                                        'qty_before'   => $received,
                                        'qty'          => $qty_now,
                                );
                        }

                        if ( ! empty( $errors ) ) {
                                wp_send_json_error(
                                        array(
                                                'message' => __( 'Quantities cannot exceed the remaining ordered amount.', 'lpr-backorder-allocator' ),
                                                'details' => $errors,
                                                'lines'   => self::collect_lines( $po_id ),
                                        )
                                );
                        }

                        if ( empty( $receipt_lines ) ) {
                                wp_send_json_error(
                                        array(
                                                'message' => __( 'No quantities were provided.', 'lpr-backorder-allocator' ),
                                                'lines'   => self::collect_lines( $po_id ),
                                        )
                                );
                        }

                        $receipt_id = uniqid( 'rcpt_', true );
                        $receipt    = array(
                                'id'          => $receipt_id,
                                'status'      => 'pending',
                                'created_at'  => current_time( 'mysql' ),
                                'created_gmt' => current_time( 'mysql', true ),
                                'created_by'  => get_current_user_id(),
                                'action_id'   => null,
                                'lines'       => $receipt_lines,
                                'logs'        => array(),
                                'message'     => $note,
                        );

                        $action_id = self::enqueue_action( $po_id, $receipt_id );
                        if ( ! $action_id ) {
                                foreach ( $receipt_lines as $line ) {
                                        $idx = (int) $line['idx'];
                                        if ( isset( $lines[ $idx ] ) ) {
                                                $lines[ $idx ]['qty_received'] = $line['qty_before'];
                                        }
                                }
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );
                                wp_send_json_error(
                                        array(
                                                'message' => __( 'Unable to queue the receipt. Please retry.', 'lpr-backorder-allocator' ),
                                                'lines'   => self::collect_lines( $po_id ),
                                        )
                                );
                        }

                        $receipt['action_id'] = (int) $action_id;

                        if ( $changed ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );
                        }

                        $receipts   = self::get_receipts( $po_id );
                        $receipts[] = $receipt;
                        self::save_receipts( $po_id, $receipts );

                        if ( class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
                                Incoming_Stock_Indexer::refresh_all();
                        }

                        if ( function_exists( __NAMESPACE__ . '\lpr_allocator_maybe_close_po' ) ) {
                                lpr_allocator_maybe_close_po( $po_id );
                        }

                        // Run the receipt immediately to ensure inventory is updated even before the async worker runs.
                        try {
                                self::process_receipt( $po_id, $receipt_id );
                        } catch ( \Throwable $e ) {
                                // Avoid surfacing fatal errors to the AJAX caller; the queued action will still run.
                                if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
                                        error_log( sprintf( 'LPR allocator receipt sync failure: %s', $e->getMessage() ) );
                                }
                        }

                        $message = __( 'Job scheduled. Stock will update asynchronously.', 'lpr-backorder-allocator' );
                        wp_send_json_success(
                                array(
                                        'message' => $message,
                                        'lines'   => self::collect_lines( $po_id ),
                                        'redirect' => $mobile_ok && class_exists( __NAMESPACE__ . '\\Incoming_Mobile_Inbox' ) ? Incoming_Mobile_Inbox::allocation_url( $po_id ) : '',
                                )
                        );
                }
        }
        PO_Receive_Stock_UI::init();
}

if ( ! class_exists( __NAMESPACE__ . '\PO_Allocation_Overview' ) ) {
        /**
         * Supplier PO metabox: lists orders served by this PO.
         */
        class PO_Allocation_Overview {

                public static function init(): void {
                        add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 30 );
                }

                public static function register_box(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        add_meta_box(
                                'lpr_po_allocation_overview',
                                __( 'PO Allocation Overview', 'lpr-backorder-allocator' ),
                                array( __CLASS__, 'render_box' ),
                                defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                'normal',
                                'default'
                        );
                }

                /**
                 * Collect allocation rows for this PO from the allocation index.
                 *
                 * @param int $po_id
                 * @return array<int, array<string, mixed>>
                 */
                public static function collect_rows( int $po_id ): array {
                        if ( $po_id <= 0 || ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_po_allocation_index' ) ) {
                                return array();
                        }

                        lpr_allocator_refresh_po_allocation_state( $po_id );

                        $index = lpr_allocator_get_po_allocation_index( $po_id );
                        if ( empty( $index ) ) {
                                return array();
                        }

                        $rows      = array();
                        $exclude   = array( 'trash' );
                        $po_eta    = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                        $meta_key  = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';

                        foreach ( $index as $entry ) {
                                $order_id = isset( $entry['order_id'] ) ? absint( $entry['order_id'] ) : 0;
                                $item_id  = isset( $entry['item_id'] ) ? absint( $entry['item_id'] ) : 0;
                                if ( $order_id <= 0 || $item_id <= 0 ) {
                                        continue;
                                }

                                $order = wc_get_order( $order_id );
                                if ( ! ( $order instanceof \WC_Order ) ) {
                                        continue;
                                }
                                if ( $order->has_status( $exclude ) ) {
                                        continue;
                                }

                                $item = $order->get_item( $item_id );
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }
                                if ( method_exists( $item, 'read_meta_data' ) ) {
                                        $item->read_meta_data( true );
                                }

                                $allocs = $item->get_meta( $meta_key, true );
                                if ( ! is_array( $allocs ) ) {
                                        continue;
                                }

                                $qty_allocated = 0;
                                $eta_row       = '';
                                foreach ( $allocs as $row ) {
                                        $row_po_id = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
                                        if ( $row_po_id !== $po_id ) {
                                                continue;
                                        }

                                        $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                        if ( 'released' === $status ) {
                                                continue;
                                        }

                                        $row_qty = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
                                        if ( $row_qty <= 0 ) {
                                                continue;
                                        }

                                        $qty_allocated += $row_qty;

                                        if ( ! empty( $row['eta'] ) ) {
                                                $candidate_eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                                $eta_row       = self::earliest_eta( $eta_row, $candidate_eta );
                                        }
                                }

                                if ( $qty_allocated <= 0 ) {
                                        continue;
                                }

                                $order_url  = method_exists( $order, 'get_edit_order_url' ) ? $order->get_edit_order_url() : get_edit_post_link( $order_id, 'url' );
                                $order_no   = method_exists( $order, 'get_order_number' ) ? $order->get_order_number() : (string) $order_id;
                                $full_name  = method_exists( $order, 'get_formatted_billing_full_name' ) ? $order->get_formatted_billing_full_name() : trim( $order->get_billing_first_name() . ' ' . $order->get_billing_last_name() );
                                $product    = $item->get_name();
                                $sku        = $item->get_product() instanceof \WC_Product ? $item->get_product()->get_sku() : '';
                                $label      = $product;
                                if ( $sku ) {
                                        $label .= ' (' . $sku . ')';
                                }

                                $order_value = function_exists( 'wc_price' ) ? wc_price( $order->get_total(), array( 'currency' => $order->get_currency() ) ) : number_format_i18n( (float) $order->get_total(), 2 );
                                $status_name = function_exists( 'wc_get_order_status_name' ) ? wc_get_order_status_name( $order->get_status() ) : $order->get_status();
                                $ready       = self::order_ready_by_eta( $order, $eta_row ? $eta_row : $po_eta );

                                $rows[] = array(
                                        'order_id'     => $order_id,
                                        'order_number' => $order_no,
                                        'order_url'    => $order_url,
                                        'customer'     => $full_name,
                                        'product'      => $label,
                                        'qty'          => $qty_allocated,
                                        'order_value'  => $order_value,
                                        'status'       => $status_name,
                                        'vip'          => class_exists( __NAMESPACE__ . '\Order_VIP_Prioritizer' ) ? Order_VIP_Prioritizer::is_vip_order( $order ) : false,
                                        'eta'          => $eta_row ? $eta_row : $po_eta,
                                        'ready'        => $ready,
                                );
                        }

                        return $rows;
                }

                protected static function earliest_eta( string $current, string $candidate ): string {
                        if ( '' === $candidate ) {
                                return $current;
                        }
                        if ( '' === $current ) {
                                return $candidate;
                        }

                        return lpr_allocator_compare_dates( $candidate, $current ) < 0 ? $candidate : $current;
                }

                /**
                 * Determine if an order should be fully allocated by the time this PO arrives.
                 */
                protected static function order_ready_by_eta( \WC_Order $order, string $eta ): ?bool {
                        $cutoff_eta = lpr_allocator_sanitize_ymd( $eta );
                        if ( '' === $cutoff_eta ) {
                                return null;
                        }

                        $force_key    = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation';
                        $alloc_key    = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $has_relevant = false;

                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                if ( ! $item instanceof \WC_Order_Item_Product ) {
                                        continue;
                                }

                                $force_qty = (int) $item->get_meta( $force_key, true );
                                $desired   = function_exists( __NAMESPACE__ . '\\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : max( 0, (int) $item->get_quantity() );
                                $target    = max( $desired, $force_qty );

                                if ( $target <= 0 ) {
                                        continue;
                                }

                                $has_relevant    = true;
                                $allocs          = $item->get_meta( $alloc_key, true );
                                $total_allocated = 0;
                                $latest_eta      = '';

                                if ( is_array( $allocs ) ) {
                                        foreach ( $allocs as $alloc ) {
                                                $status = isset( $alloc['status'] ) ? sanitize_key( (string) $alloc['status'] ) : 'reserved';
                                                if ( 'released' === $status ) {
                                                        continue;
                                                }

                                                $eta_row = lpr_allocator_sanitize_ymd( (string) ( $alloc['eta'] ?? '' ) );
                                                if ( '' === $eta_row && ! empty( $alloc['po_id'] ) ) {
                                                        $eta_row = lpr_allocator_sanitize_ymd( (string) get_post_meta( (int) $alloc['po_id'], defined( __NAMESPACE__ . '\\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                                                }
                                                if ( '' === $eta_row ) {
                                                        continue;
                                                }

                                                $qty_row = isset( $alloc['qty_allocated'] ) ? max( 0, (int) $alloc['qty_allocated'] ) : 0;
                                                if ( $qty_row <= 0 ) {
                                                        continue;
                                                }

                                                $total_allocated += $qty_row;

                                                if ( '' === $latest_eta || lpr_allocator_compare_dates( $eta_row, $latest_eta ) > 0 ) {
                                                        $latest_eta = $eta_row;
                                                }
                                        }
                                }

                                if ( $total_allocated < $target ) {
                                        return false;
                                }

                                if ( '' !== $latest_eta && lpr_allocator_compare_dates( $latest_eta, $cutoff_eta ) > 0 ) {
                                        return false;
                                }
                        }

                        return $has_relevant ? true : null;
                }

                public static function render_box( \WP_Post $post ): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        $rows = self::collect_rows( (int) $post->ID );

                        echo '<style>.lpr-po-alloc-overview{width:100%;border-collapse:collapse}.lpr-po-alloc-overview th,.lpr-po-alloc-overview td{border-bottom:1px solid #ddd;padding:6px;text-align:left;vertical-align:top}.lpr-po-alloc-overview th{white-space:nowrap}.lpr-badge{display:inline-block;padding:2px 6px;border-radius:3px;background:#f0ad4e;color:#111;font-size:11px;margin-left:6px}.lpr-badge.lpr-badge-vip{background:#c2274e;color:#fff;font-weight:600}.lpr-badge.lpr-badge-ready{background:#3aa35c;color:#fff;font-weight:600}.lpr-badge.lpr-badge-muted{background:#e5e7eb;color:#111;font-weight:600}</style>';

                        if ( empty( $rows ) ) {
                                echo '<p>' . esc_html__( 'No allocations found for this PO.', 'lpr-backorder-allocator' ) . '</p>';
                                return;
                        }

                        echo '<table class="widefat striped lpr-po-alloc-overview">';
                        echo '<thead><tr>';
                        echo '<th>' . esc_html__( 'Order', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'Customer', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'Product / Qty', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'Order Value', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'Status', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'Ready on arrival', 'lpr-backorder-allocator' ) . '</th>';
                        echo '<th>' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th>';
                        echo '</tr></thead><tbody>';

                        foreach ( $rows as $row ) {
                                $order_link = ! empty( $row['order_url'] ) ? '<a href="' . esc_url( $row['order_url'] ) . '">' . esc_html( '#' . $row['order_number'] ) . '</a>' : esc_html( '#' . $row['order_number'] );
                                if ( ! empty( $row['vip'] ) && class_exists( __NAMESPACE__ . '\Order_VIP_Prioritizer' ) ) {
                                        $order_link .= ' ' . Order_VIP_Prioritizer::vip_badge_html();
                                }
                                $product    = esc_html( $row['product'] );
                                $qty        = esc_html( (string) $row['qty'] );
                                $eta_val    = $row['eta'] ? lpr_allocator_format_store_date( $row['eta'] ) : '';
                                $eta        = $eta_val ? esc_html( $eta_val ) : '&#8211;';
                                $ready_cell = '&#8211;';
                                if ( true === $row['ready'] ) {
                                        $ready_cell = '<span class="lpr-badge lpr-badge-ready">' . esc_html__( 'Yes', 'lpr-backorder-allocator' ) . '</span>';
                                } elseif ( false === $row['ready'] ) {
                                        $ready_cell = '<span class="lpr-badge">' . esc_html__( 'No', 'lpr-backorder-allocator' ) . '</span>';
                                } elseif ( null === $row['ready'] ) {
                                        $ready_cell = '<span class="lpr-badge lpr-badge-muted">' . esc_html__( 'Unknown', 'lpr-backorder-allocator' ) . '</span>';
                                }

                                echo '<tr>';
                                echo '<td>' . $order_link . '</td>';
                                echo '<td>' . esc_html( $row['customer'] ) . '</td>';
                                echo '<td>' . $product . ' &times; ' . $qty . '</td>';
                                echo '<td>' . wp_kses_post( $row['order_value'] ) . '</td>';
                                echo '<td>' . esc_html( $row['status'] ) . '</td>';
                                echo '<td>' . wp_kses_post( $ready_cell ) . '</td>';
                                echo '<td>' . $eta . '</td>';
                                echo '</tr>';
                        }

                        echo '</tbody></table>';
                }
        }
        PO_Allocation_Overview::init();
}

/* SELF-CHECK:
- Added PO_FIFO_Allocator (new class) with:
  - admin_post handler `lpr_allocate_po` (nonce + manage_woocommerce required).
  - Async worker via Action Scheduler (`lpr_allocator_allocate_po`) with fallback to inline if AS unavailable.
  - FIFO allocation per PO line: builds queue of backordered items (statuses from settings) sorted by paid date ASC (fallback created), then created ASC, then order ID ASC.
  - Allocates up to (qty_ordered - qty_allocated) per PO line; appends ledger rows to order item meta `lpr_allocations`; increments line `qty_allocated`; no stock writes.
  - Adds private order notes and batches ETA recompute via ETA::update_line_eta() for affected orders.
  - Uses wc_get_orders with pagination and returns IDs (no wildcard meta_query). Per-SKU transient lock to avoid contention.
- Added PO_Allocate_Button_UI (new class) to render "Allocate" button on PO edit and show admin notices.
- New helper function lpr_allocator_calc_backorder_need() (guarded) to compute remaining needed qty per item using Backordered meta/forced allocations minus active allocations.
- All declarations are new & guarded; used Woo CRUD only; respects admin/cron-only early return; frontend remains untouched.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() && ! lpr_allocator_is_incoming_request() ) {
        return;
}

/**
 * Helper: compute the "desired" backordered quantity for a line item.
 * Mirrors the logic used by lpr_allocator_calc_backorder_need(), but without subtracting allocations.
 *
 * Only uses order-time backorder indicators (forced allocation meta or the
 * recorded Backordered quantity). Live product stock state is deliberately
 * ignored so we don't misclassify lines placed while inventory was available.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ) {
        function lpr_allocator_calc_backorder_desired( \WC_Order_Item_Product $item ): int {
                if ( ! $item instanceof \WC_Order_Item_Product ) {
                        return 0;
                }
                $qty     = max( 0, (int) $item->get_quantity() );
                $product = $item->get_product();
                if ( ! ( $product instanceof \WC_Product ) ) {
                        return 0;
                }

                $desired    = 0;
                $force_qty  = (int) $item->get_meta( defined( __NAMESPACE__ . '\\ORDER_ITEM_META_FORCE_ALLOCATION' ) ? ORDER_ITEM_META_FORCE_ALLOCATION : '_lpr_force_allocation', true );
                $meta_back  = class_exists( __NAMESPACE__ . '\\Backorder' ) ? Backorder::get_backordered_qty( $item ) : 0;
                $desired    = max( $force_qty, $meta_back );

                // Safety clamp to the line quantity.
                return min( $desired, $qty );
        }
}

/**
 * Helper: sum of active (non-released) allocations for a line item.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ) {
        function lpr_allocator_get_item_allocated_active( \WC_Order_Item_Product $item ): int {
                if ( ! $item instanceof \WC_Order_Item_Product ) {
                        return 0;
                }
		$key   = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
		$alloc = $item->get_meta( $key, true );
		$sum   = 0;
		if ( is_array( $alloc ) ) {
			foreach ( $alloc as $row ) {
				$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
				if ( 'released' === $status ) {
					continue;
				}
				$sum += isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
			}
		}
		return max( 0, $sum );
	}
}

/**
 * Helper: get or create a "Quick PO Draft" for the current user and optionally seed header meta.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_or_create_quick_po_for_user' ) ) {
        function lpr_allocator_get_or_create_quick_po_for_user( string $supplier = '', string $eta_ymd = '', string $po_number = '' ): int {
                $user_id = get_current_user_id();
                if ( $user_id <= 0 ) {
                        return 0;
                }
                $meta_key = 'lpr_quick_po_draft_id';
                $po_id    = (int) get_user_meta( $user_id, $meta_key, true );

                $valid = false;
                if ( $po_id > 0 ) {
                        $post           = get_post( $po_id );
                        $draft_statuses = array( 'draft', 'auto-draft' );
                        if ( $post instanceof \WP_Post && $post->post_type === ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) && in_array( $post->post_status, $draft_statuses, true ) ) {
                                $valid = true;
                        } else {
                                $po_id = 0; // never reuse open/trashed POs for quick add.
                        }
                }

                if ( ! $valid ) {
                        $title = sprintf(
                                /* translators: 1: user display name, 2: date time */
                                __( 'Quick PO Draft â€“ %1$s â€“ %2$s', 'lpr-backorder-allocator' ),
                                wp_get_current_user()->display_name ?: 'User',
                                wp_date( 'd-m-Y H:i' )
                        );
                        $po_id = wp_insert_post(
                                array(
                                        'post_type'   => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                        'post_status' => 'draft',
                                        'post_title'  => $title,
                                ),
                                true
                        );
                        if ( is_wp_error( $po_id ) ) {
                                return 0;
                        }
                        update_user_meta( $user_id, $meta_key, (int) $po_id );
                }

                // Seed header fields if provided (non-empty).
                if ( $po_id > 0 ) {
                        if ( '' !== $supplier ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', sanitize_text_field( $supplier ) );
                        }
                        if ( '' !== $po_number ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', sanitize_text_field( $po_number ) );
                        }
                        if ( '' !== $eta_ymd ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', lpr_allocator_sanitize_ymd( $eta_ymd ) );
                        }
                        // Ensure lines array exists.
                        $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( ! is_array( $lines ) ) {
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', array() );
                        }
                }

                return (int) $po_id;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_live_po_statuses' ) ) {
        /**
         * Statuses considered "live" for PO availability and allocation.
         *
         * @return array
         */
        function lpr_allocator_live_po_statuses(): array {
                $statuses = array( defined( __NAMESPACE__ . '\PO_STATUS_OPEN' ) ? PO_STATUS_OPEN : 'open' );
                if ( defined( __NAMESPACE__ . '\PO_STATUS_PARTIAL' ) ) {
                        $statuses[] = PO_STATUS_PARTIAL;
                }
                return $statuses;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_po_is_fully_received' ) ) {
        /**
         * Determine if every PO line has been fully received.
         */
        function lpr_allocator_po_is_fully_received( int $po_id ): bool {
                $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                if ( ! is_array( $lines ) || empty( $lines ) ) {
                        return false;
                }

                $has_ordered_lines = false;
                foreach ( $lines as $line ) {
                        $ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                        $received = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;

                        if ( $ordered <= 0 ) {
                                continue;
                        }

                        $has_ordered_lines = true;

                        if ( $received < $ordered ) {
                                return false;
                        }
                }

                return $has_ordered_lines;
        }
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_maybe_close_po' ) ) {
        /**
         * Close a PO when all ordered lines are fully received.
         */
        function lpr_allocator_maybe_close_po( int $po_id ): void {
                if ( $po_id <= 0 ) {
                        return;
                }

                $post = get_post( $po_id );
                if ( ! ( $post instanceof \WP_Post ) ) {
                        return;
                }

                $status_closed = defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) ? PO_STATUS_CLOSED : 'closed';
                $live_statuses = lpr_allocator_live_po_statuses();

                if ( in_array( $post->post_status, $live_statuses, true ) && lpr_allocator_po_is_fully_received( $po_id ) ) {
                        wp_update_post(
                                array(
                                        'ID'          => $po_id,
                                        'post_status' => $status_closed,
                                )
                        );
                }
        }
}

/**
 * Builds and stores incoming PO availability for products (frontend notices + admin UI).
 */
if ( ! class_exists( __NAMESPACE__ . '\PO_Allocation_Overage_Checker' ) ) {
        /**
         * Ensures POs are not over-allocated beyond ordered quantity.
         * Releases the newest allocations when an overage is detected.
         */
        class PO_Allocation_Overage_Checker {

                /**
                 * Entry point (used by other scheduled jobs).
                 */
                public static function run(): void {
                        if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_po_allocation_index' ) ) {
                                return;
                        }

                        $query = new \WP_Query(
                                array(
                                        'post_type'      => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                        'post_status'    => lpr_allocator_live_po_statuses(),
                                        'posts_per_page' => -1,
                                        'fields'         => 'ids',
                                        'no_found_rows'  => true,
                                )
                        );

                        foreach ( $query->posts as $po_id ) {
                                self::rebalance_po( (int) $po_id );
                        }
                }

                /**
                 * Remove over-allocations from the newest rows for a PO.
                 */
                protected static function rebalance_po( int $po_id ): void {
                        $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( ! is_array( $lines ) || empty( $lines ) ) {
                                return;
                        }

                        $caps = array(); // target_id => qty_ordered cap
                        foreach ( $lines as $line ) {
                                $qty_ordered = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                $variation  = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
                                $product    = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
                                $target_id  = $variation > 0 ? $variation : $product;
                                if ( $target_id <= 0 || $qty_ordered <= 0 ) {
                                        continue;
                                }
                                $caps[ $target_id ] = ( $caps[ $target_id ] ?? 0 ) + $qty_ordered;
                        }

                        if ( empty( $caps ) ) {
                                return;
                        }

                        $index = lpr_allocator_get_po_allocation_index( $po_id );
                        if ( empty( $index ) ) {
                                return;
                        }

                        $meta_key   = ORDER_ITEM_META_ALLOCATIONS;
                        $per_target = array();
                        $items      = array(); // map_key => ['item' => WC_Order_Item_Product, 'allocs' => array, 'changed' => bool]

                        foreach ( $index as $row ) {
                                $order_id = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                                $item_id  = isset( $row['item_id'] ) ? absint( $row['item_id'] ) : 0;
                                if ( $order_id <= 0 || $item_id <= 0 ) {
                                        continue;
                                }

                                $order = wc_get_order( $order_id );
                                if ( ! ( $order instanceof \WC_Order ) ) {
                                        continue;
                                }
                                $item = $order->get_item( $item_id );
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                $allocs = $item->get_meta( $meta_key, true );
                                if ( ! is_array( $allocs ) ) {
                                        continue;
                                }

                                $map_key = $order_id . ':' . $item_id;
                                if ( ! isset( $items[ $map_key ] ) ) {
                                        $items[ $map_key ] = array(
                                                'item'     => $item,
                                                'allocs'   => $allocs,
                                                'changed'  => false,
                                                'released' => 0,
                                        );
                                }

                                $target_id = (int) $item->get_variation_id();
                                if ( $target_id <= 0 ) {
                                        $target_id = (int) $item->get_product_id();
                                }
                                if ( $target_id <= 0 || ! isset( $caps[ $target_id ] ) ) {
                                        continue;
                                }

                                foreach ( $allocs as $idx => $alloc_row ) {
                                        $row_po_id = isset( $alloc_row['po_id'] ) ? (int) $alloc_row['po_id'] : 0;
                                        if ( $row_po_id !== $po_id ) {
                                                continue;
                                        }
                                        $status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                        if ( 'released' === $status ) {
                                                continue;
                                        }
                                        $qty = isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                        if ( $qty <= 0 ) {
                                                continue;
                                        }

                                        $per_target[ $target_id ]['total'] = ( $per_target[ $target_id ]['total'] ?? 0 ) + $qty;
                                        $per_target[ $target_id ]['rows'][] = array(
                                                'map_key'      => $map_key,
                                                'index'        => (int) $idx,
                                                'qty'          => $qty,
                                                'allocated_at' => isset( $alloc_row['allocated_at'] ) ? (string) $alloc_row['allocated_at'] : '',
                                                'eta'          => isset( $alloc_row['eta'] ) ? (string) $alloc_row['eta'] : '',
                                        );
                                }
                        }

                        $affected_orders = array();

                        foreach ( $per_target as $target_id => $data ) {
                                $cap   = (int) ( $caps[ $target_id ] ?? 0 );
                                $total = (int) ( $data['total'] ?? 0 );
                                $over  = max( 0, $total - $cap );
                                if ( $over <= 0 ) {
                                        continue;
                                }

                                $rows = $data['rows'] ?? array();
                                usort(
                                        $rows,
                                        static function ( $a, $b ) {
                                                $a_time = isset( $a['allocated_at'] ) ? (string) $a['allocated_at'] : '';
                                                $b_time = isset( $b['allocated_at'] ) ? (string) $b['allocated_at'] : '';
                                                if ( $a_time !== $b_time ) {
                                                        return lpr_allocator_compare_dates( $b_time, $a_time );
                                                }
                                                $a_eta = isset( $a['eta'] ) ? (string) $a['eta'] : '';
                                                $b_eta = isset( $b['eta'] ) ? (string) $b['eta'] : '';
                                                return lpr_allocator_compare_dates( $b_eta, $a_eta );
                                        }
                                );

                                foreach ( $rows as $row ) {
                                        if ( $over <= 0 ) {
                                                break;
                                        }
                                        $key = $row['map_key'];
                                        if ( ! isset( $items[ $key ]['allocs'] ) ) {
                                                continue;
                                        }
                                        $idx = (int) $row['index'];
                                        if ( ! isset( $items[ $key ]['allocs'][ $idx ] ) ) {
                                                continue;
                                        }

                                        $current = $items[ $key ]['allocs'][ $idx ];
                                        $status  = isset( $current['status'] ) ? sanitize_key( (string) $current['status'] ) : 'reserved';
                                        if ( 'released' === $status ) {
                                                continue;
                                        }
                                        $row_qty = isset( $current['qty_allocated'] ) ? max( 0, (int) $current['qty_allocated'] ) : 0;
                                        if ( $row_qty <= 0 ) {
                                                continue;
                                        }

                                        $release = min( $row_qty, $over );
                                        if ( $release >= $row_qty ) {
                                                lpr_allocator_touch_allocation_status( $items[ $key ]['allocs'][ $idx ], 'released' );
                                                $items[ $key ]['released'] += $row_qty;
                                        } else {
                                                $items[ $key ]['allocs'][ $idx ]['qty_allocated'] = $row_qty - $release;
                                        }
                                        $items[ $key ]['changed'] = true;
                                        $over                    -= $release;
                                }
                        }

                        $po_number = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
                        $po_label  = $po_number ? sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_number ) : sprintf( __( 'PO #%d', 'lpr-backorder-allocator' ), $po_id );

                        foreach ( $items as $payload ) {
                                if ( empty( $payload['changed'] ) ) {
                                        continue;
                                }
                                $payload['item']->update_meta_data( $meta_key, array_values( $payload['allocs'] ) );
                                $payload['item']->save();
                                if ( ! empty( $payload['released'] ) ) {
                                        $order = wc_get_order( $payload['item']->get_order_id() );
                                        if ( $order instanceof \WC_Order ) {
                                                $release_reason = sprintf( __( 'Adjusted because %s has less available quantity than previously allocated.', 'lpr-backorder-allocator' ), $po_label );

                                                lpr_allocator_add_release_note( $order, $payload['item'], (int) $payload['released'], $release_reason );

                                                lpr_allocator_log_event(
                                                        'allocation_released',
                                                        array(
                                                                'order_id' => $order->get_id(),
                                                                'item_id'  => $payload['item']->get_id(),
                                                                'po_id'    => $po_id,
                                                                'qty'      => (int) $payload['released'],
                                                                'reason'   => $release_reason,
                                                        )
                                                );
                                        }
                                }
                                $affected_orders[ (int) $payload['item']->get_order_id() ] = true;
                        }

                        if ( empty( $affected_orders ) ) {
                                return;
                        }

                        // Refresh PO tallies and ETAs after adjustments.
                        $lines_now = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                        if ( is_array( $lines_now ) ) {
                                $lines_now = lpr_allocator_recalculate_po_lines_from_allocations( $po_id, $lines_now );
                                update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines_now );
                        }

                        foreach ( array_keys( $affected_orders ) as $oid ) {
                                if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                        lpr_allocator_reapply_po_allocations_for_order( (int) $oid );
                                }
                                if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                        ETA::update_line_eta( (int) $oid );
                                }
                        }
                }
        }
}

/**
 * Periodic guardrail to drop allocations pointing at deleted or non-live POs.
 */
if ( ! class_exists( __NAMESPACE__ . '\PO_Allocation_Integrity_Checker' ) ) {
        class PO_Allocation_Integrity_Checker {

                protected const JOB_LABEL = 'Incoming stock indexer integrity check';

                /**
                 * Entry point (used by other scheduled jobs).
                 */
                public static function run(): void {
                        if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_remove_po_allocations_from_orders' ) ) {
                                return;
                        }

                        $po_ids = self::find_po_ids_from_allocations();
                        if ( empty( $po_ids ) ) {
                                return;
                        }

                        $expected_type = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
                        $live_statuses = lpr_allocator_live_po_statuses();

                        // Keep allocations for closed/received POs so the overview retains historical links.
                        $retained_statuses = array_unique(
                                array_merge(
                                        $live_statuses,
                                        array( defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) ? PO_STATUS_CLOSED : 'closed' )
                                )
                        );

                        foreach ( $po_ids as $po_id ) {
                                if ( ! self::po_has_allowed_status( $po_id, $expected_type, $retained_statuses ) ) {
                                        lpr_allocator_remove_po_allocations_from_orders( (int) $po_id );
                                }
                        }

                        self::reconcile_orders();
                }

                protected static function job_label(): string {
                        return __( self::JOB_LABEL, 'lpr-backorder-allocator' );
                }

                /**
                 * Gather PO IDs referenced inside order item allocations.
                 */
                protected static function find_po_ids_from_allocations(): array {
                        global $wpdb;

                        if ( ! ( $wpdb instanceof \wpdb ) ) {
                                return array();
                        }

                        $meta_table  = $wpdb->prefix . 'woocommerce_order_itemmeta';
                        $items_table = $wpdb->prefix . 'woocommerce_order_items';

                        $sql  = $wpdb->prepare(
                                "SELECT im.meta_value\n"
                                . "FROM {$items_table} oi\n"
                                . "INNER JOIN {$meta_table} im ON oi.order_item_id = im.order_item_id\n"
                                . "WHERE im.meta_key = %s",
                                ORDER_ITEM_META_ALLOCATIONS
                        );
                        $rows = $wpdb->get_col( $sql );

                        if ( empty( $rows ) ) {
                                return array();
                        }

                        $po_ids = array();
                        foreach ( $rows as $meta_val ) {
                                $allocs = maybe_unserialize( $meta_val );
                                if ( ! is_array( $allocs ) ) {
                                        continue;
                                }

                                foreach ( $allocs as $alloc_row ) {
                                        $po_id = isset( $alloc_row['po_id'] ) ? absint( $alloc_row['po_id'] ) : 0;
                                        if ( $po_id > 0 ) {
                                                $po_ids[ $po_id ] = true;
                                        }
                                }
                        }

                        return array_keys( $po_ids );
                }

                /**
                 * Check if the PO exists and remains in an allowed status.
                 */
                protected static function po_has_allowed_status( int $po_id, string $expected_type, array $allowed_statuses ): bool {
                        $po = get_post( $po_id );

                        if ( ! ( $po instanceof \WP_Post ) || $po->post_type !== $expected_type ) {
                                return false;
                        }

                        return in_array( $po->post_status, $allowed_statuses, true );
                }

                /**
                 * Build the list of allowed order statuses for allocation (without wc- prefix).
                 */
                protected static function allowed_order_statuses(): array {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $allowed  = array();

                        foreach ( (array) ( $settings['order_statuses'] ?? array() ) as $status ) {
                                $normalized   = sanitize_key( (string) $status );
                                $allowed[]    = preg_replace( '/^wc-/', '', $normalized );
                        }

                        return array_values( array_unique( array_filter( $allowed ) ) );
                }

                /**
                 * Release allocations attached to cancelled/invalid orders and trim quantities after edits.
                 */
                protected static function reconcile_orders(): void {
                        if ( ! function_exists( 'wc_get_order' ) ) {
                                return;
                        }

                        $rows = self::get_order_item_allocations();
                        if ( empty( $rows ) ) {
                                return;
                        }

                        $allowed_statuses = self::allowed_order_statuses();
                        $meta_key         = ORDER_ITEM_META_ALLOCATIONS;

                        $orders_to_refresh = array();

                        foreach ( $rows as $row ) {
                                $order_id = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                                $item_id  = isset( $row['order_item_id'] ) ? absint( $row['order_item_id'] ) : 0;
                                if ( $order_id <= 0 || $item_id <= 0 ) {
                                        continue;
                                }

                                $order = wc_get_order( $order_id );
                                if ( ! ( $order instanceof \WC_Order ) ) {
                                        continue;
                                }

                                $item = $order->get_item( $item_id );
                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                        continue;
                                }

                                if ( method_exists( $item, 'read_meta_data' ) ) {
                                        $item->read_meta_data( true );
                                }

                                $allocs = $item->get_meta( $meta_key, true );
                                if ( ! is_array( $allocs ) || empty( $allocs ) ) {
                                        continue;
                                }

                                $order_status      = $order->get_status();
                                $order_status      = is_string( $order_status ) ? $order_status : '';
                                $normalized_status = preg_replace( '/^wc-/', '', sanitize_key( $order_status ) );
                                $is_completed      = in_array( $normalized_status, array( 'completed', 'fullfort' ), true );
                                $is_live           = in_array( $normalized_status, $allowed_statuses, true );

                                $qty_meta_key       = defined( __NAMESPACE__ . '\\ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT' ) ? ORDER_ITEM_META_ALLOC_QTY_SNAPSHOT : '_lpr_alloc_qty_snapshot';
                                $current_qty        = max( 0, (int) $item->get_quantity() );
                                $last_qty_raw       = (int) $item->get_meta( $qty_meta_key, true );
                                $has_qty_snapshot   = $item->meta_exists( $qty_meta_key );
                                $last_qty           = $last_qty_raw > 0 ? $last_qty_raw : ( $has_qty_snapshot ? $current_qty : 0 );
                                $quantity_changed   = $has_qty_snapshot ? ( $current_qty !== $last_qty ) : true;
                                $allocations_changed = false;
                                $released_qty        = 0;

                                if ( $is_completed ) {
                                        continue;
                                }

                                if ( ! $is_live ) {
                                        foreach ( $allocs as &$alloc_row ) {
                                                $status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                                $qty    = isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                                if ( 'released' === $status || $qty <= 0 ) {
                                                        continue;
                                                }
                                                lpr_allocator_touch_allocation_status( $alloc_row, 'released' );
                                                $released_qty += $qty;
                                                $allocations_changed = true;
                                        }
                                        unset( $alloc_row );
                                } else {
                                        $desired = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ? lpr_allocator_calc_backorder_desired( $item ) : $current_qty;
                                        $desired = max( 0, (int) $desired );
                                        $cap     = $desired > 0 ? min( $current_qty, $desired ) : $current_qty;

                                        $active_total = 0;
                                        foreach ( $allocs as $alloc_row ) {
                                                $status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                                if ( 'released' === $status ) {
                                                        continue;
                                                }
                                                $active_total += isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                        }

                                        $over = max( 0, $active_total - $cap );
                                        if ( $over > 0 && $quantity_changed ) {
                                                $rows_to_release = array();
                                                foreach ( $allocs as $idx => $alloc_row ) {
                                                        $status = isset( $alloc_row['status'] ) ? sanitize_key( (string) $alloc_row['status'] ) : 'reserved';
                                                        $qty    = isset( $alloc_row['qty_allocated'] ) ? max( 0, (int) $alloc_row['qty_allocated'] ) : 0;
                                                        if ( 'released' === $status || $qty <= 0 ) {
                                                                continue;
                                                        }
                                                        $rows_to_release[] = array(
                                                                'idx'          => (int) $idx,
                                                                'qty'          => $qty,
                                                                'allocated_at' => isset( $alloc_row['allocated_at'] ) ? (string) $alloc_row['allocated_at'] : '',
                                                                'eta'          => isset( $alloc_row['eta'] ) ? (string) $alloc_row['eta'] : '',
                                                        );
                                                }

                                                usort(
                                                        $rows_to_release,
                                                        static function ( $a, $b ) {
                                                                $a_time = isset( $a['allocated_at'] ) ? (string) $a['allocated_at'] : '';
                                                                $b_time = isset( $b['allocated_at'] ) ? (string) $b['allocated_at'] : '';
                                                                if ( $a_time !== $b_time ) {
                                                                        return lpr_allocator_compare_dates( $b_time, $a_time );
                                                                }
                                                                $a_eta = isset( $a['eta'] ) ? (string) $a['eta'] : '';
                                                                $b_eta = isset( $b['eta'] ) ? (string) $b['eta'] : '';
                                                                return lpr_allocator_compare_dates( $b_eta, $a_eta );
                                                        }
                                                );

                                                foreach ( $rows_to_release as $release_row ) {
                                                        if ( $over <= 0 ) {
                                                                break;
                                                        }
                                                        $idx = (int) $release_row['idx'];
                                                        if ( ! isset( $allocs[ $idx ] ) ) {
                                                                continue;
                                                        }

                                                        $current_qty = isset( $allocs[ $idx ]['qty_allocated'] ) ? max( 0, (int) $allocs[ $idx ]['qty_allocated'] ) : 0;
                                                        if ( $current_qty <= 0 ) {
                                                                continue;
                                                        }

                                                        $release_qty = min( $current_qty, $over );
                                                        if ( $release_qty >= $current_qty ) {
                                                                lpr_allocator_touch_allocation_status( $allocs[ $idx ], 'released' );
                                                                $released_qty += $release_qty;
                                                        } else {
                                                                $allocs[ $idx ]['qty_allocated'] = $current_qty - $release_qty;
                                                        }

                                                        $over    -= $release_qty;
                                                        $allocations_changed = true;
                                                }
                                        }
                                }

                                if ( ! $allocations_changed && ! $quantity_changed ) {
                                        continue;
                                }

                                $item->update_meta_data( $qty_meta_key, $current_qty );

                                if ( ! $allocations_changed ) {
                                        $item->save();
                                        continue;
                                }

                                if ( $released_qty > 0 ) {
                                        $reason = $is_live
                                                ? sprintf(
                                                        /* translators: 1: job label, 2: previous qty, 3: new qty, 4: active allocated qty */
                                                        __( '%1$s released allocation after quantity changed (%2$d â†’ %3$d) while %4$d units were still reserved.', 'lpr-backorder-allocator' ),
                                                        self::job_label(),
                                                        (int) $last_qty,
                                                        (int) $current_qty,
                                                        (int) $active_total
                                                )
                                                : sprintf(
                                                        /* translators: 1: job label, 2: status */
                                                        __( '%1$s released allocation because order status changed to %2$s.', 'lpr-backorder-allocator' ),
                                                        self::job_label(),
                                                        $normalized_status
                                                );

                                        lpr_allocator_add_release_note( $order, $item, (int) $released_qty, $reason );
                                }

                                $item->update_meta_data( $meta_key, array_values( $allocs ) );
                                $item->save();
                                $orders_to_refresh[ $order_id ] = true;

                        }

                        if ( empty( $orders_to_refresh ) ) {
                                return;
                        }

                        foreach ( array_keys( $orders_to_refresh ) as $oid ) {
                                if ( function_exists( __NAMESPACE__ . '\lpr_allocator_reapply_po_allocations_for_order' ) ) {
                                        lpr_allocator_reapply_po_allocations_for_order( (int) $oid );
                                }
                                if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
                                        ETA::update_line_eta( (int) $oid );
                                }
                        }
                }
                /**
                 * Get order item rows containing allocations via direct SQL for performance.
                 */
                protected static function get_order_item_allocations(): array {
                        global $wpdb;

                        if ( ! ( $wpdb instanceof \wpdb ) ) {
                                return array();
                        }

                        $meta_table  = $wpdb->prefix . 'woocommerce_order_itemmeta';
                        $items_table = $wpdb->prefix . 'woocommerce_order_items';

                        $sql = $wpdb->prepare(
                                "SELECT im.order_item_id, oi.order_id, im.meta_value\n"
                                . "FROM {$items_table} oi\n"
                                . "INNER JOIN {$meta_table} im ON oi.order_item_id = im.order_item_id\n"
                                . "WHERE im.meta_key = %s",
                                ORDER_ITEM_META_ALLOCATIONS
                        );

                        $results = $wpdb->get_results( $sql, ARRAY_A );

                        return is_array( $results ) ? $results : array();
                }
        }
}

if ( ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ) {
        class Incoming_Stock_Indexer {

                const ACTION_HOOK      = 'lpr_allocator_refresh_incoming_stock';
                const OPTION_LAST_IDS  = 'lpr_allocator_incoming_ids';

                public static function init(): void {
                        add_action( 'init', array( __CLASS__, 'maybe_schedule' ) );
                        add_action( self::ACTION_HOOK, array( __CLASS__, 'run' ) );
                        add_action( 'transition_post_status', array( __CLASS__, 'handle_po_status_change' ), 10, 3 );
                        add_action( 'before_delete_post', array( __CLASS__, 'handle_po_delete' ) );
                }

                /**
                 * Used after settings changes to rebuild the recurring schedule.
                 */
                public static function reset_schedule(): void {
                        if ( function_exists( 'as_unschedule_all_actions' ) ) {
                                as_unschedule_all_actions( self::ACTION_HOOK, array(), 'lpr-allocator' );
                        } else {
                                wp_clear_scheduled_hook( self::ACTION_HOOK );
                        }
                        self::maybe_schedule( true );
                }

                /**
                 * Determine interval (seconds) from settings.
                 */
                protected static function get_interval(): int {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
                        $interval = isset( $settings['frontend_refresh_interval'] ) ? (int) $settings['frontend_refresh_interval'] : 900;
                        $interval = max( 300, $interval );
                        return $interval;
                }

                /**
                 * Ensure a recurring task exists.
                 */
                public static function maybe_schedule( bool $force = false ): void {
                        $interval = self::get_interval();

                        if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_next_scheduled_action' ) ) {
                                if ( $force && function_exists( 'as_unschedule_all_actions' ) ) {
                                        as_unschedule_all_actions( self::ACTION_HOOK, array(), 'lpr-allocator' );
                                }
                                $next = as_next_scheduled_action( self::ACTION_HOOK, array(), 'lpr-allocator' );
                                if ( ! $next ) {
                                        as_schedule_recurring_action( time() + 60, $interval, self::ACTION_HOOK, array(), 'lpr-allocator', true );
                                }
                        } else {
                                if ( $force ) {
                                        wp_clear_scheduled_hook( self::ACTION_HOOK );
                                }
                                if ( ! wp_next_scheduled( self::ACTION_HOOK ) ) {
                                        wp_schedule_single_event( time() + $interval, self::ACTION_HOOK );
                                }
                        }
                }

                /**
                 * Action Scheduler / WP-Cron entrypoint.
                 */
                public static function run(): void {
                        self::refresh_all();

                        if ( class_exists( __NAMESPACE__ . '\PO_Allocation_Overage_Checker' ) ) {
                                PO_Allocation_Overage_Checker::run();
                        }

                        if ( class_exists( __NAMESPACE__ . '\PO_Allocation_Integrity_Checker' ) ) {
                                PO_Allocation_Integrity_Checker::run();
                        }

                        self::close_completed_pos();

                        // Fallback when AS is unavailable: keep chaining single events.
                        if ( ! function_exists( 'as_schedule_recurring_action' ) && ! wp_next_scheduled( self::ACTION_HOOK ) ) {
                                wp_schedule_single_event( time() + self::get_interval(), self::ACTION_HOOK );
                        }
                }

                /**
                 * Rebuild incoming availability snapshot and persist to product meta.
                 */
                protected static function refresh_all(): void {
                        $products       = array(); // product_id => [ [eta, qty_free, qty_ordered, po_id, po_number], ... ]
                        $incoming_totals = array();

                        $query = new \WP_Query(
                                array(
                                        'post_type'      => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                        'post_status'    => lpr_allocator_live_po_statuses(),
                                        'posts_per_page' => -1,
                                        'fields'         => 'ids',
                                        'no_found_rows'  => true,
                                )
                        );

                        foreach ( $query->posts as $po_id ) {
                                $po_eta    = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                                $po_number = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
                                $lines     = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                                if ( ! is_array( $lines ) || empty( $lines ) ) {
                                        continue;
                                }

                                foreach ( $lines as $line ) {
                                        $qty_ordered    = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                        $qty_allocated  = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
                                        $qty_received   = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
                                        $free           = max( 0, $qty_ordered - $qty_allocated - $qty_received );
                                        $incoming_total = max( 0, $qty_ordered - $qty_received );

                                        if ( $qty_ordered <= 0 || $qty_received >= $qty_ordered ) {
                                                continue;
                                        }

                                        $target_id = isset( $line['variation_id'] ) && (int) $line['variation_id'] > 0 ? (int) $line['variation_id'] : (int) ( $line['product_id'] ?? 0 );
                                        if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
                                                continue;
                                        }

                                        $eta = lpr_allocator_sanitize_ymd( isset( $line['eta_override'] ) ? (string) $line['eta_override'] : '' );
                                        if ( '' === $eta ) {
                                                $eta = $po_eta;
                                        }

                                        $products[ $target_id ][] = array(
                                                'eta'         => $eta,
                                                'qty_free'    => $free,
                                                'qty_ordered' => $qty_ordered,
                                                'po_id'       => (int) $po_id,
                                                'po_number'   => $po_number,
                                        );

                                        if ( ! isset( $incoming_totals[ $target_id ] ) ) {
                                                $incoming_totals[ $target_id ] = 0;
                                        }
                                        $incoming_totals[ $target_id ] += $incoming_total;
                                }
                        }

                        $new_ids = array();
                        foreach ( $products as $product_id => $entries ) {
                                usort(
                                        $entries,
                                        static function ( $a, $b ) {
                                                $ea = $a['eta'] ?? '';
                                                $eb = $b['eta'] ?? '';
                                                if ( $ea === $eb ) {
                                                        return ( $a['po_id'] ?? 0 ) <=> ( $b['po_id'] ?? 0 );
                                                }
                                                if ( '' === $ea ) {
                                                        return 1;
                                                }
                                                if ( '' === $eb ) {
                                                        return -1;
                                                }
                                                return lpr_allocator_compare_dates( $ea, $eb );
                                        }
                                );

                                $next_with_free = $entries[0];
                                foreach ( $entries as $entry ) {
                                        if ( ( $entry['qty_free'] ?? 0 ) > 0 ) {
                                                $next_with_free = $entry;
                                                break;
                                        }
                                }

                                update_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty', (int) ( $next_with_free['qty_free'] ?? 0 ) );
                                update_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta', (string) ( $next_with_free['eta'] ?? '' ) );
                                update_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS' ) ? PRODUCT_META_INCOMING_DETAILS : '_lpr_incoming_po_details', $entries );
                                update_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL' ) ? PRODUCT_META_INCOMING_TOTAL : '_lpr_incoming_po_total', (int) ( $incoming_totals[ $product_id ] ?? 0 ) );

                                if ( function_exists( 'wc_delete_product_transients' ) ) {
                                        wc_delete_product_transients( $product_id );
                                }

                                $new_ids[] = (int) $product_id;
                        }

                        $prev_ids = get_option( self::OPTION_LAST_IDS, array() );
                        if ( ! is_array( $prev_ids ) ) {
                                $prev_ids = array();
                        }

                        foreach ( $prev_ids as $old_id ) {
                                if ( ! in_array( (int) $old_id, $new_ids, true ) ) {
                                        delete_post_meta( (int) $old_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty' );
                                        delete_post_meta( (int) $old_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta' );
                                        delete_post_meta( (int) $old_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS' ) ? PRODUCT_META_INCOMING_DETAILS : '_lpr_incoming_po_details' );
                                        delete_post_meta( (int) $old_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL' ) ? PRODUCT_META_INCOMING_TOTAL : '_lpr_incoming_po_total' );

                                        if ( function_exists( 'wc_delete_product_transients' ) ) {
                                                wc_delete_product_transients( (int) $old_id );
                                        }
                                }
                        }

                        if ( null === get_option( self::OPTION_LAST_IDS, null ) ) {
                                add_option( self::OPTION_LAST_IDS, $new_ids, '', 'no' );
                        } else {
                                update_option( self::OPTION_LAST_IDS, $new_ids, false );
                        }
                }

                /**
                 * Close POs whose lines are fully received so they are no longer processed.
                 */
                protected static function close_completed_pos(): void {
                        if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_po_is_fully_received' ) ) {
                                return;
                        }

                        $statuses = lpr_allocator_live_po_statuses();

                        $query = new \WP_Query(
                                array(
                                        'post_type'      => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                        'post_status'    => $statuses,
                                        'posts_per_page' => -1,
                                        'fields'         => 'ids',
                                        'no_found_rows'  => true,
                                )
                        );

                        foreach ( $query->posts as $po_id ) {
                                lpr_allocator_maybe_close_po( (int) $po_id );
                        }
                }

                /**
                 * Read-only helpers for UI consumers.
                 */
                public static function get_product_snapshot( int $product_id ): array {
                        return array(
                                'qty'      => (int) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty', true ),
                                'eta'      => (string) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta', true ),
                                'details'  => self::get_product_details( $product_id ),
                        );
                }

                public static function get_product_details( int $product_id ): array {
                        $details = get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS' ) ? PRODUCT_META_INCOMING_DETAILS : '_lpr_incoming_po_details', true );
                        if ( ! is_array( $details ) ) {
                                return array();
                        }
                        $live_statuses = lpr_allocator_live_po_statuses();
                        $filtered      = array_values(
                                array_filter(
                                        $details,
                                        static function ( $row ) use ( $live_statuses ) {
                                                $po_id = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                                if ( $po_id <= 0 ) {
                                                        return false;
                                                }
                                                $status = get_post_status( $po_id );
                                                return (bool) ( $status && in_array( $status, $live_statuses, true ) );
                                        }
                                )
                        );

                        if ( $filtered !== $details ) {
                                update_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_DETAILS' ) ? PRODUCT_META_INCOMING_DETAILS : '_lpr_incoming_po_details', $filtered );
                                $details = $filtered;
                        }
                        usort(
                                $details,
                                static function ( $a, $b ) {
                                        $ea = $a['eta'] ?? '';
                                        $eb = $b['eta'] ?? '';
                                        if ( $ea === $eb ) {
                                                return ( $a['po_id'] ?? 0 ) <=> ( $b['po_id'] ?? 0 );
                                        }
                                        if ( '' === $ea ) {
                                                return 1;
                                        }
                                        if ( '' === $eb ) {
                                                return -1;
                                        }
                                        return lpr_allocator_compare_dates( $ea, $eb );
                                }
                        );
                        return $details;
                }

                /**
                 * Trigger an immediate refresh when a PO leaves a live status.
                 */
                public static function handle_po_status_change( string $new_status, string $old_status, \WP_Post $post ): void {
                        if ( ! $post instanceof \WP_Post ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }

                        $live = lpr_allocator_live_po_statuses();
                        if ( in_array( $new_status, $live, true ) && in_array( $old_status, $live, true ) ) {
                                return; // still live, no refresh required.
                        }

                        self::refresh_all();
                }

                /**
                 * Trigger refresh when a PO is deleted/trashed.
                 */
                public static function handle_po_delete( int $post_id ): void {
                        $post = get_post( $post_id );
                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }
                        self::refresh_all();
                }
        }
        Incoming_Stock_Indexer::init();
}

/**
 * Builds a cached "backordered products" index from orders (async-capable via Action Scheduler).
 */
if ( ! class_exists( __NAMESPACE__ . '\Backorder_Indexer' ) ) {
                class Backorder_Indexer {

                        const OPT_KEY = 'lpr_allocator_backorder_index';
                        const MAX_AGE = 600; // seconds
                        const ACTION_BUILD = 'lpr_allocator_build_index';

                        public static function init(): void {
                                add_action( 'init', array( __CLASS__, 'maybe_schedule' ) );
                                add_action( 'admin_init', array( __CLASS__, 'ensure_index_option' ) );
                                add_action( 'admin_post_lpr_build_backorder_index', array( __CLASS__, 'handle_build_index_request' ) );
                                // Async worker (Action Scheduler).
                                add_action( self::ACTION_BUILD, array( __CLASS__, 'build_and_store' ) );
                        }

                        public static function reset_schedule(): void {
                                if ( function_exists( 'as_unschedule_all_actions' ) ) {
                                        as_unschedule_all_actions( self::ACTION_BUILD, array(), 'lpr-allocator' );
                                } else {
                                        wp_clear_scheduled_hook( self::ACTION_BUILD );
                                }

                                self::maybe_schedule( true );
                        }

                        protected static function get_interval(): int {
                                $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : Settings::defaults();
                                $interval = isset( $settings['backorder_index_interval'] ) ? (int) $settings['backorder_index_interval'] : Settings::defaults()['backorder_index_interval'];

                                return max( 0, $interval );
                        }

                        public static function maybe_schedule( bool $force = false ): void {
                                $interval = self::get_interval();

                                if ( function_exists( 'as_schedule_recurring_action' ) && function_exists( 'as_next_scheduled_action' ) ) {
                                        if ( $force && function_exists( 'as_unschedule_all_actions' ) ) {
                                                as_unschedule_all_actions( self::ACTION_BUILD, array(), 'lpr-allocator' );
                                        }

                                        if ( $interval <= 0 ) {
                                                return;
                                        }

                                        $next = as_next_scheduled_action( self::ACTION_BUILD, array(), 'lpr-allocator' );
                                        if ( ! $next ) {
                                                as_schedule_recurring_action( time() + 60, $interval, self::ACTION_BUILD, array(), 'lpr-allocator', true );
                                        }

                                        return;
                                }

                                if ( $force ) {
                                        wp_clear_scheduled_hook( self::ACTION_BUILD );
                                }

                                if ( $interval <= 0 ) {
                                        return;
                                }

                                if ( ! wp_next_scheduled( self::ACTION_BUILD ) ) {
                                        wp_schedule_single_event( time() + $interval, self::ACTION_BUILD );
                                }
                        }

                        protected static function queue_async_build( bool $force = false ): bool {
                                if ( function_exists( 'as_next_scheduled_action' ) ) {
                                        $next = as_next_scheduled_action( self::ACTION_BUILD, array(), 'lpr-allocator' );
                                        if ( ! $force && $next && ( (int) $next - time() ) < 300 ) {
                                                return false;
                                        }
                                } elseif ( ! $force && function_exists( 'as_has_scheduled_action' ) && as_has_scheduled_action( self::ACTION_BUILD, array(), 'lpr-allocator' ) ) {
                                        return false;
                                }

                                if ( function_exists( 'as_enqueue_async_action' ) ) {
                                        as_enqueue_async_action( self::ACTION_BUILD, array(), 'lpr-allocator' );

                                        return true;
                                }

                                if ( function_exists( 'as_schedule_single_action' ) ) {
                                        as_schedule_single_action( time(), self::ACTION_BUILD, array(), 'lpr-allocator' );

                                        return true;
                                }

                                self::build_and_store( false );

                                return false;
                        }

                public static function ensure_index_option(): void {
                        if ( null === get_option( self::OPT_KEY, null ) ) {
                                add_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ), '', 'no' );
                                // Kick off an initial async build if AS available, else do a lightweight inline build (first page only).
                                self::queue_async_build( true );
                        }
                }

		public static function handle_build_index_request(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			$nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( ! wp_verify_nonce( $nonce, 'lpr_build_backorder_index' ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}
                        $redirect = isset( $_GET['redirect'] ) ? esc_url_raw( wp_unslash( $_GET['redirect'] ) ) : admin_url( 'admin.php?page=lpr-backordered-products' ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended

                        $queued = self::queue_async_build( true );

                        wp_safe_redirect( add_query_arg( array( 'lpr_index' => $queued ? 'queued' : 'rebuilt' ), $redirect ) );
                        exit;
                }

		/**
		 * Returns the index array: ['built_at'=>timestamp, 'rows'=>[ id => [desired_total, allocated_total, need_total, count] ] ]
		 *
		 * @param bool $allow_stale When false, will attempt to queue a rebuild if stale.
		 */
		public static function get_index( bool $allow_stale = true ): array {
                        $idx = get_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ) );
                        if ( ! is_array( $idx ) || ! isset( $idx['rows'] ) ) {
                                $idx = array( 'built_at' => 0, 'rows' => array() );
                        }
                        // If stale and allowed, queue a refresh (non-blocking).
                        if ( ! $allow_stale ) {
                                $stale = ( time() - (int) $idx['built_at'] ) > self::MAX_AGE;
                                if ( $stale ) {
                                        self::queue_async_build();
                                }
                        }
                        return $idx;
                }

		/**
		 * Build full snapshot and store in option.
		 *
		 * @param bool $paginate_early_break If true, performs a shallow build (useful for inline warmup without timeouts).
		 */
		public static function build_and_store( bool $paginate_early_break = false ): void {
			$snapshot = self::build_snapshot( $paginate_early_break );
			$existing = get_option( self::OPT_KEY, null );
			if ( null === $existing ) {
				add_option( self::OPT_KEY, $snapshot, '', 'no' );
			} else {
				update_option( self::OPT_KEY, $snapshot, false );
			}
		}

		/**
		 * Build the backorder snapshot by scanning orders in configured statuses.
		 *
		 * @return array
		 */
		protected static function build_snapshot( bool $paginate_early_break = false ): array {
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}

			$rows  = array(); // id => ['desired_total'=>int, 'allocated_total'=>int, 'need_total'=>int, 'items'=>int]
			$page  = 1;
			$limit = 50;
			$scanned_pages = 0;

			do {
				$args      = array(
					'status'  => $statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) {
					break;
				}

				foreach ( $order_ids as $oid ) {
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) {
						continue;
					}
					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
							continue;
						}
						// Treat variation as primary ID when present.
						$target_id = (int) $item->get_variation_id();
						if ( $target_id <= 0 ) {
							$target_id = (int) $item->get_product_id();
						}
						if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
							continue;
						}

						$desired   = lpr_allocator_calc_backorder_desired( $item );
						if ( $desired <= 0 ) {
							continue; // not a backordered line
						}
						$allocated = lpr_allocator_get_item_allocated_active( $item );

						if ( ! isset( $rows[ $target_id ] ) ) {
							$rows[ $target_id ] = array(
								'desired_total'  => 0,
								'allocated_total'=> 0,
								'need_total'     => 0,
								'items'          => 0,
							);
						}
						$rows[ $target_id ]['desired_total']   += (int) $desired;
						$rows[ $target_id ]['allocated_total'] += (int) $allocated;
						$rows[ $target_id ]['items']           += 1;
					}
				}

				$page++;
				$scanned_pages++;
				if ( $paginate_early_break && $scanned_pages >= 2 ) { // shallow build: scan just first ~100 orders
					break;
				}
			} while ( true );

			// Finalize needs and clamp.
			foreach ( $rows as $pid => &$agg ) {
				$agg['desired_total']   = max( 0, (int) $agg['desired_total'] );
				$agg['allocated_total'] = max( 0, (int) $agg['allocated_total'] );
				$agg['need_total']      = max( 0, (int) ( $agg['desired_total'] - $agg['allocated_total'] ) );
			}
			unset( $agg );

			return array(
				'built_at' => time(),
				'rows'     => $rows,
			);
		}
        }
        Backorder_Indexer::init();
}

/**
 * Cached index of backordered order lines (one row per line).
 */
if ( ! class_exists( __NAMESPACE__ . '\Backorder_Order_Indexer' ) ) {
        class Backorder_Order_Indexer {

                const OPT_KEY      = 'lpr_allocator_backorder_order_index';
                const MAX_AGE      = 600; // seconds
                const ACTION_BUILD = 'lpr_allocator_build_order_backorder_index';

                public static function init(): void {
                        add_action( 'admin_init', array( __CLASS__, 'ensure_index_option' ) );
                        add_action( 'admin_post_lpr_build_order_backorder_index', array( __CLASS__, 'handle_build_request' ) );

                        // Async worker.
                        add_action( self::ACTION_BUILD, array( __CLASS__, 'build_and_store' ) );

                        // Triggers: order lifecycle.
                        add_action( 'woocommerce_new_order', array( __CLASS__, 'queue_rebuild' ) );
                        add_action( 'woocommerce_order_status_changed', array( __CLASS__, 'queue_rebuild' ) );
                        add_action( 'woocommerce_after_order_object_save', array( __CLASS__, 'queue_rebuild' ) );
                        add_action( 'woocommerce_new_order_item', array( __CLASS__, 'queue_rebuild' ) );
                        add_action( 'woocommerce_update_order_item_meta', array( __CLASS__, 'queue_rebuild' ) );
                        add_action( 'woocommerce_before_delete_order_item', array( __CLASS__, 'queue_rebuild' ) );

                        // Triggers: allocation/meta changes (order item allocations + ETA updates).
                        add_action(
                                'updated_post_meta',
                                array( __CLASS__, 'maybe_handle_meta_change' ),
                                10,
                                4
                        );

                        // Triggers: PO ETA/status changes (affects allocation source + ETA text).
                        add_action( 'transition_post_status', array( __CLASS__, 'handle_po_status_change' ), 10, 3 );
                        add_action( 'before_delete_post', array( __CLASS__, 'handle_po_delete' ) );
                }

                public static function ensure_index_option(): void {
                        if ( null === get_option( self::OPT_KEY, null ) ) {
                                add_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ), '', 'no' );
                                self::queue_rebuild();
                        }
                }

                public static function handle_build_request(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
                        }
                        $nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        if ( ! wp_verify_nonce( $nonce, 'lpr_build_order_backorder_index' ) ) {
                                wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
                        }

                        $redirect = isset( $_GET['redirect'] ) ? esc_url_raw( wp_unslash( $_GET['redirect'] ) ) : admin_url( 'admin.php?page=lpr-backorder-orders' ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        self::queue_rebuild();

                        wp_safe_redirect( add_query_arg( array( 'lpr_order_index' => 'queued' ), $redirect ) );
                        exit;
                }

                public static function get_index( bool $allow_stale = true ): array {
                        $idx = get_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ) );
                        if ( ! is_array( $idx ) || ! isset( $idx['rows'] ) ) {
                                $idx = array( 'built_at' => 0, 'rows' => array() );
                        }
                        if ( ! $allow_stale ) {
                                $stale = ( time() - (int) $idx['built_at'] ) > self::MAX_AGE;
                                if ( $stale ) {
                                        self::queue_rebuild();
                                }
                        }
                        return $idx;
                }

                public static function queue_rebuild( ...$args ): void {
                        // Avoid flooding Action Scheduler with duplicate async jobs.
                        if (
                                function_exists( 'as_has_scheduled_action' )
                                && as_has_scheduled_action( self::ACTION_BUILD, array(), 'lpr-allocator' )
                        ) {
                                return;
                        }

                        if ( function_exists( 'as_enqueue_async_action' ) ) {
                                as_enqueue_async_action( self::ACTION_BUILD, array(), 'lpr-allocator' );
                        } elseif ( function_exists( 'as_schedule_single_action' ) ) {
                                as_schedule_single_action( time(), self::ACTION_BUILD, array(), 'lpr-allocator' );
                        } else {
                                self::build_and_store();
                        }
                }

                public static function maybe_handle_meta_change( $meta_id, $object_id, $meta_key, $meta_value ): void { // phpcs:ignore WordPress.NamingConventions.ValidFunctionName.FunctionNameInvalid
                        $watched = array(
                                defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations',
                                defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta',
                                defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date',
                        );

                        if ( in_array( $meta_key, $watched, true ) ) {
                                self::queue_rebuild();
                        }
                }

                public static function handle_po_status_change( string $new_status, string $old_status, \WP_Post $post ): void {
                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }
                        self::queue_rebuild();
                }

                public static function handle_po_delete( int $post_id ): void {
                        $post = get_post( $post_id );
                        if ( ! ( $post instanceof \WP_Post ) ) {
                                return;
                        }
                        if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
                                return;
                        }
                        self::queue_rebuild();
                }

                public static function build_and_store(): void {
                        $snapshot = self::build_snapshot();
                        $existing = get_option( self::OPT_KEY, null );
                        if ( null === $existing ) {
                                add_option( self::OPT_KEY, $snapshot, '', 'no' );
                        } else {
                                update_option( self::OPT_KEY, $snapshot, false );
                        }
                }

                protected static function build_snapshot(): array {
                        $settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
                        $statuses = array();
                        foreach ( (array) $settings['order_statuses'] as $st ) {
                                $statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
                        }

                        $rows  = array();
                        $page  = 1;
                        $limit = 50;

                        do {
                                $args      = array(
                                        'status'  => $statuses,
                                        'limit'   => $limit,
                                        'page'    => $page,
                                        'orderby' => 'date',
                                        'order'   => 'ASC',
                                        'return'  => 'ids',
                                        'type'    => 'shop_order',
                                );
                                $order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
                                if ( empty( $order_ids ) ) {
                                        break;
                                }

                                foreach ( $order_ids as $oid ) {
                                        $order = wc_get_order( $oid );
                                        if ( ! ( $order instanceof \WC_Order ) ) {
                                                continue;
                                        }

                                        $order_date = $order->get_date_created();
                                        $order_ts   = $order_date ? (int) $order_date->getTimestamp() : (int) $order->get_id();
                                        $status     = $order->get_status();
                                        $status_h   = function_exists( 'wc_get_order_status_name' ) ? wc_get_order_status_name( $status ) : $status;
                                        $number     = method_exists( $order, 'get_order_number' ) ? $order->get_order_number() : (string) $order->get_id();
                                        $customer   = trim( $order->get_formatted_billing_full_name() ?: '' );
                                        if ( '' === $customer ) {
                                                $customer = trim( $order->get_formatted_shipping_full_name() ?: '' );
                                        }
                                        if ( '' === $customer ) {
                                                $customer = (string) $order->get_billing_email();
                                        }
                                        $order_url = function_exists( 'get_edit_post_link' ) ? get_edit_post_link( $order->get_id(), '' ) : '';

                                        $eta_email_meta_key = defined( __NAMESPACE__ . '\\ORDER_META_LAST_ETA_EMAIL' ) ? ORDER_META_LAST_ETA_EMAIL : '_lpr_last_eta_email';
                                        $eta_email_sent     = (bool) $order->get_meta( $eta_email_meta_key );

                                        $order_rows           = array();
                                        $has_backorder_line   = false;
                                        $total_backordered    = 0;

                                        foreach ( $order->get_items( 'line_item' ) as $item ) {
                                                if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
                                                        continue;
                                                }

                                                $target_id = (int) $item->get_variation_id();
                                                if ( $target_id <= 0 ) {
                                                        $target_id = (int) $item->get_product_id();
                                                }
                                                if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
                                                        continue;
                                                }

                                                $desired = lpr_allocator_calc_backorder_desired( $item );

                                                $allocated          = lpr_allocator_get_item_allocated_active( $item );
                                                $backordered        = max( 0, $desired - $allocated );
                                                $qty_ordered        = max( 0, (int) $item->get_quantity() );
                                                $line_total         = (float) $item->get_total() + (float) $item->get_total_tax();
                                                $eta_meta_key       = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';
                                                $line_eta           = (string) $item->get_meta( $eta_meta_key, true );
                                                $alloc_source       = self::summarize_allocation_source( $item );
                                                $alloc_text         = isset( $alloc_source['text'] ) ? (string) $alloc_source['text'] : '';
                                                $alloc_url          = isset( $alloc_source['url'] ) ? (string) $alloc_source['url'] : '';
                                                $alloc_status       = ( $allocated >= $desired ) ? __( 'Fully allocated', 'lpr-backorder-allocator' ) : ( $allocated > 0 ? __( 'Partially allocated', 'lpr-backorder-allocator' ) : __( 'Not allocated', 'lpr-backorder-allocator' ) );
                                                $product_label      = $item->get_name();
                                                $is_backorder_line  = ( $desired > 0 );

                                                if ( $is_backorder_line ) {
                                                        $has_backorder_line = true;
                                                        $total_backordered += (int) $backordered;
                                                }

                                                $order_rows[] = array(
                                                        'order_id'                  => (int) $order->get_id(),
                                                        'order_number'              => (string) $number,
                                                        'order_url'                 => (string) $order_url,
                                                        'order_date_ts'             => $order_ts,
                                                        'order_date'                => $order_date ? $order_date->date_i18n( 'd-m-Y' ) : '',
                                                        'status'                    => (string) $status_h,
                                                        'customer'                  => $customer,
                                                        'customer_email'            => (string) $order->get_billing_email(),
                                                        'currency'                  => (string) $order->get_currency(),
                                                        'item_id'                   => (int) $item->get_id(),
                                                        'product_id'                => $target_id,
                                                        'product'                   => $product_label,
                                                        'qty_ordered'               => $qty_ordered,
                                                        'qty_allocated'             => (int) $allocated,
                                                        'qty_backordered'           => (int) $backordered,
                                                        'qty_backorder_desired'     => (int) $desired,
                                                        'is_backorder_line'         => $is_backorder_line,
                                                        'line_value'                => $line_total,
                                                        'eta'                       => $line_eta,
                                                        'allocation'                => $alloc_text,
                                                        'allocation_url'            => $alloc_url,
                                                        'allocation_label'          => $alloc_status,
                                                        'eta_email_sent'            => $eta_email_sent,
                                                        'order_backorder_outstand'  => 0, // populated when order is added.
                                                );
                                        }

                                        if ( $has_backorder_line && ! empty( $order_rows ) ) {
                                                foreach ( $order_rows as $row ) {
                                                        $row['order_backorder_outstand'] = $total_backordered;
                                                        $rows[]                          = $row;
                                                }
                                        }
                                }

                                $page++;
                        } while ( true );

                        usort(
                                $rows,
                                static function ( $a, $b ) {
                                        return ( $a['order_date_ts'] ?? 0 ) <=> ( $b['order_date_ts'] ?? 0 );
                                }
                        );

                        return array(
                                'built_at' => time(),
                                'rows'     => $rows,
                        );
                }

                protected static function summarize_allocation_source( \WC_Order_Item_Product $item ): array {
                        $key    = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
                        $allocs = $item->get_meta( $key, true );
                        if ( ! is_array( $allocs ) || empty( $allocs ) ) {
                                return array(
                                        'text' => __( 'Not allocated', 'lpr-backorder-allocator' ),
                                        'url'  => '',
                                );
                        }

                        $best     = '';
                        $best_url = '';
                        foreach ( $allocs as $row ) {
                                $status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
                                if ( 'released' === $status ) {
                                        continue;
                                }

                                $po_id  = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;
                                $eta    = '';
                                $source = '';
                                $url    = '';

                                if ( $po_id > 0 ) {
                                        $eta = class_exists( __NAMESPACE__ . '\ETA' ) ? ETA::live_eta_from_po( $po_id, $item ) : '';
                                        if ( '' === $eta && ! empty( $row['eta'] ) ) {
                                                $eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                        }
                                        $po_number = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
                                        if ( '' === $po_number && isset( $row['po_number'] ) ) {
                                                $po_number = (string) $row['po_number'];
                                        }
                                        $url     = get_edit_post_link( $po_id, 'url' );
                                        $source = $po_number ? sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_number ) : __( 'PO allocation', 'lpr-backorder-allocator' );
                                } elseif ( ! empty( $row['source'] ) ) {
                                        $source = (string) $row['source'];
                                } elseif ( isset( $row['eta'] ) && '' !== $row['eta'] ) {
                                        $eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                }

                                if ( '' === $source ) {
                                        $source = __( 'Reserved', 'lpr-backorder-allocator' );
                                }

                                if ( $eta ) {
                                        $eta_h = lpr_allocator_format_store_date( $eta );
                                        $text  = sprintf( __( '%1$s â€“ ETA %2$s', 'lpr-backorder-allocator' ), $source, $eta_h );
                                } else {
                                        $text = $source;
                                }

                                if ( '' === $best ) {
                                        $best     = $text;
                                        $best_url = $url;
                                }
                        }

                        return array(
                                'text' => $best ?: __( 'Not allocated', 'lpr-backorder-allocator' ),
                                'url'  => $best_url,
                        );
                }
        }
        Backorder_Order_Indexer::init();
}

/**
 * Admin page: index-backed overview of orders with backordered lines.
 */
if ( ! class_exists( __NAMESPACE__ . '\Backorder_Orders_Page' ) ) {
        class Backorder_Orders_Page {

                public static function init(): void {
                        add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
                }

                public static function register_page(): void {
                        add_submenu_page(
                                ADMIN_MENU_SLUG,
                                __( 'Backorder Orders', 'lpr-backorder-allocator' ),
                                __( 'Backorder Orders', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                'lpr-backorder-orders',
                                array( __CLASS__, 'render' ),
                                2
                        );
                }

                protected static function group_orders( array $rows ): array {
                        $orders = array();

                        foreach ( $rows as $row ) {
                                $oid = isset( $row['order_id'] ) ? (int) $row['order_id'] : 0;
                                if ( $oid <= 0 ) {
                                        continue;
                                }

                                if ( ! isset( $orders[ $oid ] ) ) {
                                                $orders[ $oid ] = array(
                                                        'order_id'               => $oid,
                                                        'order_number'           => isset( $row['order_number'] ) ? (string) $row['order_number'] : '',
                                                        'order_url'              => isset( $row['order_url'] ) ? (string) $row['order_url'] : '',
                                                        'order_date'             => isset( $row['order_date'] ) ? (string) $row['order_date'] : '',
                                                        'order_date_ts'          => isset( $row['order_date_ts'] ) ? (int) $row['order_date_ts'] : 0,
                                                        'status'                 => isset( $row['status'] ) ? (string) $row['status'] : '',
                                                        'customer'               => isset( $row['customer'] ) ? (string) $row['customer'] : '',
                                                        'currency'               => isset( $row['currency'] ) ? (string) $row['currency'] : '',
                                                        'customer_email'         => isset( $row['customer_email'] ) ? sanitize_email( (string) $row['customer_email'] ) : '',
                                                        'latest_eta'             => '',
                                                        'latest_eta_ts'          => 0,
                                                        'rows'                   => array(),
                                                        'outstanding_backorder'  => 0,
                                                        'has_backorder_line'     => false,
                                                );
                                        }

                                if ( '' === $orders[ $oid ]['customer_email'] && ! empty( $row['customer_email'] ) ) {
                                        $orders[ $oid ]['customer_email'] = sanitize_email( (string) $row['customer_email'] );
                                }

                                $orders[ $oid ]['rows'][] = $row;
                                $orders[ $oid ]['outstanding_backorder'] += isset( $row['qty_backordered'] ) ? (int) $row['qty_backordered'] : 0;
                                $orders[ $oid ]['has_backorder_line']    = $orders[ $oid ]['has_backorder_line'] || ! empty( $row['is_backorder_line'] );

                                if ( ! empty( $row['is_backorder_line'] ) && ! empty( $row['eta'] ) ) {
                                        $eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
                                        if ( $eta ) {
                                                $eta_obj = lpr_allocator_parse_date( $eta );
                                                $eta_ts  = $eta_obj ? $eta_obj->getTimestamp() : 0;

                                                if ( $eta_ts > 0 && ( $eta_ts > ( $orders[ $oid ]['latest_eta_ts'] ?? 0 ) ) ) {
                                                        $orders[ $oid ]['latest_eta']    = $eta;
                                                        $orders[ $oid ]['latest_eta_ts'] = $eta_ts;
                                                }
                                        }
                                }
                        }

                        uasort(
                                $orders,
                                static function ( $a, $b ) {
                                        return ( $a['order_date_ts'] ?? 0 ) <=> ( $b['order_date_ts'] ?? 0 );
                                }
                        );

                        return array_values( $orders );
                }

                protected static function filter_orders( array $orders, string $view ): array {
                        $out = array();

                        foreach ( $orders as $order ) {
                                $outstanding = isset( $order['outstanding_backorder'] ) ? (int) $order['outstanding_backorder'] : 0;

                                if ( empty( $order['has_backorder_line'] ) ) {
                                        continue;
                                }

                                if ( 'unallocated' === $view && $outstanding <= 0 ) {
                                        continue;
                                }

                                if ( 'allocated' === $view && $outstanding > 0 ) {
                                        continue;
                                }

                                $out[] = $order;
                        }

                        return $out;
                }

                protected static function format_money( float $amount, string $currency ): string {
                        if ( function_exists( 'wc_price' ) ) {
                                return wc_price( $amount, array( 'currency' => $currency ) );
                        }
                        return number_format_i18n( $amount, 2 ) . ' ' . esc_html( $currency );
                }

                protected static function email_link( array $order ): string {
                        $email = isset( $order['customer_email'] ) ? sanitize_email( (string) $order['customer_email'] ) : '';
                        if ( '' === $email ) {
                                return '<span class="button disabled">' . esc_html__( 'Email unavailable', 'lpr-backorder-allocator' ) . '</span>';
                        }

                        $order_eta_text = '';
                        if ( ! empty( $order['latest_eta'] ) ) {
                                $order_eta_text = lpr_allocator_format_store_date( (string) $order['latest_eta'] );
                        }
                        $order_eta_line = $order_eta_text ? sprintf( __( 'Latest ETA: %s', 'lpr-backorder-allocator' ), $order_eta_text ) : __( 'Latest ETA: not set', 'lpr-backorder-allocator' );

                        $line_summaries = array();
                        if ( ! empty( $order['rows'] ) && is_array( $order['rows'] ) ) {
                                foreach ( $order['rows'] as $row ) {
                                        if ( empty( $row['is_backorder_line'] ) ) {
                                                continue;
                                        }

                                        $line_eta = ! empty( $row['eta'] ) ? lpr_allocator_format_store_date( (string) $row['eta'] ) : __( 'not set', 'lpr-backorder-allocator' );

                                        $line_summaries[] = sprintf(
                                                /* translators: 1: order line id, 2: product name, 3: ordered qty, 4: allocated qty, 5: backordered qty, 6: ETA */
                                                __( 'Line %1$d â€“ %2$s â€“ Ordered: %3$d â€“ Allocated: %4$d â€“ Backordered: %5$d â€“ ETA: %6$s', 'lpr-backorder-allocator' ),
                                                isset( $row['item_id'] ) ? (int) $row['item_id'] : 0,
                                                isset( $row['product'] ) ? (string) $row['product'] : '',
                                                isset( $row['qty_ordered'] ) ? (int) $row['qty_ordered'] : 0,
                                                isset( $row['qty_allocated'] ) ? (int) $row['qty_allocated'] : 0,
                                                isset( $row['qty_backordered'] ) ? (int) $row['qty_backordered'] : 0,
                                                $line_eta
                                        );
                                }
                        }

                        if ( empty( $line_summaries ) ) {
                                $line_summaries[] = __( 'No backordered line items are currently listed for this order.', 'lpr-backorder-allocator' );
                        }

                        $body_lines = array_merge(
                                array(
                                        sprintf( __( 'Hello, here is the latest ETA for your order #%s:', 'lpr-backorder-allocator' ), (string) $order['order_number'] ),
                                        '',
                                        $order_eta_line,
                                        '',
                                        __( 'Line details:', 'lpr-backorder-allocator' ),
                                ),
                                $line_summaries
                        );

                        $mailto = sprintf(
                                'mailto:%1$s?subject=%2$s&body=%3$s',
                                rawurlencode( $email ),
                                rawurlencode( sprintf( __( 'Updated ETAs for order #%s', 'lpr-backorder-allocator' ), (string) $order['order_number'] ) ),
                                rawurlencode( implode( "\r\n", $body_lines ) )
                        );

                        return '<a class="button" href="' . esc_url( $mailto ) . '">' . esc_html__( 'Email customer', 'lpr-backorder-allocator' ) . '</a>';
                }

                public static function render(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        $view = isset( $_GET['view'] ) ? sanitize_key( wp_unslash( $_GET['view'] ) ) : 'all'; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        if ( ! in_array( $view, array( 'unallocated', 'all', 'allocated' ), true ) ) {
                                $view = 'all';
                        }

                        $idx         = class_exists( __NAMESPACE__ . '\Backorder_Order_Indexer' ) ? Backorder_Order_Indexer::get_index( false ) : array( 'built_at' => 0, 'rows' => array() );
                        $built_ts    = isset( $idx['built_at'] ) ? (int) $idx['built_at'] : 0;
                        $rows_all    = isset( $idx['rows'] ) && is_array( $idx['rows'] ) ? $idx['rows'] : array();
                        $orders_all  = self::group_orders( $rows_all );
                        $orders_view = self::filter_orders( $orders_all, $view );

                        $page     = isset( $_GET['paged'] ) ? max( 1, (int) $_GET['paged'] ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $per_page = 25;
                        $total    = count( $orders_view );
                        $pages    = max( 1, (int) ceil( $total / $per_page ) );
                        $offset   = ( $page - 1 ) * $per_page;
                        $subset   = array_slice( $orders_view, $offset, $per_page );

                        $rebuild_url = wp_nonce_url(
                                add_query_arg(
                                        array(
                                                'action'   => 'lpr_build_order_backorder_index',
                                                'redirect' => rawurlencode( admin_url( 'admin.php?page=lpr-backorder-orders&view=' . $view . '&paged=' . $page ) ),
                                        ),
                                        admin_url( 'admin-post.php' )
                                ),
                                'lpr_build_order_backorder_index'
                        );

                        if ( isset( $_GET['lpr_order_index'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                                $state = sanitize_key( wp_unslash( $_GET['lpr_order_index'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                                if ( 'queued' === $state ) {
                                        echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Order backorder index rebuild queued.', 'lpr-backorder-allocator' ) . '</p></div>';
                                }
                        }

                        ?>
                        <div class="wrap">
                                <h1><?php echo esc_html__( 'Orders with Backordered Lines', 'lpr-backorder-allocator' ); ?></h1>

                                <form method="get" style="margin:16px 0;">
                                        <input type="hidden" name="page" value="lpr-backorder-orders" />
                                        <label for="lpr-order-view"><strong><?php echo esc_html__( 'View', 'lpr-backorder-allocator' ); ?>:</strong></label>
                                        <select name="view" id="lpr-order-view">
                                                <option value="all" <?php selected( $view, 'all' ); ?>><?php echo esc_html__( 'All backorder orders', 'lpr-backorder-allocator' ); ?></option>
                                                <option value="unallocated" <?php selected( $view, 'unallocated' ); ?>><?php echo esc_html__( 'Not fully allocated', 'lpr-backorder-allocator' ); ?></option>
                                                <option value="allocated" <?php selected( $view, 'allocated' ); ?>><?php echo esc_html__( 'Fully allocated', 'lpr-backorder-allocator' ); ?></option>
                                        </select>
                                        <noscript><button class="button"><?php esc_html_e( 'Apply', 'lpr-backorder-allocator' ); ?></button></noscript>
                                </form>

                                <style>
                                        .lpr-backorder-row {
                                                border-left: 4px solid #d63638;
                                                background: #fff4f3;
                                        }
                                        .lpr-badge {
                                                display: inline-block;
                                                padding: 2px 8px;
                                                border-radius: 4px;
                                                font-weight: 600;
                                                font-size: 12px;
                                                line-height: 1.4;
                                        }
                                        .lpr-badge-success {
                                                background: #e7f5ec;
                                                color: #0f6f2f;
                                                border: 1px solid #0f6f2f;
                                        }
                                        .lpr-badge-warning {
                                                background: #fff6e5;
                                                color: #a15c00;
                                                border: 1px solid #a15c00;
                                        }

                                        .lpr-order-card {
                                                background: #fff;
                                                border: 1px solid #dcdcde;
                                                box-shadow: 0 1px 1px rgba(0, 0, 0, 0.04);
                                                margin-bottom: 20px;
                                                border-radius: 4px;
                                                overflow: hidden;
                                        }

                                        .lpr-order-card__header {
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: flex-start;
                                                padding: 12px 16px;
                                                border-bottom: 1px solid #dcdcde;
                                                background: #f6f7f7;
                                        }

                                        .lpr-order-card__left {
                                                flex: 1;
                                                min-width: 0;
                                        }

                                        .lpr-order-card__title-row {
                                                display: flex;
                                                align-items: center;
                                                gap: 12px;
                                                flex-wrap: wrap;
                                                justify-content: space-between;
                                        }

                                        .lpr-order-card__title {
                                                display: flex;
                                                align-items: center;
                                                gap: 10px;
                                                flex-wrap: wrap;
                                        }

                                        .lpr-order-card__eta {
                                                color: #50575e;
                                                font-size: 13px;
                                        }

                                        .lpr-order-card__actions .button {
                                                margin: 0;
                                        }

                                        .lpr-order-card__meta {
                                                margin-top: 4px;
                                                color: #50575e;
                                        }

                                        .lpr-order-card__status {
                                                margin-left: 12px;
                                        }

                                        .lpr-order-card__body {
                                                padding: 0 12px 12px 12px;
                                        }

                                        .lpr-order-card table.widefat {
                                                margin: 0;
                                        }
                                </style>

                                <p>
                                        <a class="button" href="<?php echo esc_url( $rebuild_url ); ?>"><?php echo esc_html__( 'Rebuild Index', 'lpr-backorder-allocator' ); ?></a>
                                        <span class="description" style="margin-left:8px;">
                                                <?php
                                                printf(
                                                        /* translators: %s: timestamp */
                                                        esc_html__( 'Last built: %s', 'lpr-backorder-allocator' ),
                                                        $built_ts ? esc_html( wp_date( 'd-m-Y H:i:s', $built_ts ) ) : esc_html__( 'never', 'lpr-backorder-allocator' )
                                                );
                                                ?>
                                        </span>
                                </p>

                                <?php if ( empty( $subset ) ) : ?>
                                        <div class="notice notice-info inline"><p><?php echo esc_html__( 'No orders found for this view.', 'lpr-backorder-allocator' ); ?></p></div>
                                <?php else : ?>
                                        <?php foreach ( $subset as $order ) : ?>
                                                <?php
                                                $order_link   = ! empty( $order['order_url'] ) ? '<a href="' . esc_url( $order['order_url'] ) . '">#' . esc_html( $order['order_number'] ) . '</a>' : '#' . esc_html( $order['order_number'] );
                                                $outstanding  = isset( $order['outstanding_backorder'] ) ? (int) $order['outstanding_backorder'] : 0;
                                                $order_badge  = $outstanding > 0 ? 'lpr-badge lpr-badge-warning' : 'lpr-badge lpr-badge-success';
                                                $order_label  = $outstanding > 0 ? sprintf( __( 'Backordered qty outstanding: %d', 'lpr-backorder-allocator' ), $outstanding ) : __( 'Fully allocated', 'lpr-backorder-allocator' );
                                                $order_eta    = ! empty( $order['latest_eta'] ) ? lpr_allocator_format_store_date( (string) $order['latest_eta'] ) : '';
                                                $order_eta_h  = $order_eta ? sprintf( __( 'ETA: %s', 'lpr-backorder-allocator' ), $order_eta ) : __( 'ETA: not set', 'lpr-backorder-allocator' );
                                                $email_link   = self::email_link( $order );
                                                ?>
                                                <div class="lpr-order-card">
                                                        <div class="lpr-order-card__header">
                                                                <div class="lpr-order-card__left">
                                                                        <div class="lpr-order-card__title-row">
                                                                                <div class="lpr-order-card__title">
                                                                                        <h2 style="margin:0; font-size:16px;"><?php echo wp_kses_post( $order_link ); ?></h2>
                                                                                        <span class="lpr-order-card__eta"><?php echo esc_html( $order_eta_h ); ?></span>
                                                                                </div>
                                                                                <div class="lpr-order-card__actions">
                                                                                        <?php echo wp_kses_post( $email_link ); ?>
                                                                                </div>
                                                                        </div>
                                                                        <div class="lpr-order-card__meta">
                                                                                <?php echo esc_html( $order['order_date'] ); ?> &bull; <?php echo esc_html( $order['status'] ); ?>
                                                                                <?php if ( ! empty( $order['customer'] ) ) : ?>
                                                                                        &bull; <?php echo esc_html( $order['customer'] ); ?>
                                                                                <?php endif; ?>
                                                                        </div>
                                                                </div>
                                                                <div class="lpr-order-card__status">
                                                                        <span class="<?php echo esc_attr( $order_badge ); ?>"><?php echo esc_html( $order_label ); ?></span>
                                                                </div>
                                                        </div>
                                                        <div class="lpr-order-card__body">
                                                                <table class="widefat fixed striped">
                                                                        <thead>
                                                                                <tr>
                                                                                        <th><?php echo esc_html__( 'Line ID', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th><?php echo esc_html__( 'Product', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php echo esc_html__( 'Ordered', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php echo esc_html__( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php echo esc_html__( 'Backordered', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php echo esc_html__( 'Line Value', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th><?php echo esc_html__( 'Line ETA', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th><?php echo esc_html__( 'Allocation Source', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th><?php echo esc_html__( 'Allocation Status', 'lpr-backorder-allocator' ); ?></th>
                                                                                </tr>
                                                                        </thead>
                                                                        <tbody>
                                                                                <?php foreach ( $order['rows'] as $row ) : ?>
                                                                                        <?php
                                                                                        $eta                 = ! empty( $row['eta'] ) ? lpr_allocator_format_store_date( (string) $row['eta'] ) : '';
                                                                                        $backordered         = isset( $row['qty_backordered'] ) ? (int) $row['qty_backordered'] : 0;
                                                                                        $backordered_display = $backordered > 0 ? '<strong>' . esc_html( (string) $backordered ) . '</strong>' : esc_html( (string) $backordered );
                                                                                        $has_allocation      = isset( $row['qty_allocated'] ) ? ( (int) $row['qty_allocated'] > 0 ) : false;
                                                                                        $row_class           = $backordered > 0 ? ' class="lpr-backorder-row"' : '';
                                                                                        $badge               = '';

                                                                                        if ( $backordered > 0 ) {
                                                                                                $badge_class = $has_allocation ? 'lpr-badge lpr-badge-success' : 'lpr-badge lpr-badge-warning';
                                                                                                $badge_label = $has_allocation ? __( 'Allocated', 'lpr-backorder-allocator' ) : __( 'Not allocated', 'lpr-backorder-allocator' );
                                                                                                $badge       = '<span class="' . esc_attr( $badge_class ) . '">' . esc_html( $badge_label ) . '</span>';
                                                                                        }
                                                                                        ?>
                                                                                        <tr<?php echo $row_class; // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped ?>>
                                                                                                <td><?php echo esc_html( (string) $row['item_id'] ); ?></td>
                                                                                                <td><?php echo esc_html( $row['product'] ); ?></td>
                                                                                                <td class="num"><?php echo esc_html( (string) $row['qty_ordered'] ); ?></td>
                                                                                                <td class="num"><?php echo esc_html( (string) $row['qty_allocated'] ); ?></td>
                                                                                                <td class="num">
                                                                                                        <?php echo wp_kses_post( $backordered_display ); ?>
                                                                                                        <?php if ( $badge ) : ?>
                                                                                                                <div style="margin-top:4px;"> <?php echo wp_kses_post( $badge ); ?> </div>
                                                                                                        <?php endif; ?>
                                                                                                </td>
                                                                                                <td class="num"><?php echo wp_kses_post( self::format_money( (float) $row['line_value'], (string) $row['currency'] ) ); ?></td>
                                                                                                <td><?php echo $eta ? esc_html( $eta ) : '&#8211;'; ?></td>
                                                                                                <td>
                                                                                                        <?php if ( ! empty( $row['allocation_url'] ) ) : ?>
                                                                                                                <a href="<?php echo esc_url( (string) $row['allocation_url'] ); ?>"><?php echo esc_html( (string) $row['allocation'] ); ?></a>
                                                                                                        <?php else : ?>
                                                                                                                <?php echo esc_html( (string) $row['allocation'] ); ?>
                                                                                                        <?php endif; ?>
                                                                                                </td>
                                                                                                <td><?php echo esc_html( (string) $row['allocation_label'] ); ?></td>
                                                                                        </tr>
                                                                                <?php endforeach; ?>
                                                                        </tbody>
                                                                </table>
                                                        </div>
                                                </div>
                                        <?php endforeach; ?>
                                <?php endif; ?>

                                <?php if ( $pages > 1 ) : ?>
                                        <div class="tablenav-pages">
                                                <span class="displaying-num"><?php echo esc_html( sprintf( _n( '%s order', '%s orders', $total, 'lpr-backorder-allocator' ), number_format_i18n( $total ) ) ); ?></span>
                                                <span class="pagination-links">
                                                        <?php
                                                        $base_url = admin_url( 'admin.php?page=lpr-backorder-orders&view=' . $view . '&paged=%#%' );
                                                        echo wp_kses_post(
                                                                paginate_links(
                                                                        array(
                                                                                'base'      => $base_url,
                                                                                'format'    => '',
                                                                                'current'   => $page,
                                                                                'total'     => $pages,
                                                                                'prev_text' => __( '&laquo;', 'lpr-backorder-allocator' ),
                                                                                'next_text' => __( '&raquo;', 'lpr-backorder-allocator' ),
                                                                        )
                                                                )
                                                        );
                                                        ?>
                                                </span>
                                        </div>
                                <?php endif; ?>
                        </div>
                        <?php
                }
        }
        Backorder_Orders_Page::init();
}

/**
 * Admin page: incoming supplier POs grouped by ETA (line-level when provided).
 */
if ( ! class_exists( __NAMESPACE__ . '\Incoming_Purchase_Orders_Page' ) ) {
        class Incoming_Purchase_Orders_Page {

                public static function init(): void {
                        add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
                }

                public static function register_page(): void {
                        add_submenu_page(
                                ADMIN_MENU_SLUG,
                                __( 'Incoming POs', 'lpr-backorder-allocator' ),
                                __( 'Incoming POs', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                'lpr-incoming-pos',
                                array( __CLASS__, 'render' ),
                                3
                        );
                }

                public static function collect_rows(): array {
                        $entries      = array();
                        $live_status  = lpr_allocator_live_po_statuses();
                        $po_post_type = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';

                        $query = new \WP_Query(
                                array(
                                        'post_type'      => $po_post_type,
                                        'post_status'    => $live_status,
                                        'posts_per_page' => -1,
                                        'fields'         => 'ids',
                                        'no_found_rows'  => true,
                                )
                        );

                        foreach ( $query->posts as $po_id ) {
                                $po_id   = (int) $po_id;
                                $lines   = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                                $po_eta  = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                                $number  = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
                                $supplier = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', true );
                                $status  = get_post_status( $po_id );
                                $status_obj = $status ? get_post_status_object( $status ) : null;
                                $status_label = $status_obj && isset( $status_obj->label ) ? (string) $status_obj->label : (string) $status;
                                $po_link = get_edit_post_link( $po_id, 'url' );

                                if ( ! is_array( $lines ) || empty( $lines ) ) {
                                        continue;
                                }

                                foreach ( $lines as $line ) {
                                        $qty_ordered   = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                        $qty_allocated = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
                                        $qty_received  = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;

                                        if ( $qty_ordered <= 0 || $qty_received >= $qty_ordered ) {
                                                continue;
                                        }

                                        $target_id = isset( $line['variation_id'] ) && (int) $line['variation_id'] > 0 ? (int) $line['variation_id'] : (int) ( $line['product_id'] ?? 0 );
                                        if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
                                                continue;
                                        }

                                        $eta = lpr_allocator_sanitize_ymd( isset( $line['eta_override'] ) ? (string) $line['eta_override'] : '' );
                                        if ( '' === $eta ) {
                                                $eta = $po_eta;
                                        }

                                        $key = $po_id . '|' . ( $eta ? $eta : 'no-eta' );
                                        if ( ! isset( $entries[ $key ] ) ) {
                                                $entries[ $key ] = array(
                                                        'po_id'        => $po_id,
                                                        'po_number'    => $number ?: (string) $po_id,
                                                        'po_url'       => $po_link,
                                                        'supplier'     => $supplier,
                                                        'eta'          => $eta,
                                                        'status'       => $status_label,
                                                        'status_slug'  => $status,
                                                        'lines'        => array(),
                                                        'totals'       => array(
                                                                'ordered'   => 0,
                                                                'allocated' => 0,
                                                                'received'  => 0,
                                                                'free'      => 0,
                                                        ),
                                                );
                                        }

                                        $free = max( 0, $qty_ordered - $qty_allocated - $qty_received );

                                        $entries[ $key ]['lines'][] = array(
                                                'product_id'    => $target_id,
                                                'product_label' => lpr_allocator_product_option_label( $target_id ),
                                                'ordered'       => $qty_ordered,
                                                'allocated'     => $qty_allocated,
                                                'received'      => $qty_received,
                                                'free'          => $free,
                                        );

                                        $entries[ $key ]['totals']['ordered']   += $qty_ordered;
                                        $entries[ $key ]['totals']['allocated'] += $qty_allocated;
                                        $entries[ $key ]['totals']['received']  += $qty_received;
                                        $entries[ $key ]['totals']['free']      += $free;
                                }
                        }

                        // Normalize into a list and sort by ETA earliest -> latest, then PO ID.
                        $rows = array_values(
                                array_filter(
                                        $entries,
                                        static function ( $row ) {
                                                return ! empty( $row['lines'] );
                                        }
                                )
                        );
                        usort(
                                $rows,
                                static function ( $a, $b ) {
                                        $ea = $a['eta'] ?? '';
                                        $eb = $b['eta'] ?? '';
                                        if ( $ea === $eb ) {
                                                return ( $a['po_id'] ?? 0 ) <=> ( $b['po_id'] ?? 0 );
                                        }
                                        if ( '' === $ea ) {
                                                return 1;
                                        }
                                        if ( '' === $eb ) {
                                                return -1;
                                        }
                                        return lpr_allocator_compare_dates( (string) $ea, (string) $eb );
                                }
                        );

                        return $rows;
                }

                public static function render(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

                        $rows = self::collect_rows();
                        ?>
                        <div class="wrap">
                                <h1><?php echo esc_html__( 'Incoming Purchase Orders', 'lpr-backorder-allocator' ); ?></h1>
                                <p class="description"><?php echo esc_html__( 'Open supplier POs grouped by ETA. Line-level ETAs split a PO into multiple arrivals when needed.', 'lpr-backorder-allocator' ); ?></p>

                                <?php if ( empty( $rows ) ) : ?>
                                        <div class="notice notice-info"><p><?php echo esc_html__( 'No incoming purchase orders in open or partial status.', 'lpr-backorder-allocator' ); ?></p></div>
                                <?php else : ?>
                                        <style>
                                                .lpr-incoming-list { display:flex; flex-direction:column; gap:16px; }
                                                .lpr-incoming-card { background:#fff; border:1px solid #e0e4e7; box-shadow:0 4px 14px rgba(0,0,0,0.03); border-radius:8px; overflow:hidden; width:100%; }
                                                .lpr-incoming-card__header { display:flex; justify-content:space-between; align-items:flex-start; padding:14px 18px; background:linear-gradient(180deg, #f8fafc 0%, #f4f6f8 100%); border-bottom:1px solid #e6eaee; gap:12px; }
                                                .lpr-incoming-card__title { font-size:15px; font-weight:600; margin:0 0 4px; }
                                                .lpr-incoming-card__meta { color:#4c5561; font-size:12px; margin:0; display:flex; flex-wrap:wrap; gap:10px; }
                                                .lpr-incoming-card__eta { display:flex; flex-direction:column; align-items:flex-end; gap:4px; text-align:right; }
                                                .lpr-incoming-card__eta-days { color:#1d2327; font-size:12px; display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#eef2f7; }
                                                .lpr-incoming-card__stats { display:flex; flex-wrap:wrap; gap:12px; padding:12px 16px; border-bottom:1px solid #edf0f3; background:#fff; }
                                                .lpr-incoming-card__stats span { display:inline-flex; align-items:center; gap:6px; font-size:12px; color:#1d2327; }
                                                .lpr-incoming-card table { width:100%; border-collapse:separate; border-spacing:0; }
                                                .lpr-incoming-card th { padding:10px 12px; text-align:left; font-size:12px; text-transform:uppercase; letter-spacing:.02em; color:#4c5561; background:#f7f9fb; border-bottom:1px solid #e8edf2; }
                                                .lpr-incoming-card td { padding:10px 12px; text-align:left; font-size:13px; border:0; }
                                                .lpr-incoming-card tbody tr:nth-child(odd) td { background:#fbfcff; }
                                                .lpr-incoming-card tbody tr:nth-child(even) td { background:#ffffff; }
                                                .lpr-incoming-card tbody tr:hover td { background:#eef3ff; }
                                                .lpr-incoming-card tbody tr td { border-top:1px solid #eef0f3; }
                                                .lpr-incoming-card th.num, .lpr-incoming-card td.num { text-align:right; white-space:nowrap; }
                                                .lpr-badge { display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:600; border:1px solid #1e73be; color:#1e73be; background:#ecf5ff; }
                                                .lpr-incoming-card__actions { margin-top:10px; display:flex; justify-content:flex-start; gap:8px; }
                                        </style>

                                        <div class="lpr-incoming-list">
                                                <?php foreach ( $rows as $row ) :
                                                        $eta_label = $row['eta'] ? lpr_allocator_format_store_date( (string) $row['eta'] ) : __( 'No ETA set', 'lpr-backorder-allocator' );
                                                        $po_label  = ! empty( $row['po_number'] ) ? (string) $row['po_number'] : '#' . ( $row['po_id'] ?? '' );
                                                        $po_url    = ! empty( $row['po_url'] ) ? (string) $row['po_url'] : '';
                                                        $line_total = isset( $row['lines'] ) && is_array( $row['lines'] ) ? count( $row['lines'] ) : 0;
                                                        $totals    = isset( $row['totals'] ) && is_array( $row['totals'] ) ? $row['totals'] : array();
                                                        $ordered   = (int) ( $totals['ordered'] ?? 0 );
                                                        $allocated = (int) ( $totals['allocated'] ?? 0 );
                                                        $received  = (int) ( $totals['received'] ?? 0 );
                                                        $free      = (int) ( $totals['free'] ?? max( 0, $ordered - $allocated - $received ) );
                                                        $eta_days  = '';

                                                        if ( $row['eta'] ) {
                                                                $eta_date = lpr_allocator_parse_date( (string) $row['eta'] );
                                                                if ( $eta_date ) {
                                                                        $tz          = function_exists( 'wp_timezone' ) ? wp_timezone() : new \DateTimeZone( 'UTC' );
                                                                        $today_start = new \DateTimeImmutable( 'today', $tz );
                                                                        $diff_days   = (int) $today_start->diff( $eta_date )->format( '%r%a' );

                                                                        if ( $diff_days >= 0 ) {
                                                                                $eta_days = sprintf( _n( '%s day until ETA', '%s days until ETA', $diff_days, 'lpr-backorder-allocator' ), number_format_i18n( $diff_days ) );
                                                                        } else {
                                                                                $eta_days = sprintf( _n( '%s day past ETA', '%s days past ETA', abs( $diff_days ), 'lpr-backorder-allocator' ), number_format_i18n( abs( $diff_days ) ) );
                                                                        }
                                                                }
                                                        }
                                                        ?>
                                                        <div class="lpr-incoming-card">
                                                                <div class="lpr-incoming-card__header">
                                                                        <div>
                                                                                <p class="lpr-incoming-card__title">
                                                                                        <?php if ( $po_url ) : ?>
                                                                                                <a href="<?php echo esc_url( $po_url ); ?>"><?php echo esc_html( sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_label ) ); ?></a>
                                                                                        <?php else : ?>
                                                                                                <?php echo esc_html( sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_label ) ); ?>
                                                                                        <?php endif; ?>
                                                                                </p>
                                                                                <p class="lpr-incoming-card__meta">
                                                                                        <?php if ( ! empty( $row['supplier'] ) ) : ?>
                                                                                                <span><?php echo esc_html( sprintf( __( 'Supplier: %s', 'lpr-backorder-allocator' ), (string) $row['supplier'] ) ); ?></span>
                                                                                        <?php endif; ?>
                                                                                        <?php if ( ! empty( $row['status'] ) ) : ?>
                                                                                                <span><?php echo esc_html( sprintf( __( 'Status: %s', 'lpr-backorder-allocator' ), (string) $row['status'] ) ); ?></span>
                                                                                        <?php endif; ?>
                                                                                        <span><?php echo esc_html( sprintf( _n( '%s line', '%s lines', $line_total, 'lpr-backorder-allocator' ), number_format_i18n( $line_total ) ) ); ?></span>
                                                                                </p>
                                                                                <?php if ( class_exists( __NAMESPACE__ . '\PO_Receive_Stock_UI' ) && ! empty( $row['po_id'] ) ) :
                                                                                        $nonce = wp_create_nonce( 'lpr_receive_po_' . $row['po_id'] );
                                                                                        ?>
                                                                                        <p class="lpr-incoming-card__actions">
                                                                                                <button type="button" class="button lpr-open-receive" data-po="<?php echo esc_attr( (string) $row['po_id'] ); ?>" data-nonce="<?php echo esc_attr( $nonce ); ?>"><?php esc_html_e( 'Receive', 'lpr-backorder-allocator' ); ?></button>
                                                                                        </p>
                                                                                <?php endif; ?>
                                                                        </div>
                                                                        <div class="lpr-incoming-card__eta">
                                                                                <span class="lpr-badge"><?php echo esc_html( sprintf( __( 'ETA %s', 'lpr-backorder-allocator' ), $eta_label ) ); ?></span>
                                                                                <?php if ( '' !== $eta_days ) : ?>
                                                                                        <span class="lpr-incoming-card__eta-days"><?php echo esc_html( $eta_days ); ?></span>
                                                                                <?php endif; ?>
                                                                        </div>
                                                                </div>

                                                                <div class="lpr-incoming-card__stats">
                                                                        <span><strong><?php esc_html_e( 'Ordered', 'lpr-backorder-allocator' ); ?>:</strong> <?php echo esc_html( number_format_i18n( $ordered ) ); ?></span>
                                                                        <span><strong><?php esc_html_e( 'Allocated to orders', 'lpr-backorder-allocator' ); ?>:</strong> <?php echo esc_html( number_format_i18n( $allocated ) ); ?></span>
                                                                        <span><strong><?php esc_html_e( 'Received', 'lpr-backorder-allocator' ); ?>:</strong> <?php echo esc_html( number_format_i18n( $received ) ); ?></span>
                                                                        <span><strong><?php esc_html_e( 'Free to allocate', 'lpr-backorder-allocator' ); ?>:</strong> <?php echo esc_html( number_format_i18n( $free ) ); ?></span>
                                                                </div>

                                                                <table class="widefat fixed striped">
                                                                        <thead>
                                                                                <tr>
                                                                                        <th><?php esc_html_e( 'Product incoming', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php esc_html_e( 'Incoming qty', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php esc_html_e( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php esc_html_e( 'Received', 'lpr-backorder-allocator' ); ?></th>
                                                                                        <th class="num"><?php esc_html_e( 'Free', 'lpr-backorder-allocator' ); ?></th>
                                                                                </tr>
                                                                        </thead>
                                                                        <tbody>
                                                                                <?php foreach ( (array) ( $row['lines'] ?? array() ) as $line ) :
                                                                                        $product_id = (int) ( $line['product_id'] ?? 0 );
                                                                                        $product_url = $product_id > 0 ? get_edit_post_link( $product_id, 'url' ) : '';
                                                                                        ?>
                                                                                        <tr>
                                                                                                <td>
                                                                                                        <?php if ( $product_url ) : ?>
                                                                                                                <a href="<?php echo esc_url( $product_url ); ?>"><?php echo esc_html( (string) ( $line['product_label'] ?? '' ) ); ?></a>
                                                                                                        <?php else : ?>
                                                                                                                <?php echo esc_html( (string) ( $line['product_label'] ?? '' ) ); ?>
                                                                                                        <?php endif; ?>
                                                                                                </td>
                                                                                                <td class="num"><?php echo esc_html( number_format_i18n( (int) ( $line['ordered'] ?? 0 ) ) ); ?></td>
                                                                                                <td class="num"><?php echo esc_html( number_format_i18n( (int) ( $line['allocated'] ?? 0 ) ) ); ?></td>
                                                                                                <td class="num"><?php echo esc_html( number_format_i18n( (int) ( $line['received'] ?? 0 ) ) ); ?></td>
                                                                                                <td class="num"><?php echo esc_html( number_format_i18n( (int) ( $line['free'] ?? 0 ) ) ); ?></td>
                                                                                        </tr>
                                                                                <?php endforeach; ?>
                                                                        </tbody>
                                                                </table>
                                                        </div>
                                                <?php endforeach; ?>
                                        </div>
                                <?php endif; ?>
                        </div>
                        <?php
                }
        }
        Incoming_Purchase_Orders_Page::init();
}

/**
 * Admin product UI: show incoming PO availability beneath Quantity.
 */
if ( ! class_exists( __NAMESPACE__ . '\Incoming_Stock_Product_UI' ) ) {
        class Incoming_Stock_Product_UI {

                public static function init(): void {
                        add_action( 'woocommerce_product_options_stock_fields', array( __CLASS__, 'render_simple_product' ) );
                        add_action( 'woocommerce_variation_options_inventory', array( __CLASS__, 'render_variation_product' ), 20, 3 );
                }

                public static function render_simple_product(): void {
                        global $product_object;
                        $product_id = 0;
                        if ( $product_object instanceof \WC_Product ) {
                                $product_id = (int) $product_object->get_id();
                        } elseif ( isset( $GLOBALS['post'] ) && $GLOBALS['post'] instanceof \WP_Post ) {
                                $product_id = (int) $GLOBALS['post']->ID;
                        }
                        self::render_block( $product_id, false );
                }

                public static function render_variation_product( $loop, array $variation_data, $variation ): void { // phpcs:ignore Universal.NamingConventions.NoReservedKeywordParameterNames
                        $product_id = 0;
                        if ( $variation instanceof \WC_Product ) {
                                $product_id = (int) $variation->get_id();
                        }
                        self::render_block( $product_id, true );
                }

                protected static function render_block( int $product_id, bool $is_variation ): void {
                        if ( $product_id <= 0 ) {
                                return;
                        }

                        $snapshot = class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ? Incoming_Stock_Indexer::get_product_snapshot( $product_id ) : array( 'qty' => 0, 'eta' => '', 'details' => array() );
                        $label    = __( 'Incoming PO availability', 'lpr-backorder-allocator' );

                        $field_classes = $is_variation ? 'form-row form-row-full lpr-incoming-po' : 'form-field lpr-incoming-po';

                        echo '<p class="' . esc_attr( $field_classes ) . '">';
                        echo '<label>' . esc_html( $label ) . '</label>';

                        if ( ! empty( $snapshot['details'] ) ) {
                                $eta_text = $snapshot['eta'] ? $snapshot['eta'] : __( 'No ETA set', 'lpr-backorder-allocator' );
                                echo '<span>' . esc_html( sprintf( __( '%1$d free units arriving (next ETA %2$s).', 'lpr-backorder-allocator' ), (int) $snapshot['qty'], $eta_text ) ) . '</span>';

                                echo '<ul style="margin-top:6px;">';
                                foreach ( (array) $snapshot['details'] as $entry ) {
                                        $po_label = ! empty( $entry['po_number'] ) ? (string) $entry['po_number'] : ( '#' . ( $entry['po_id'] ?? '' ) );
                                        $line_eta = ! empty( $entry['eta'] ) ? (string) $entry['eta'] : __( 'No ETA', 'lpr-backorder-allocator' );
                                        $ordered  = isset( $entry['qty_ordered'] ) ? (int) $entry['qty_ordered'] : 0;
                                        $free     = isset( $entry['qty_free'] ) ? (int) $entry['qty_free'] : 0;
                                        $text     = sprintf(
                                                /* translators: 1: PO number, 2: ETA, 3: ordered qty, 4: free qty */
                                                __( 'PO %1$s â€“ ETA %2$s â€“ Ordered %3$d, Free %4$d', 'lpr-backorder-allocator' ),
                                                $po_label,
                                                $line_eta,
                                                $ordered,
                                                $free
                                        );
                                        echo '<li style="margin-left:1em;list-style:disc;">' . esc_html( $text ) . '</li>';
                                }
                                echo '</ul>';
                        } else {
                                echo '<span>' . esc_html__( 'No open purchase orders with free quantity.', 'lpr-backorder-allocator' ) . '</span>';
                        }

                        echo '</p>';
                }
        }
        Incoming_Stock_Product_UI::init();
}

/**
 * Admin page: bulk spreadsheet-style editor for open supplier POs.
 */
if ( ! class_exists( __NAMESPACE__ . '\PO_Bulk_Editor_Page' ) ) {
    class PO_Bulk_Editor_Page {

        public static function init(): void {
            add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
            add_action( 'admin_enqueue_scripts', array( __CLASS__, 'enqueue_assets' ) );
        }

        public static function register_page(): void {
            add_submenu_page(
                ADMIN_MENU_SLUG,
                __( 'Bulk Edit POs', 'lpr-backorder-allocator' ),
                __( 'Bulk Edit POs', 'lpr-backorder-allocator' ),
                'manage_woocommerce',
                'lpr-po-bulk-edit',
                array( __CLASS__, 'render' ),
                4
            );
        }

        /**
         * Load WooCommerce enhanced select assets on the bulk editor page so product search works.
         */
        public static function enqueue_assets( $hook ): void {
            $page = isset( $_GET['page'] ) ? sanitize_key( wp_unslash( $_GET['page'] ) ) : '';
            if ( 'lpr-po-bulk-edit' !== $page ) {
                return;
            }

            wp_enqueue_style( 'woocommerce_admin_styles' );
            wp_enqueue_script( 'wc-enhanced-select' );
        }

        protected static function allowed_statuses(): array {
            return array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED );
        }

        protected static function sanitize_header( array $data, string $current_status = '' ): array {
            $supplier  = isset( $data['supplier'] ) ? sanitize_text_field( wp_unslash( $data['supplier'] ) ) : '';
            $po_number = isset( $data['po_number'] ) ? sanitize_text_field( wp_unslash( $data['po_number'] ) ) : '';
            $eta       = isset( $data['eta'] ) ? lpr_allocator_sanitize_ymd( wp_unslash( $data['eta'] ) ) : '';
            $status    = isset( $data['status'] ) ? sanitize_key( wp_unslash( $data['status'] ) ) : ( $current_status ?: PO_STATUS_OPEN );
            if ( ! in_array( $status, self::allowed_statuses(), true ) ) {
                $status = $current_status ?: PO_STATUS_OPEN;
            }
            $title = isset( $data['title'] ) ? sanitize_text_field( wp_unslash( $data['title'] ) ) : '';

            return array(
                'supplier'  => $supplier,
                'po_number' => $po_number,
                'eta'       => $eta,
                'status'    => $status,
                'title'     => $title,
            );
        }

        /**
         * Normalize posted select fields back into product/variation IDs.
         */
        protected static function normalize_select_rows( array $rows ): array {
            if ( empty( $rows ) || ! function_exists( 'wc_get_product' ) ) {
                return $rows;
            }

            foreach ( $rows as &$row ) {
                if ( ! is_array( $row ) ) {
                    continue;
                }
                $sel_id = isset( $row['select_id'] ) ? absint( $row['select_id'] ) : 0;
                $pid    = isset( $row['product_id'] ) ? absint( $row['product_id'] ) : 0;
                $vid    = isset( $row['variation_id'] ) ? absint( $row['variation_id'] ) : 0;

                if ( $sel_id && 0 === $pid && 0 === $vid ) {
                    $product = wc_get_product( $sel_id );
                    if ( $product instanceof \WC_Product ) {
                        if ( $product->is_type( 'variation' ) ) {
                            $row['variation_id'] = (string) $sel_id;
                            $row['product_id']   = '';
                        } else {
                            $row['product_id']   = (string) $sel_id;
                            $row['variation_id'] = '';
                        }
                    }
                }
            }
            unset( $row );

            return $rows;
        }

        /**
         * Normalize PO lines meta so the bulk editor can render any stored format.
         *
         * @param mixed $raw Raw meta value from get_post_meta.
         * @return array
         */
        protected static function normalize_po_lines_meta( $raw ): array {
            if ( is_array( $raw ) ) {
                return $raw;
            }

            if ( is_string( $raw ) ) {
                $decoded = json_decode( $raw, true );
                if ( is_array( $decoded ) ) {
                    return $decoded;
                }
            }

            if ( is_object( $raw ) && isset( $raw->lines ) && is_array( $raw->lines ) ) {
                return $raw->lines;
            }

            return array();
        }

        protected static function has_new_payload( array $data ): bool {
            if ( ! empty( $data['title'] ) || ! empty( $data['supplier'] ) || ! empty( $data['po_number'] ) || ! empty( $data['eta'] ) ) {
                return true;
            }
            if ( ! empty( $data['lines'] ) && is_array( $data['lines'] ) ) {
                foreach ( $data['lines'] as $row ) {
                    if ( array_filter( (array) $row ) ) {
                        return true;
                    }
                }
            }
            return false;
        }

        protected static function collect_open_pos(): array {
            $po_type = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
            $query   = new \WP_Query(
                array(
                    'post_type'      => $po_type,
                    'post_status'    => lpr_allocator_live_po_statuses(),
                    'posts_per_page' => -1,
                    'orderby'        => 'date',
                    'order'          => 'DESC',
                    'no_found_rows'  => true,
                )
            );

            $rows = array();
            foreach ( $query->posts as $post_obj ) {
                if ( ! ( $post_obj instanceof \WP_Post ) ) {
                    continue;
                }

                $po_id = (int) $post_obj->ID;
                $post  = $post_obj;

                $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                $lines = self::normalize_po_lines_meta( $lines );

                foreach ( $lines as &$line ) {
                    $target = isset( $line['variation_id'] ) && (int) $line['variation_id'] > 0 ? (int) $line['variation_id'] : (int) ( $line['product_id'] ?? 0 );
                    if ( $target > 0 ) {
                        $line['product_label'] = lpr_allocator_product_option_label( $target );
                    }
                }
                unset( $line );

                $status_obj = get_post_status_object( $post->post_status );
                $rows[]     = array(
                    'id'             => (int) $po_id,
                    'post'           => $post,
                    'supplier'       => (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', true ),
                    'po_number'      => (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true ),
                    'eta'            => lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) ),
                    'lines'          => $lines,
                    'edit_url'       => get_edit_post_link( $po_id, 'url' ),
                    'edit_date'      => get_the_date( 'd-m-Y', $po_id ),
                    'edit_time'      => get_the_time( 'H:i', $po_id ),
                    'current_status' => (string) $post->post_status,
                    'current_label'  => $status_obj && isset( $status_obj->label ) ? (string) $status_obj->label : (string) $post->post_status,
                );
            }

            return $rows;
        }

        protected static function handle_save(): array {
            $messages = array();
            $errors   = array();

            if ( 'POST' !== strtoupper( $_SERVER['REQUEST_METHOD'] ?? '' ) ) {
                return array( $messages, $errors );
            }

            if ( ! isset( $_POST['lpr_po_bulk_nonce'] ) || ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_bulk_nonce'] ) ), 'lpr_po_bulk_edit' ) ) {
                $errors[] = __( 'Security check failed. Please try again.', 'lpr-backorder-allocator' );
                return array( $messages, $errors );
            }

            if ( ! current_user_can( 'manage_woocommerce' ) ) {
                $errors[] = __( 'You do not have permission to edit purchase orders.', 'lpr-backorder-allocator' );
                return array( $messages, $errors );
            }

            $po_type = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
            $updated = 0;
            $created = 0;

            if ( ! empty( $_POST['pos'] ) && is_array( $_POST['pos'] ) ) {
                foreach ( $_POST['pos'] as $po_id => $payload ) {
                    $po_id = (int) $po_id;
                    $post  = get_post( $po_id );
                    if ( ! ( $post instanceof \WP_Post ) || $post->post_type !== $po_type ) {
                        continue;
                    }

                    $header = self::sanitize_header( (array) $payload, $post->post_status );
                    update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', $header['supplier'] );
                    update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', $header['po_number'] );
                    update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', $header['eta'] );

                    $update_args = array( 'ID' => $po_id );
                    $needs_post  = false;
                    if ( '' !== $header['title'] && $header['title'] !== $post->post_title ) {
                        $update_args['post_title'] = $header['title'];
                        $needs_post                = true;
                    }
                    if ( $header['status'] !== $post->post_status ) {
                        $update_args['post_status'] = $header['status'];
                        $needs_post                  = true;
                    }
                    if ( $needs_post ) {
                        wp_update_post( $update_args );
                    }

                    $lines_raw = isset( $payload['lines'] ) ? (array) $payload['lines'] : array();
                    $lines_raw = self::normalize_select_rows( $lines_raw );
                    $lines     = lpr_allocator_sanitize_po_lines_input( $lines_raw );
                    $lines     = lpr_allocator_recalculate_po_lines_from_allocations( $po_id, $lines );
                    update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );
                    $updated++;
                }
            }

            $new_payload = isset( $_POST['new_po'] ) ? (array) $_POST['new_po'] : array();
            if ( self::has_new_payload( $new_payload ) ) {
                $header = self::sanitize_header( $new_payload, PO_STATUS_OPEN );
                $title  = $header['title'];
                if ( '' === $title ) {
                    $title = sprintf( __( 'PO Draft %s', 'lpr-backorder-allocator' ), wp_date( 'd-m-Y H:i' ) );
                }

                $post_id = wp_insert_post(
                    array(
                        'post_type'   => $po_type,
                        'post_status' => $header['status'],
                        'post_title'  => $title,
                    ),
                    true
                );

                if ( is_wp_error( $post_id ) ) {
                    $errors[] = $post_id->get_error_message();
                } else {
                    $lines = isset( $new_payload['lines'] ) ? (array) $new_payload['lines'] : array();
                    $lines = self::normalize_select_rows( $lines );
                    $lines = lpr_allocator_sanitize_po_lines_input( $lines );
                    $lines = lpr_allocator_recalculate_po_lines_from_allocations( (int) $post_id, $lines );

                    update_post_meta( $post_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', $header['supplier'] );
                    update_post_meta( $post_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', $header['po_number'] );
                    update_post_meta( $post_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', $header['eta'] );
                    update_post_meta( $post_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );

                    $created++;
                }
            }

            if ( $updated > 0 ) {
                $messages[] = sprintf( _n( 'Updated %d purchase order.', 'Updated %d purchase orders.', $updated, 'lpr-backorder-allocator' ), $updated );
            }
            if ( $created > 0 ) {
                $messages[] = sprintf( _n( 'Created %d purchase order.', 'Created %d purchase orders.', $created, 'lpr-backorder-allocator' ), $created );
            }

            return array( $messages, $errors );
        }

        public static function render(): void {
            if ( ! current_user_can( 'manage_woocommerce' ) ) {
                return;
            }

            list( $messages, $errors ) = self::handle_save();
            $rows     = self::collect_open_pos();
            $statuses = self::allowed_statuses();
            ?>
            <div class="wrap lpr-po-bulk-wrap">
                <h1><?php esc_html_e( 'Bulk Edit Purchase Orders', 'lpr-backorder-allocator' ); ?></h1>
                <?php if ( ! empty( $messages ) ) : ?>
                    <div class="notice notice-success">
                        <?php foreach ( $messages as $msg ) : ?>
                            <p><?php echo esc_html( $msg ); ?></p>
                        <?php endforeach; ?>
                    </div>
                <?php endif; ?>
                <?php if ( ! empty( $errors ) ) : ?>
                    <div class="notice notice-error">
                        <?php foreach ( $errors as $err ) : ?>
                            <p><?php echo esc_html( $err ); ?></p>
                        <?php endforeach; ?>
                    </div>
                <?php endif; ?>
                <form method="post">
                    <?php wp_nonce_field( 'lpr_po_bulk_edit', 'lpr_po_bulk_nonce' ); ?>
                    <p class="description"><?php esc_html_e( 'Review every open/partial PO in one screen, edit lines inline, and save all changes at once.', 'lpr-backorder-allocator' ); ?></p>
                    <p><button class="button button-primary"><?php esc_html_e( 'Save all PO changes', 'lpr-backorder-allocator' ); ?></button></p>
                    <div class="lpr-po-bulk-grid">
                        <?php if ( empty( $rows ) ) : ?>
                            <div class="lpr-po-bulk-card">
                                <p><?php esc_html_e( 'No open purchase orders to edit.', 'lpr-backorder-allocator' ); ?></p>
                            </div>
                        <?php else : ?>
                            <?php foreach ( $rows as $row ) : ?>
                                <?php $po_key = (int) $row['id']; ?>
                                <div class="lpr-po-bulk-card">
                                    <div class="lpr-po-bulk-card__header">
                                        <div>
                                            <?php
                                            $po_title = $row['post'] instanceof \WP_Post ? (string) $row['post']->post_title : '';
                                            if ( '' === $po_title ) {
                                                $po_title = sprintf( __( 'PO #%1$s', 'lpr-backorder-allocator' ), $row['po_number'] ? $row['po_number'] : $po_key );
                                            }
                                            ?>
                                            <strong><?php echo esc_html( $po_title ); ?></strong>
                                            <span class="lpr-po-bulk-chip"><?php echo esc_html( sprintf( __( 'Status: %s', 'lpr-backorder-allocator' ), $row['current_label'] ) ); ?></span>
                                        </div>
                                        <div class="lpr-po-bulk-card__meta">
                                            <?php if ( ! empty( $row['edit_url'] ) ) : ?>
                                                <a class="button" href="<?php echo esc_url( $row['edit_url'] ); ?>"><?php esc_html_e( 'Open editor', 'lpr-backorder-allocator' ); ?></a>
                                            <?php endif; ?>
                                            <span><?php echo esc_html( sprintf( __( 'Last edited %1$s at %2$s', 'lpr-backorder-allocator' ), (string) $row['edit_date'], (string) $row['edit_time'] ) ); ?></span>
                                        </div>
                                    </div>

                                    <div class="lpr-po-bulk-fields">
                                        <label>
                                            <span><?php esc_html_e( 'Title', 'lpr-backorder-allocator' ); ?></span>
                                            <input type="text" name="pos[<?php echo esc_attr( $po_key ); ?>][title]" value="<?php echo esc_attr( $row['post']->post_title ); ?>" />
                                        </label>
                                        <label>
                                            <span><?php esc_html_e( 'Supplier', 'lpr-backorder-allocator' ); ?></span>
                                            <input type="text" name="pos[<?php echo esc_attr( $po_key ); ?>][supplier]" value="<?php echo esc_attr( $row['supplier'] ); ?>" />
                                        </label>
                                        <label>
                                            <span><?php esc_html_e( 'PO Number', 'lpr-backorder-allocator' ); ?></span>
                                            <input type="text" name="pos[<?php echo esc_attr( $po_key ); ?>][po_number]" value="<?php echo esc_attr( $row['po_number'] ); ?>" />
                                        </label>
                                        <label>
                                            <span><?php esc_html_e( 'Default ETA (dd-mm-yyyy)', 'lpr-backorder-allocator' ); ?></span>
                                            <input type="text" name="pos[<?php echo esc_attr( $po_key ); ?>][eta]" value="<?php echo esc_attr( $row['eta'] ); ?>" pattern="\d{2}-\d{2}-\d{4}" placeholder="DD-MM-YYYY" />
                                        </label>
                                        <label>
                                            <span><?php esc_html_e( 'Status', 'lpr-backorder-allocator' ); ?></span>
                                            <select name="pos[<?php echo esc_attr( $po_key ); ?>][status]">
                                                <?php foreach ( $statuses as $status_key ) : ?>
                                                    <?php
                                                    $status_obj   = get_post_status_object( $status_key );
                                                    $status_label = $status_obj && isset( $status_obj->label ) ? (string) $status_obj->label : $status_key;
                                                    ?>
                                                    <option value="<?php echo esc_attr( $status_key ); ?>" <?php selected( $status_key, $row['current_status'] ); ?>><?php echo esc_html( $status_label ); ?></option>
                                                <?php endforeach; ?>
                                            </select>
                                        </label>
                                    </div>

                                    <div class="lpr-po-bulk-table-wrapper">
                                        <table class="widefat fixed striped">
                                            <thead>
                                                <tr>
                                                    <th><?php esc_html_e( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
                                                    <th><?php esc_html_e( 'Ordered', 'lpr-backorder-allocator' ); ?></th>
                                                    <th><?php esc_html_e( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                    <th><?php esc_html_e( 'Received', 'lpr-backorder-allocator' ); ?></th>
                                                    <th><?php esc_html_e( 'ETA Override', 'lpr-backorder-allocator' ); ?></th>
                                                    <th></th>
                                                </tr>
                                            </thead>
                                            <tbody id="lpr-po-lines-<?php echo esc_attr( $po_key ); ?>" data-next-index="<?php echo esc_attr( (string) count( (array) $row['lines'] ) ); ?>">
                                                <?php foreach ( (array) $row['lines'] as $line_index => $line ) : ?>
                                                <?php
                                                $line_product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
                                                $line_variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
                                                $line_chosen_id    = $line_variation_id > 0 ? $line_variation_id : $line_product_id;
                                                $line_label        = '';
                                                if ( $line_chosen_id ) {
                                                        $line_label = ! empty( $line['product_label'] ) ? (string) $line['product_label'] : lpr_allocator_product_option_label( $line_chosen_id );
                                                }
                                                $base_name = sprintf( 'pos[%1$d][lines][%2$d]', $po_key, (int) $line_index );
                                                ?>
                                                <tr>
                                                        <td class="lpr-product-cell">
                                                                <select
                                                                        class="wc-product-search lpr-product-select"
                                                                        name="<?php echo esc_attr( $base_name ); ?>[select_ui]"
                                                                        data-placeholder="<?php echo esc_attr__( 'Search for a productâ€¦', 'lpr-backorder-allocator' ); ?>"
                                                                        data-action="woocommerce_json_search_products_and_variations"
                                                                        data-minimum_input_length="1"
                                                                        data-allow_clear="true"
                                                                        style="width: 100%;"
                                                                >
                                                                <?php if ( $line_chosen_id ) : ?>
                                                                        <option value="<?php echo esc_attr( (string) $line_chosen_id ); ?>" selected="selected"><?php echo esc_html( $line_label ); ?></option>
                                                                <?php endif; ?>
                                                        </select>
                                                        <input type="hidden" class="lpr-select-id" name="<?php echo esc_attr( $base_name ); ?>[select_id]" value="<?php echo esc_attr( (string) $line_chosen_id ); ?>" />
                                                        <input type="hidden" class="lpr-product-id" name="<?php echo esc_attr( $base_name ); ?>[product_id]" value="<?php echo esc_attr( (string) $line_product_id ); ?>" />
                                                        <input type="hidden" class="lpr-variation-id" name="<?php echo esc_attr( $base_name ); ?>[variation_id]" value="<?php echo esc_attr( (string) $line_variation_id ); ?>" />
                                                        </td>
                                                        <td><input type="number" min="0" step="1" name="<?php echo esc_attr( $base_name ); ?>[qty_ordered]" value="<?php echo esc_attr( (string) ( $line['qty_ordered'] ?? 0 ) ); ?>" /></td>
                                                        <td><input type="number" min="0" step="1" name="<?php echo esc_attr( $base_name ); ?>[qty_allocated]" value="<?php echo esc_attr( (string) ( $line['qty_allocated'] ?? 0 ) ); ?>" /></td>
                                                        <td><input type="number" min="0" step="1" name="<?php echo esc_attr( $base_name ); ?>[qty_received]" value="<?php echo esc_attr( (string) ( $line['qty_received'] ?? 0 ) ); ?>" /></td>
                                                        <td><input type="text" name="<?php echo esc_attr( $base_name ); ?>[eta_override]" value="<?php echo esc_attr( (string) ( $line['eta_override'] ?? '' ) ); ?>" placeholder="DD-MM-YYYY" pattern="\d{2}-\d{2}-\d{4}" /></td>
                                                        <td><button type="button" class="button-link-delete lpr-po-bulk-remove-line">&times;</button></td>
                                                    </tr>
                                                <?php endforeach; ?>
                                            </tbody>
                                        </table>
                                        <p><button type="button" class="button lpr-po-bulk-add-line" data-target="lpr-po-lines-<?php echo esc_attr( $po_key ); ?>" data-key="<?php echo esc_attr( $po_key ); ?>" data-new="0"><?php esc_html_e( 'Add PO line', 'lpr-backorder-allocator' ); ?></button></p>
                                    </div>
                                </div>
                            <?php endforeach; ?>
                        <?php endif; ?>
                    </div>

                    <div class="lpr-po-bulk-card lpr-po-bulk-card--new">
                        <h2><?php esc_html_e( 'Create a new PO', 'lpr-backorder-allocator' ); ?></h2>
                        <p class="description"><?php esc_html_e( 'Enter header fields and at least one line to start a fresh PO directly from the grid.', 'lpr-backorder-allocator' ); ?></p>

                        <div class="lpr-po-bulk-fields">
                            <label>
                                <span><?php esc_html_e( 'Title', 'lpr-backorder-allocator' ); ?></span>
                                <input type="text" name="new_po[title]" />
                            </label>
                            <label>
                                <span><?php esc_html_e( 'Supplier', 'lpr-backorder-allocator' ); ?></span>
                                <input type="text" name="new_po[supplier]" />
                            </label>
                            <label>
                                <span><?php esc_html_e( 'PO Number', 'lpr-backorder-allocator' ); ?></span>
                                <input type="text" name="new_po[po_number]" />
                            </label>
                            <label>
                                <span><?php esc_html_e( 'Default ETA (dd-mm-yyyy)', 'lpr-backorder-allocator' ); ?></span>
                                <input type="text" name="new_po[eta]" pattern="\d{2}-\d{2}-\d{4}" placeholder="DD-MM-YYYY" />
                            </label>
                            <label>
                                <span><?php esc_html_e( 'Status', 'lpr-backorder-allocator' ); ?></span>
                                <select name="new_po[status]">
                                    <?php foreach ( $statuses as $status_key ) : ?>
                                        <?php
                                        $status_obj   = get_post_status_object( $status_key );
                                        $status_label = $status_obj && isset( $status_obj->label ) ? (string) $status_obj->label : $status_key;
                                        ?>
                                        <option value="<?php echo esc_attr( $status_key ); ?>" <?php selected( $status_key, PO_STATUS_OPEN ); ?>><?php echo esc_html( $status_label ); ?></option>
                                    <?php endforeach; ?>
                                </select>
                            </label>
                        </div>

                        <div class="lpr-po-bulk-table-wrapper">
                            <table class="widefat fixed striped">
                                <thead>
                                    <tr>
                                        <th><?php esc_html_e( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
                                        <th><?php esc_html_e( 'Ordered', 'lpr-backorder-allocator' ); ?></th>
                                        <th><?php esc_html_e( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                        <th><?php esc_html_e( 'Received', 'lpr-backorder-allocator' ); ?></th>
                                        <th><?php esc_html_e( 'ETA Override', 'lpr-backorder-allocator' ); ?></th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody id="lpr-po-lines-new" data-next-index="0">
                                </tbody>
                            </table>
                            <p><button type="button" class="button lpr-po-bulk-add-line" data-target="lpr-po-lines-new" data-key="new" data-new="1"><?php esc_html_e( 'Add PO line', 'lpr-backorder-allocator' ); ?></button></p>
                        </div>
                    </div>

                    <p><button class="button button-primary"><?php esc_html_e( 'Save all PO changes', 'lpr-backorder-allocator' ); ?></button></p>
                </form>

                <style>
                    .lpr-po-bulk-grid { display: flex; flex-direction: column; gap: 16px; }
                    .lpr-po-bulk-card { background: #fff; border: 1px solid #c3c4c7; border-radius: 6px; padding: 16px; box-shadow: 0 1px 1px rgba(0,0,0,.04); width: 100%; }
                    .lpr-po-bulk-card__header { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 12px; }
                    .lpr-po-bulk-card__meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; font-size: 12px; color: #50575e; }
                    .lpr-po-bulk-chip { display: inline-flex; align-items: center; padding: 2px 8px; border-radius: 12px; background: #e2e8f0; font-size: 12px; }
                    .lpr-po-bulk-fields { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 12px; }
                    .lpr-po-bulk-fields label { display: flex; flex-direction: column; gap: 4px; font-weight: 600; }
                    .lpr-po-bulk-fields input, .lpr-po-bulk-fields select { width: 100%; }
                    .lpr-po-bulk-table-wrapper { margin-top: 12px; overflow-x: auto; }
                    .lpr-po-bulk-card--new { border-style: dashed; }
                    .lpr-po-bulk-card .lpr-product-cell { width: 45%; min-width: 260px; }
                    .lpr-po-bulk-card .lpr-product-cell .select2-container { width: 100% !important; min-width: 0; }
                </style>

                <script>
                (function($) {
                    function buildRow(baseName) {
                        var tr = document.createElement('tr');
                        tr.innerHTML = '<td class="lpr-product-cell">' +
                            '<select class="wc-product-search lpr-product-select" name="' + baseName + '[select_ui]" data-placeholder="<?php echo esc_js( __( 'Search for a productâ€¦', 'lpr-backorder-allocator' ) ); ?>" data-action="woocommerce_json_search_products_and_variations" data-minimum_input_length="1" data-allow_clear="true" style="width:100%;"></select>' +
                            '<input type="hidden" class="lpr-select-id" name="' + baseName + '[select_id]" value="" />' +
                            '<input type="hidden" class="lpr-product-id" name="' + baseName + '[product_id]" value="" />' +
                            '<input type="hidden" class="lpr-variation-id" name="' + baseName + '[variation_id]" value="" />' +
                            '</td>' +
                            '<td><input type="number" min="0" step="1" name="' + baseName + '[qty_ordered]" value="0" /></td>' +
                            '<td><input type="number" min="0" step="1" name="' + baseName + '[qty_allocated]" value="0" /></td>' +
                            '<td><input type="number" min="0" step="1" name="' + baseName + '[qty_received]" value="0" /></td>' +
                            '<td><input type="text" name="' + baseName + '[eta_override]" placeholder="DD-MM-YYYY" pattern="\\d{2}-\\d{2}-\\d{4}" /></td>' +
                            '<td><button type="button" class="button-link-delete lpr-po-bulk-remove-line">&times;</button></td>';
                        return tr;
                    }

                    function getNextIndex(tbody) {
                        var current = parseInt(tbody.dataset.nextIndex || tbody.children.length || 0, 10);
                        if ( isNaN(current) ) {
                            current = 0;
                        }
                        tbody.dataset.nextIndex = String(current + 1);
                        return current;
                    }

                    function initProductSearch($context) {
                        $(document.body).trigger('wc-enhanced-select-init');
                        $context.find('select.lpr-product-select').off('change.lprBulk').on('change.lprBulk', function() {
                            var $sel = $(this);
                            var val = $sel.val() || '';
                            var $row = $sel.closest('tr');
                            $row.find('.lpr-select-id').val(val);
                            if ( ! val ) {
                                $row.find('.lpr-product-id, .lpr-variation-id').val('');
                                return;
                            }
                            $row.find('.lpr-product-id, .lpr-variation-id').val('');
                        });
                    }

                    $('.lpr-po-bulk-add-line').on('click', function() {
                        var targetId = $(this).data('target');
                        var key = $(this).data('key');
                        var isNew = String( $(this).data('new') ) === '1';
                        var tbody = document.getElementById(targetId);
                        if ( ! tbody ) {
                            return;
                        }
                        var basePrefix = isNew ? 'new_po[lines]' : 'pos[' + key + '][lines]';
                        var nextIndex = getNextIndex(tbody);
                        var baseName = basePrefix + '[' + nextIndex + ']';
                        var row = buildRow(baseName);
                        tbody.appendChild(row);
                        initProductSearch( $( row ) );
                    });

                    $(document).on('click', '.lpr-po-bulk-remove-line', function() {
                        var $row = $(this).closest('tr');
                        if ( $row.length ) {
                            $row.remove();
                        }
                    });

                    initProductSearch( $('.lpr-po-bulk-wrap') );

                    $('form').on('submit', function() {
                        $(this).find('select.lpr-product-select').each(function() {
                            var $sel = $(this);
                            var val = $sel.val() || '';
                            var $row = $sel.closest('tr');
                            $row.find('.lpr-select-id').val(val);
                            if ( ! val ) {
                                $row.find('.lpr-product-id, .lpr-variation-id').val('');
                            }
                        });
                    });
                })(jQuery);
                </script>

            </div>
            <?php
        }
    }
    PO_Bulk_Editor_Page::init();
}

/**
 * Admin page: "Backordered Products" with quick add-to-PO actions.
 */
if ( ! class_exists( __NAMESPACE__ . '\Backordered_Products_Page' ) ) {
        class Backordered_Products_Page {

		public static function init(): void {
			add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
		}

                public static function register_page(): void {
                        add_submenu_page(
                                ADMIN_MENU_SLUG,
                                __( 'Backordered Products', 'lpr-backorder-allocator' ),
                                __( 'Backordered Products', 'lpr-backorder-allocator' ),
                                'manage_woocommerce',
                                'lpr-backordered-products',
                                array( __CLASS__, 'render' ),
                                1
                        );
                }

                protected static function filter_rows( array $rows, string $view ): array {
                        $out = array();
                        foreach ( $rows as $pid => $agg ) {
                                $desired = isset( $agg['desired_total'] ) ? (int) $agg['desired_total'] : 0;
                                if ( $desired <= 0 ) {
                                        continue;
                                }

                                $need = isset( $agg['need_total'] ) ? (int) $agg['need_total'] : 0;

                                if ( 'unallocated' === $view && $need <= 0 ) {
                                        continue;
                                }

                                if ( 'allocated' === $view && $need > 0 ) {
                                        continue;
                                }

                                $out[ $pid ] = $agg;
                        }
                        return $out;
                }

                /**
                 * Filter rows by a search term matching the product label.
                 */
                protected static function search_rows( array $rows, string $search ): array {
                        $search = trim( $search );
                        if ( '' === $search ) {
                                return $rows;
                        }

                        $needle   = function_exists( 'mb_strtolower' ) ? mb_strtolower( $search ) : strtolower( $search );
                        $filtered = array();

                        foreach ( $rows as $pid => $agg ) {
                                $label    = function_exists( __NAMESPACE__ . '\\lpr_allocator_product_option_label' ) ? lpr_allocator_product_option_label( (int) $pid ) : ( '#' . (int) $pid );
                                $haystack = function_exists( 'mb_strtolower' ) ? mb_strtolower( $label ) : strtolower( $label );

                                if ( false !== strpos( $haystack, $needle ) ) {
                                        $filtered[ $pid ] = $agg;
                                }
                        }

                        return $filtered;
                }

                /**
                 * Resolve the list of live PO statuses, guarded against missing helpers/constants.
                 */
                protected static function live_po_statuses(): array {
                        $statuses = function_exists( __NAMESPACE__ . '\\lpr_allocator_live_po_statuses' )
                                ? lpr_allocator_live_po_statuses()
                                : array();

                        if ( empty( $statuses ) ) {
                                if ( defined( __NAMESPACE__ . '\\PO_STATUS_OPEN' ) ) {
                                        $statuses[] = PO_STATUS_OPEN;
                                }
                                if ( defined( __NAMESPACE__ . '\\PO_STATUS_PARTIAL' ) ) {
                                        $statuses[] = PO_STATUS_PARTIAL;
                                }
                        }

                        return $statuses;
                }

                /**
                 * Aggregate totals for the backorder snapshot and open POs.
                 */
                protected static function get_totals( array $rows_all ): array {
                        $need_total = 0;
                        foreach ( $rows_all as $agg ) {
                                $need_total += max( 0, (int) ( $agg['need_total'] ?? 0 ) );
                        }

                        $incoming_total = 0;

                        $statuses = self::live_po_statuses();

                        if ( ! empty( $statuses ) ) {
                                $query = new \WP_Query(
                                        array(
                                                'post_type'      => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                                'post_status'    => $statuses,
                                                'posts_per_page' => -1,
                                                'fields'         => 'ids',
                                                'no_found_rows'  => true,
                                        )
                                );

                                foreach ( $query->posts as $po_id ) {
                                        $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                                        if ( ! is_array( $lines ) || empty( $lines ) ) {
                                                continue;
                                        }

                                        foreach ( $lines as $line ) {
                                                $qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                                $qty_received = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
                                                $incoming     = max( 0, $qty_ordered - $qty_received );

                                                if ( $incoming > 0 ) {
                                                        $incoming_total += $incoming;
                                                }
                                        }
                                }
                        }

                        return array(
                                'incoming_total'       => (int) $incoming_total,
                                'backorder_need_total' => (int) $need_total,
                        );
                }

                /**
                 * Build a map of incoming quantities for the provided product IDs across open POs.
                 */
                protected static function incoming_by_product( array $product_ids ): array {
                        $product_ids = array_filter( array_map( 'absint', $product_ids ) );
                        if ( empty( $product_ids ) ) {
                                return array();
                        }

                        $statuses = self::live_po_statuses();
                        if ( empty( $statuses ) ) {
                                return array_fill_keys( $product_ids, 0 );
                        }

                        $incoming    = array_fill_keys( $product_ids, 0 );
                        $product_map = array_fill_keys( $product_ids, true );

                        $query = new \WP_Query(
                                array(
                                        'post_type'      => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
                                        'post_status'    => $statuses,
                                        'posts_per_page' => -1,
                                        'fields'         => 'ids',
                                        'no_found_rows'  => true,
                                )
                        );

                        foreach ( $query->posts as $po_id ) {
                                $lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
                                if ( ! is_array( $lines ) || empty( $lines ) ) {
                                        continue;
                                }

                                foreach ( $lines as $line ) {
                                        $qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
                                        $qty_received = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
                                        $incoming_qty = max( 0, $qty_ordered - $qty_received );
                                        if ( $incoming_qty <= 0 ) {
                                                continue;
                                        }

                                        $target_id = isset( $line['variation_id'] ) && (int) $line['variation_id'] > 0 ? (int) $line['variation_id'] : (int) ( $line['product_id'] ?? 0 );
                                        if ( $target_id <= 0 || ! isset( $product_map[ $target_id ] ) ) {
                                                continue;
                                        }

                                        $incoming[ $target_id ] += $incoming_qty;
                                }
                        }

                        return $incoming;
                }

                public static function render(): void {
                        if ( ! current_user_can( 'manage_woocommerce' ) ) {
                                return;
                        }

			$view = isset( $_GET['view'] ) ? sanitize_key( wp_unslash( $_GET['view'] ) ) : 'unallocated'; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( ! in_array( $view, array( 'unallocated', 'all', 'allocated' ), true ) ) {
				$view = 'unallocated';
			}

                        $idx       = class_exists( __NAMESPACE__ . '\Backorder_Indexer' ) ? Backorder_Indexer::get_index( false ) : array( 'built_at' => 0, 'rows' => array() );
                        $built_ts  = isset( $idx['built_at'] ) ? (int) $idx['built_at'] : 0;
                        $rows_all  = isset( $idx['rows'] ) && is_array( $idx['rows'] ) ? $idx['rows'] : array();
                        $totals    = self::get_totals( $rows_all );
                        $rows_view = self::filter_rows( $rows_all, $view );

                        $search_term = isset( $_GET['s'] ) ? sanitize_text_field( wp_unslash( $_GET['s'] ) ) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        if ( '' !== $search_term ) {
                                $rows_view = self::search_rows( $rows_view, $search_term );
                        }

                        $visible_ids = array();
                        foreach ( $rows_view as $pid => $agg ) {
                                $need = isset( $agg['need_total'] ) ? (int) $agg['need_total'] : 0;
                                if ( $need > 0 ) {
                                        $visible_ids[] = (int) $pid;
                                }
                        }

                        $incoming_by_product = self::incoming_by_product( array_keys( $rows_view ) );

                        // Preload the order index for the displayed products to show linked orders per product row.
                        $orders_by_product = array();
                        if ( class_exists( __NAMESPACE__ . '\Backorder_Order_Indexer' ) ) {
                                $order_idx   = Backorder_Order_Indexer::get_index( false );
                                $order_rows  = isset( $order_idx['rows'] ) && is_array( $order_idx['rows'] ) ? $order_idx['rows'] : array();
                                $visible_map = array_fill_keys( $visible_ids, true );

                                foreach ( $order_rows as $row ) {
                                        $pid = isset( $row['product_id'] ) ? (int) $row['product_id'] : 0;
                                        if ( $pid <= 0 || ! isset( $visible_map[ $pid ] ) ) {
                                                continue;
                                        }

                                        $is_backorder_line = ! empty( $row['is_backorder_line'] );
                                        $backordered_qty   = isset( $row['qty_backordered'] ) ? (int) $row['qty_backordered'] : 0;
                                        if ( ! $is_backorder_line || $backordered_qty <= 0 ) {
                                                continue;
                                        }

                                        $order_id = isset( $row['order_id'] ) ? (int) $row['order_id'] : 0;
                                        if ( $order_id <= 0 ) {
                                                continue;
                                        }

                                        if ( ! isset( $orders_by_product[ $pid ] ) ) {
                                                $orders_by_product[ $pid ] = array();
                                        }

                                        if ( isset( $orders_by_product[ $pid ][ $order_id ] ) ) {
                                                continue; // Already captured this order for this product.
                                        }

                                        $orders_by_product[ $pid ][ $order_id ] = array(
                                                'customer'     => (string) ( $row['customer'] ?? '' ),
                                                'order_number' => (string) ( $row['order_number'] ?? $order_id ),
                                                'order_url'    => (string) ( $row['order_url'] ?? '' ),
                                                'order_date'   => (string) ( $row['order_date'] ?? '' ),
                                                'status'       => (string) ( $row['status'] ?? '' ),
                                        );
                                }
                        }

			// Sort: need desc, then desired desc.
			uasort(
				$rows_view,
				static function ( $a, $b ) {
					$an = (int) ( $a['need_total'] ?? 0 );
					$bn = (int) ( $b['need_total'] ?? 0 );
					if ( $an !== $bn ) {
						return ( $bn <=> $an );
					}
					$ad = (int) ( $a['desired_total'] ?? 0 );
					$bd = (int) ( $b['desired_total'] ?? 0 );
					return ( $bd <=> $ad );
				}
			);

                        // Pagination (server-side on snapshot).
                        $page     = isset( $_GET['paged'] ) ? max( 1, (int) $_GET['paged'] ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
                        $per_page = 25;
                        $total    = count( $rows_view );
                        $pages    = max( 1, (int) ceil( $total / $per_page ) );
                        $offset   = ( $page - 1 ) * $per_page;
                        $subset   = array_slice( $rows_view, $offset, $per_page, true );

                        $page_args = array(
                                'page' => 'lpr-backordered-products',
                                'view' => $view,
                        );

                        if ( '' !== $search_term ) {
                                $page_args['s'] = $search_term;
                        }

                        $current_page_url = add_query_arg( array_merge( $page_args, array( 'paged' => $page ) ), admin_url( 'admin.php' ) );
                        $pagination_base  = add_query_arg( array_merge( $page_args, array( 'paged' => '%#%' ) ), admin_url( 'admin.php' ) );

                        $rebuild_url = wp_nonce_url(
                                add_query_arg(
                                        array(
                                                'action'   => 'lpr_build_backorder_index',
                                                'redirect' => rawurlencode( $current_page_url ),
                                        ),
                                        admin_url( 'admin-post.php' )
                                ),
                                'lpr_build_backorder_index'
                        );

			// Notices.
			if ( isset( $_GET['lpr_index'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$state = sanitize_key( wp_unslash( $_GET['lpr_index'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				if ( 'queued' === $state ) {
					echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Backorder index rebuild has been queued.', 'lpr-backorder-allocator' ) . '</p></div>';
				} elseif ( 'rebuilt' === $state ) {
					echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Backorder index rebuilt.', 'lpr-backorder-allocator' ) . '</p></div>';
				}
			}
			if ( isset( $_GET['lpr_added'] ) && isset( $_GET['po_id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$po_id = absint( $_GET['po_id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$link  = $po_id ? get_edit_post_link( $po_id, 'url' ) : '';
				$msg   = $link
					? sprintf( __( 'Added to PO draft. %sEdit PO%s.', 'lpr-backorder-allocator' ), '<a href="' . esc_url( $link ) . '">', '</a>' )
					: __( 'Added to PO draft.', 'lpr-backorder-allocator' );
				echo '<div class="notice notice-success is-dismissible"><p>' . wp_kses_post( $msg ) . '</p></div>';
			}

			// Controls.
                        ?>
                        <div class="wrap">
                                <h1><?php echo esc_html__( 'Backordered Products', 'lpr-backorder-allocator' ); ?></h1>
                                <div style="margin:10px 0; display:flex; gap:12px; align-items:center;">
                                        <form method="get" action="">
                                                <input type="hidden" name="page" value="lpr-backordered-products" />
                                                <?php if ( '' !== $search_term ) : ?>
                                                        <input type="hidden" name="s" value="<?php echo esc_attr( $search_term ); ?>" />
                                                <?php endif; ?>
                                                <label for="lpr-view"><strong><?php echo esc_html__( 'View', 'lpr-backorder-allocator' ); ?>:</strong></label>
                                                <select id="lpr-view" name="view" onchange="this.form.submit()">
                                                        <option value="unallocated" <?php selected( $view, 'unallocated' ); ?>><?php echo esc_html__( 'Not fully allocated', 'lpr-backorder-allocator' ); ?></option>
                                                        <option value="all" <?php selected( $view, 'all' ); ?>><?php echo esc_html__( 'All backordered (incl. fully allocated)', 'lpr-backorder-allocator' ); ?></option>
                                                        <option value="allocated" <?php selected( $view, 'allocated' ); ?>><?php echo esc_html__( 'Fully allocated', 'lpr-backorder-allocator' ); ?></option>
                                                </select>
                                                <noscript><button class="button"><?php esc_html_e( 'Apply', 'lpr-backorder-allocator' ); ?></button></noscript>
                                        </form>

                                        <form method="get" action="" style="display:flex; gap:6px; align-items:center;">
                                                <input type="hidden" name="page" value="lpr-backordered-products" />
                                                <input type="hidden" name="view" value="<?php echo esc_attr( $view ); ?>" />
                                                <label for="lpr-search"><strong><?php echo esc_html__( 'Search', 'lpr-backorder-allocator' ); ?>:</strong></label>
                                                <input type="search" id="lpr-search" name="s" value="<?php echo esc_attr( $search_term ); ?>" placeholder="<?php echo esc_attr__( 'Search productsâ€¦', 'lpr-backorder-allocator' ); ?>" />
                                                <button class="button" type="submit"><?php esc_html_e( 'Search', 'lpr-backorder-allocator' ); ?></button>
                                        </form>

                                        <a class="button button-secondary" href="<?php echo esc_url( $rebuild_url ); ?>">
                                                <?php echo esc_html__( 'Rebuild Snapshot', 'lpr-backorder-allocator' ); ?>
                                        </a>

                                        <span style="opacity:.8;">
                                                <?php
                                                echo esc_html(
                                                        sprintf(
								/* translators: %s: datetime */
								__( 'Last built: %s', 'lpr-backorder-allocator' ),
								$built_ts ? wp_date( 'd-m-Y H:i:s', $built_ts ) : __( 'never', 'lpr-backorder-allocator' )
							)
                                                );
                                                ?>
                                        </span>
                                </div>

                                <div class="lpr-backorders-stats">
                                        <div class="lpr-backorders-stat">
                                                <span class="label"><?php echo esc_html__( 'Amount incoming (open POs)', 'lpr-backorder-allocator' ); ?></span>
                                                <span class="value"><?php echo esc_html( number_format_i18n( (int) ( $totals['incoming_total'] ?? 0 ) ) ); ?></span>
                                        </div>
                                        <div class="lpr-backorders-stat">
                                                <span class="label"><?php echo esc_html__( 'Required to cover backorders', 'lpr-backorder-allocator' ); ?></span>
                                                <span class="value"><?php echo esc_html( number_format_i18n( (int) ( $totals['backorder_need_total'] ?? 0 ) ) ); ?></span>
                                        </div>
                                </div>

                                <style>
                                        .lpr-backorders-table { width:100%; border-collapse: collapse; }
                                        .lpr-backorders-table th, .lpr-backorders-table td { padding:8px; border-bottom:1px solid #e5e5e5; text-align:left; vertical-align:top; }
                                        .lpr-backorders-table th.num, .lpr-backorders-table td.num { text-align:right; white-space:nowrap; }
                                        .lpr-quick-form { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
                                        .lpr-quick-form input[type="number"] { width:90px; }
                                        .lpr-quick-form input[type="text"] { width:140px; }
                                        .lpr-orders-dropdown { display:none; margin-top:8px; padding:8px 10px; border:1px solid #dcdcde; background:#f6f7f7; border-radius:4px; max-width:460px; }
                                        .lpr-orders-dropdown ul { margin:4px 0 0; padding-left:18px; }
                                        .lpr-orders-dropdown li { margin:4px 0; line-height:1.4; }
                                        .lpr-orders-dropdown .order-meta { display:block; color:#6c6c6c; font-size:12px; }
                                        .tablenav-pages { margin-top: 12px; }
                                        .lpr-backorders-stats { display:flex; flex-wrap:wrap; gap:12px; margin:8px 0 14px; }
                                        .lpr-backorders-stat { padding:10px 12px; border:1px solid #dcdcde; background:#fff; border-radius:6px; min-width:220px; box-shadow:0 2px 6px rgba(0,0,0,0.04); }
                                        .lpr-backorders-stat .label { display:block; font-size:12px; letter-spacing:.02em; text-transform:uppercase; color:#555; margin-bottom:4px; }
                                        .lpr-backorders-stat .value { display:block; font-size:20px; font-weight:600; color:#1d2327; }
                                </style>

                                <table class="widefat striped lpr-backorders-table">
                                        <thead>
                                                <tr>
                                                        <th><?php echo esc_html__( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
                                                        <th><?php echo esc_html__( 'Linked Orders', 'lpr-backorder-allocator' ); ?></th>
                                                        <th class="num"><?php echo esc_html__( 'Backordered', 'lpr-backorder-allocator' ); ?></th>
                                                        <th class="num"><?php echo esc_html__( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                        <th class="num"><?php echo esc_html__( 'Incoming (open POs)', 'lpr-backorder-allocator' ); ?></th>
                                                        <th class="num"><?php echo esc_html__( 'Required to Allocate', 'lpr-backorder-allocator' ); ?></th>
                                                        <th class="num"><?php echo esc_html__( 'Required to Cover Backorders', 'lpr-backorder-allocator' ); ?></th>
                                                        <th><?php echo esc_html__( 'Quick add to Supplier PO draft', 'lpr-backorder-allocator' ); ?></th>
                                                </tr>
                                        </thead>
                                                <tbody>
                                                <?php if ( empty( $subset ) ) : ?>
                                                        <tr><td colspan="8"><?php echo esc_html__( 'No results for this view.', 'lpr-backorder-allocator' ); ?></td></tr>
                                                <?php else : ?>
                                                        <?php foreach ( $subset as $pid => $agg ) :
                                                                $desired = (int) ( $agg['desired_total'] ?? 0 );
                                                                $alloc   = (int) ( $agg['allocated_total'] ?? 0 );
                                // Clamp allocated not to exceed desired for display sanity.
                                                                if ( $alloc > $desired ) { $alloc = $desired; }
                                                                $need    = max( 0, (int) ( $agg['need_total'] ?? ( $desired - $alloc ) ) );
                                                                $incoming = (int) ( $incoming_by_product[ $pid ] ?? 0 );
                                                                $required_after_incoming = max( 0, $need - $incoming );
                                                                $label   = function_exists( __NAMESPACE__ . '\lpr_allocator_product_option_label' ) ? lpr_allocator_product_option_label( (int) $pid ) : ( '#' . (int) $pid );
                                                                $edit    = get_edit_post_link( (int) $pid, 'url' );
                                                                $orders  = $orders_by_product[ $pid ] ?? array();
                                                                $toggle_id = 'lpr-orders-' . (int) $pid;
                                                                ?>
                                                                <tr>
                                                                        <td>
                                                                                <?php if ( $edit ) : ?>
                                                                                        <a href="<?php echo esc_url( $edit ); ?>"><?php echo esc_html( $label ); ?></a>
                                                                                <?php else : ?>
                                                                                        <?php echo esc_html( $label ); ?>
                                                                                <?php endif; ?>
                                                                        </td>
                                                                        <td>
                                                                                <div class="lpr-orders-cell">
                                                                                        <?php if ( ! empty( $orders ) ) : ?>
                                                                                                <button type="button" class="button lpr-orders-toggle" data-target="<?php echo esc_attr( $toggle_id ); ?>" data-label-show="<?php echo esc_attr( __( 'Show orders', 'lpr-backorder-allocator' ) ); ?>" data-label-hide="<?php echo esc_attr( __( 'Hide orders', 'lpr-backorder-allocator' ) ); ?>" aria-expanded="false"><?php echo esc_html__( 'Show orders', 'lpr-backorder-allocator' ); ?></button>
                                                                                                <div id="<?php echo esc_attr( $toggle_id ); ?>" class="lpr-orders-dropdown" aria-hidden="true">
                                                                                                        <ul>
                                                                                                                <?php foreach ( $orders as $order ) : ?>
                                                                                                                        <li>
                                                                                                                                <strong><?php echo esc_html( $order['customer'] ?: __( 'Customer', 'lpr-backorder-allocator' ) ); ?></strong><br />
                                                                                                                                <?php if ( ! empty( $order['order_url'] ) ) : ?>
                                                                                                                                        <a href="<?php echo esc_url( $order['order_url'] ); ?>"><?php echo esc_html( sprintf( __( 'Order #%s', 'lpr-backorder-allocator' ), $order['order_number'] ) ); ?></a>
                                                                                                                                <?php else : ?>
                                                                                                                                        <?php echo esc_html( sprintf( __( 'Order #%s', 'lpr-backorder-allocator' ), $order['order_number'] ) ); ?>
                                                                                                                                <?php endif; ?>
                                                                                                                                <span class="order-meta">
                                                                                                                                        <?php if ( ! empty( $order['order_date'] ) ) : ?>
                                                                                                                                                <?php echo esc_html( $order['order_date'] ); ?>
                                                                                                                                                &middot;
                                                                                                                                        <?php endif; ?>
                                                                                                                                        <?php echo esc_html( $order['status'] ); ?>
                                                                                                                                </span>
                                                                                                                        </li>
                                                                                                                <?php endforeach; ?>
                                                                                                        </ul>
                                                                                                </div>
                                                                                        <?php else : ?>
                                                                                                <span class="description"><?php echo esc_html__( 'No linked orders found.', 'lpr-backorder-allocator' ); ?></span>
                                                                                        <?php endif; ?>
                                                                                </div>
                                                                        </td>
                                                                        <td class="num"><?php echo esc_html( (string) $desired ); ?></td>
                                                                        <td class="num"><?php echo esc_html( (string) $alloc ); ?></td>
                                                                        <td class="num"><?php echo esc_html( (string) $incoming ); ?></td>
                                                                        <td class="num"><strong><?php echo esc_html( (string) $need ); ?></strong></td>
                                                                        <td class="num"><strong><?php echo esc_html( (string) $required_after_incoming ); ?></strong></td>
                                                                        <td>
                                                                                <form class="lpr-quick-form" method="post" action="<?php echo esc_url( admin_url( 'admin-post.php' ) ); ?>">
                                                                                        <input type="hidden" name="action" value="lpr_quick_add_to_po" />
                                                                                        <?php wp_nonce_field( 'lpr_quick_add_to_po', 'lpr_quick_nonce' ); ?>
                                                                                        <input type="hidden" name="product_id" value="<?php echo esc_attr( (string) $pid ); ?>" />
                                                                                        <input type="hidden" name="redirect" value="<?php echo esc_attr( $current_page_url ); ?>" />
                                                                                        <label>
                                                                                                <?php echo esc_html__( 'Qty', 'lpr-backorder-allocator' ); ?>
                                                                                                <input type="number" min="1" step="1" name="qty" value="<?php echo esc_attr( (string) max( 1, $required_after_incoming > 0 ? $required_after_incoming : $need ) ); ?>" />
                                                                                        </label>
											<label>
												<?php echo esc_html__( 'Supplier', 'lpr-backorder-allocator' ); ?>
												<input type="text" name="supplier_name" />
											</label>
											<label>
                                                                                                <?php echo esc_html__( 'ETA (dd-mm-yyyy)', 'lpr-backorder-allocator' ); ?>
                                                                                                <input type="text" class="short" name="eta_ymd" placeholder="DD-MM-YYYY" pattern="\d{2}-\d{2}-\d{4}" />
                                                                                        </label>
											<button type="submit" class="button button-secondary"><?php echo esc_html__( 'Add to PO Draft', 'lpr-backorder-allocator' ); ?></button>
										</form>
									</td>
								</tr>
							<?php endforeach; ?>
						<?php endif; ?>
					</tbody>
				</table>

				<?php if ( $pages > 1 ) : ?>
					<div class="tablenav-pages">
						<span class="displaying-num"><?php echo esc_html( sprintf( _n( '%s item', '%s items', $total, 'lpr-backorder-allocator' ), number_format_i18n( $total ) ) ); ?></span>
						<span class="pagination-links">
							<?php
                                                        echo wp_kses_post(
                                                                paginate_links(
                                                                        array(
                                                                                'base'      => $pagination_base,
                                                                                'format'    => '',
                                                                                'current'   => $page,
                                                                                'total'     => $pages,
                                                                                'prev_text' => __( '&laquo;', 'lpr-backorder-allocator' ),
                                                                                'next_text' => __( '&raquo;', 'lpr-backorder-allocator' ),
                                                                        )
                                                                )
                                                        );
							?>
						</span>
                                        </div>
                                <?php endif; ?>
                                <script>
                                document.addEventListener('DOMContentLoaded', function() {
                                        document.querySelectorAll('.lpr-orders-toggle').forEach(function(btn) {
                                                btn.addEventListener('click', function() {
                                                        var targetId = this.getAttribute('data-target');
                                                        var target = targetId ? document.getElementById(targetId) : null;
                                                        if (!target) {
                                                                return;
                                                        }
                                                        var isOpen = target.style.display === 'block';
                                                        target.style.display = isOpen ? 'none' : 'block';
                                                        target.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
                                                        this.setAttribute('aria-expanded', isOpen ? 'false' : 'true');
                                                        var show = this.getAttribute('data-label-show') || this.textContent;
                                                        var hide = this.getAttribute('data-label-hide') || this.textContent;
                                                        this.textContent = isOpen ? show : hide;
                                                });
                                        });
                                });
                                </script>
                        </div>
                        <?php
                }
        }
        Backordered_Products_Page::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Incoming_Mobile_Inbox' ) ) {
        /**
         * Ultra-fast mobile dashboard for receiving incoming POs at /incoming.
         */
        class Incoming_Mobile_Inbox {

                const COOKIE_KEY = 'lpr_incoming_token';
                const TOKEN_TTL  = 1800; // 30 minutes.

                protected static $active_user = '';

                public static function init(): void {
                        add_action( 'template_redirect', array( __CLASS__, 'maybe_render' ), 0 );

                        add_action( 'wp_ajax_lpr_incoming_product_search', array( __CLASS__, 'ajax_product_search' ) );
                        add_action( 'wp_ajax_nopriv_lpr_incoming_product_search', array( __CLASS__, 'ajax_product_search' ) );
                        add_action( 'wp_ajax_lpr_incoming_product_details', array( __CLASS__, 'ajax_product_details' ) );
                        add_action( 'wp_ajax_nopriv_lpr_incoming_product_details', array( __CLASS__, 'ajax_product_details' ) );
                }

                /**
                 * Validate a token carried via AJAX to allow receiving without WP auth.
                 */
                public static function authorize_ajax_request( int $po_id ): bool {
                        if ( $po_id <= 0 ) {
                                return false;
                        }

                        $token = isset( $_POST['incoming_token'] ) ? (string) wp_unslash( $_POST['incoming_token'] ) : '';
                        if ( self::validate_token( $token ) ) {
                                return true;
                        }

                        if ( isset( $_COOKIE[ self::COOKIE_KEY ] ) && self::validate_token( (string) wp_unslash( $_COOKIE[ self::COOKIE_KEY ] ) ) ) {
                                return true;
                        }

                        return false;
                }

                /**
                 * Build the allocations view URL for a PO.
                 */
                public static function allocation_url( int $po_id, string $token = '' ): string {
                        $url = home_url( '/incoming?view=allocations&po=' . absint( $po_id ) );

                        if ( $token ) {
                                $url = add_query_arg( array( 'incoming_token' => rawurlencode( $token ) ), $url );
                        }

                        return $url;
                }

                /**
                 * Detect the /incoming path while avoiding other pages.
                 */
                protected static function is_incoming_request(): bool {
                        return function_exists( __NAMESPACE__ . '\\lpr_allocator_is_incoming_request' ) ? lpr_allocator_is_incoming_request() : false;
                }

                protected static function allowed_users(): array {
                        return Settings::mobile_user_map();
                }

                protected static function generate_token( string $user, string $pin ): string {
                        $expires = time() + self::TOKEN_TTL;
                        $data    = $user . '|' . $expires;
                        $secret  = wp_salt( 'auth' );
                        $hash    = hash_hmac( 'sha256', $data . '|' . $pin, $secret );

                        return base64_encode( $data . '|' . $hash );
                }

                protected static function validate_token( string $token ): bool {
                        $decoded = base64_decode( $token );
                        if ( ! $decoded || false === strpos( $decoded, '|' ) ) {
                                return false;
                        }

                        $bits = explode( '|', $decoded );
                        if ( count( $bits ) < 3 ) {
                                return false;
                        }

                        list( $user, $expires, $hash ) = $bits;
                        if ( (int) $expires < time() ) {
                                return false;
                        }

                        $map = self::allowed_users();
                        $key = strtolower( $user );
                        if ( ! isset( $map[ $key ] ) ) {
                                return false;
                        }

                        $pin      = (string) $map[ $key ]['pin'];
                        $expected = hash_hmac( 'sha256', $user . '|' . $expires . '|' . $pin, wp_salt( 'auth' ) );
                        if ( ! hash_equals( $expected, $hash ) ) {
                                return false;
                        }

                        self::$active_user = (string) $map[ $key ]['user'];

                        return true;
                }

                protected static function authorize_token_request(): bool {
                        $token = isset( $_POST['incoming_token'] ) ? (string) wp_unslash( $_POST['incoming_token'] ) : '';

                        if ( $token && self::validate_token( $token ) ) {
                                return true;
                        }

                        if ( isset( $_COOKIE[ self::COOKIE_KEY ] ) && self::validate_token( (string) wp_unslash( $_COOKIE[ self::COOKIE_KEY ] ) ) ) {
                                return true;
                        }

                        return false;
                }

                protected static function format_eta_label( string $eta ): string {
                        if ( '' === $eta ) {
                                return __( 'No ETA', 'lpr-backorder-allocator' );
                        }

                        $formatted = lpr_allocator_format_store_date( $eta );
                        return $formatted ?: $eta;
                }

                protected static function format_stat( int $value ): string {
                        return number_format_i18n( $value );
                }

                protected static function handle_auth(): array {
                        $users = self::allowed_users();
                        $error = '';
                        $token = '';

                        if ( isset( $_GET['incoming_token'] ) && self::validate_token( (string) wp_unslash( $_GET['incoming_token'] ) ) ) {
                                $token = (string) wp_unslash( $_GET['incoming_token'] );
                                setcookie( self::COOKIE_KEY, $token, time() + self::TOKEN_TTL, '/', '', is_ssl(), true );

                                return array(
                                        'authorized' => true,
                                        'user'       => self::$active_user,
                                        'token'      => $token,
                                        'error'      => '',
                                );
                        }

                        if ( isset( $_COOKIE[ self::COOKIE_KEY ] ) && self::validate_token( (string) wp_unslash( $_COOKIE[ self::COOKIE_KEY ] ) ) ) {
                                $token = (string) wp_unslash( $_COOKIE[ self::COOKIE_KEY ] );
                                return array(
                                        'authorized' => true,
                                        'user'       => self::$active_user,
                                        'token'      => $token,
                                        'error'      => '',
                                );
                        }

                        if ( 'POST' === $_SERVER['REQUEST_METHOD'] && isset( $_POST['incoming_user'], $_POST['incoming_pin'] ) ) {
                                $user_raw = (string) wp_unslash( $_POST['incoming_user'] );
                                $pin_raw  = (string) wp_unslash( $_POST['incoming_pin'] );
                                $user     = sanitize_text_field( $user_raw );
                                $pin      = preg_replace( '/[^0-9]/', '', $pin_raw );
                                $key      = strtolower( $user );

                                if ( isset( $users[ $key ] ) && (string) $users[ $key ]['pin'] === $pin ) {
                                        $clean_user     = (string) $users[ $key ]['user'];
                                        $token          = self::generate_token( $clean_user, $pin );
                                        self::$active_user = $clean_user;
                                        setcookie( self::COOKIE_KEY, $token, time() + self::TOKEN_TTL, '/', '', is_ssl(), true );

                                        return array(
                                                'authorized' => true,
                                                'user'       => $clean_user,
                                                'token'      => $token,
                                                'error'      => '',
                                        );
                                }

                                $error = __( 'Incorrect username or PIN.', 'lpr-backorder-allocator' );
                        }

                        if ( empty( $users ) && '' === $error ) {
                                $error = __( 'Add at least one username + PIN in settings to unlock the incoming view.', 'lpr-backorder-allocator' );
                        }

                        return array(
                                'authorized' => false,
                                'user'       => '',
                                'token'      => $token,
                                'error'      => $error,
                        );
                }

                public static function maybe_render(): void {
                        if ( is_admin() || ! self::is_incoming_request() ) {
                                return;
                        }

                        $auth   = self::handle_auth();
                        $view   = isset( $_GET['view'] ) ? sanitize_key( wp_unslash( $_GET['view'] ) ) : '';
                        $po_id  = isset( $_GET['po'] ) ? absint( $_GET['po'] ) : 0;
                        $token  = $auth['token'];
                        $user   = $auth['user'];
                        $error  = $auth['error'];

                        nocache_headers();
                        status_header( 200 );
                        header( 'Content-Type: text/html; charset=utf-8' );

                        if ( ! $auth['authorized'] ) {
                                self::render_login( $error );
                                exit;
                        }

                        if ( 'allocations' === $view && $po_id > 0 ) {
                                self::render_allocations_page( $user, $token, $po_id );
                                exit;
                        }

                        if ( 'receiving' === $view ) {
                                self::render_dashboard( $user, $token );
                                exit;
                        }

                        if ( 'products' === $view ) {
                                self::render_product_lookup( $user, $token );
                                exit;
                        }

                        self::render_start_menu( $user, $token );
                        exit;
                }

                protected static function render_login( string $error ): void {
                        ?>
                        <!DOCTYPE html>
                        <html <?php language_attributes(); ?>>
                        <head>
                                <meta charset="<?php bloginfo( 'charset' ); ?>" />
                                <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
                                <title><?php echo esc_html__( 'Incoming POs', 'lpr-backorder-allocator' ); ?></title>
                                <style>
                                        body { margin:0; padding:0; font-family:-apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; background:#0f172a; color:#fff; }
                                        .lpr-incoming-login { max-width:420px; margin:10vh auto; padding:28px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); border-radius:16px; backdrop-filter:blur(10px); box-shadow:0 24px 60px rgba(0,0,0,0.3); }
                                        .lpr-incoming-login h1 { margin:0 0 12px; font-size:24px; }
                                        .lpr-incoming-login p { margin:0 0 16px; color:#cbd5f5; line-height:1.5; }
                                        .lpr-incoming-login label { display:block; margin-bottom:14px; }
                                        .lpr-incoming-login input { width:100%; padding:14px 16px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.05); color:#fff; font-size:16px; }
                                        .lpr-incoming-login input:focus { outline:2px solid #38bdf8; border-color:#38bdf8; }
                                        .lpr-incoming-login button { width:100%; padding:14px 16px; border-radius:12px; border:none; background:linear-gradient(120deg,#22d3ee,#6366f1); color:#0f172a; font-weight:700; font-size:16px; cursor:pointer; box-shadow:0 10px 25px rgba(34,211,238,0.35); }
                                        .lpr-incoming-login .error { background:rgba(248,113,113,0.1); color:#fecdd3; border:1px solid rgba(248,113,113,0.35); padding:12px 14px; border-radius:12px; margin-bottom:14px; }
                                        .lpr-login-foot { margin-top:12px; color:#cbd5f5; font-size:13px; text-align:center; }
                                </style>
                        </head>
                        <body>
                                <div class="lpr-incoming-login">
                                        <h1><?php echo esc_html__( 'Incoming PO Check-in', 'lpr-backorder-allocator' ); ?></h1>
                                        <p><?php echo esc_html__( 'Enter your username and 4-digit PIN to unlock the lightning-fast incoming dashboard.', 'lpr-backorder-allocator' ); ?></p>
                                        <?php if ( $error ) : ?>
                                                <div class="error" role="alert"><?php echo esc_html( $error ); ?></div>
                                        <?php endif; ?>
                                        <form method="post">
                                                <label>
                                                        <input type="text" name="incoming_user" autocomplete="username" placeholder="<?php echo esc_attr__( 'Username', 'lpr-backorder-allocator' ); ?>" required />
                                                </label>
                                                <label>
                                                        <input type="tel" name="incoming_pin" inputmode="numeric" pattern="[0-9]{4}" maxlength="4" autocomplete="one-time-code" placeholder="<?php echo esc_attr__( '4-digit PIN', 'lpr-backorder-allocator' ); ?>" required />
                                                </label>
                                                <button type="submit"><?php echo esc_html__( 'Enter Incoming', 'lpr-backorder-allocator' ); ?></button>
                                        </form>
                                        <div class="lpr-login-foot"><?php echo esc_html__( 'Configured in WooCommerce â†’ Settings â†’ Backorders.', 'lpr-backorder-allocator' ); ?></div>
                                </div>
                        </body>
                        </html>
                        <?php
                }

                protected static function render_start_menu( string $user, string $token ): void {
                        $ajax_url = admin_url( 'admin-ajax.php' );
                        $receive_url = add_query_arg( 'view', 'receiving', home_url( '/incoming' ) );
                        $product_url = add_query_arg( 'view', 'products', home_url( '/incoming' ) );
                        $rows = class_exists( __NAMESPACE__ . '\Incoming_Purchase_Orders_Page' ) ? Incoming_Purchase_Orders_Page::collect_rows() : array();
                        $open_count = count( $rows );
                        ?>
                        <!DOCTYPE html>
                        <html <?php language_attributes(); ?>>
                        <head>
                                <meta charset="<?php bloginfo( 'charset' ); ?>" />
                                <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
                                <title><?php echo esc_html__( 'Incoming', 'lpr-backorder-allocator' ); ?></title>
                                <style>
                                        body { margin:0; padding:0; font-family:-apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; background:#0b1120; color:#e2e8f0; }
                                        a { color:inherit; text-decoration:none; }
                                        .lpr-shell { padding:22px 16px 60px; max-width:1080px; margin:0 auto; }
                                        .lpr-top { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:18px; }
                                        h1 { margin:0; font-size:24px; }
                                        .lpr-user { font-size:14px; color:#cbd5e1; }
                                        .lpr-menu { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:14px; }
                                        .lpr-card { padding:18px; border-radius:18px; background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.08); box-shadow:0 16px 34px rgba(0,0,0,0.28); position:relative; overflow:hidden; }
                                        .lpr-card.primary { background:linear-gradient(140deg,#22d3ee 0%, #6366f1 60%, #4338ca 100%); color:#0f172a; border-color:rgba(255,255,255,0.16); box-shadow:0 18px 40px rgba(99,102,241,0.4); }
                                        .lpr-card h2 { margin:0 0 8px; font-size:18px; }
                                        .lpr-card p { margin:0 0 14px; color:#cbd5e1; line-height:1.5; }
                                        .lpr-card.primary p { color:#0f172a; }
                                        .lpr-cta { display:inline-flex; align-items:center; gap:8px; padding:12px 14px; border-radius:12px; background:rgba(255,255,255,0.14); color:#0f172a; font-weight:700; box-shadow:0 12px 30px rgba(15,23,42,0.25); }
                                        .lpr-card.primary .lpr-cta { background:#0f172a; color:#e0f2fe; }
                                        .lpr-pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.1); color:#e2e8f0; font-size:12px; margin-bottom:10px; }
                                        .lpr-card.primary .lpr-pill { background:rgba(15,23,42,0.14); color:#0f172a; }
                                </style>
                        </head>
                        <body>
                                <div class="lpr-shell" data-token="<?php echo esc_attr( $token ); ?>" data-ajax="<?php echo esc_url( $ajax_url ); ?>">
                                        <div class="lpr-top">
                                                <h1><?php echo esc_html__( 'Start', 'lpr-backorder-allocator' ); ?></h1>
                                                <span class="lpr-user"><?php echo esc_html( sprintf( __( 'Signed in as %s', 'lpr-backorder-allocator' ), $user ) ); ?></span>
                                        </div>
                                        <div class="lpr-menu">
                                                <a class="lpr-card primary" href="<?php echo esc_url( $receive_url ); ?>">
                                                        <span class="lpr-pill"><?php echo esc_html( sprintf( _n( '%d open arrival', '%d open arrivals', $open_count, 'lpr-backorder-allocator' ), $open_count ) ); ?></span>
                                                        <h2><?php echo esc_html__( 'Receive incoming POs', 'lpr-backorder-allocator' ); ?></h2>
                                                        <p><?php echo esc_html__( 'Open arrivals, scan PO lines, and queue receipts with the fastest mobile workflow.', 'lpr-backorder-allocator' ); ?></p>
                                                        <span class="lpr-cta"><?php echo esc_html__( 'Open receiving', 'lpr-backorder-allocator' ); ?> â†’</span>
                                                </a>
                                                <a class="lpr-card" href="<?php echo esc_url( $product_url ); ?>">
                                                        <span class="lpr-pill"><?php echo esc_html__( 'New', 'lpr-backorder-allocator' ); ?></span>
                                                        <h2><?php echo esc_html__( 'Product lookup', 'lpr-backorder-allocator' ); ?></h2>
                                                        <p><?php echo esc_html__( 'Lightning-fast SKU search with live stock, incoming, and PO timelines in one place.', 'lpr-backorder-allocator' ); ?></p>
                                                        <span class="lpr-cta"><?php echo esc_html__( 'Search products', 'lpr-backorder-allocator' ); ?> â†’</span>
                                                </a>
                                        </div>
                                </div>
                        </body>
                        </html>
                        <?php
                }

                protected static function render_dashboard( string $user, string $token ): void {
                        $rows     = class_exists( __NAMESPACE__ . '\Incoming_Purchase_Orders_Page' ) ? Incoming_Purchase_Orders_Page::collect_rows() : array();
                        $count    = count( $rows );
                        $soonest  = '';
                        $line_sum = 0;

                        foreach ( $rows as $row ) {
                                $eta = isset( $row['eta'] ) ? (string) $row['eta'] : '';
                                if ( '' === $soonest || ( $eta && lpr_allocator_compare_dates( $eta, $soonest ) < 0 ) ) {
                                        $soonest = $eta;
                                }
                                $line_sum += isset( $row['lines'] ) ? count( (array) $row['lines'] ) : 0;
                        }

                        $ajax_url = admin_url( 'admin-ajax.php' );
                        ?>
                        <!DOCTYPE html>
                        <html <?php language_attributes(); ?>>
                        <head>
                                <meta charset="<?php bloginfo( 'charset' ); ?>" />
                                <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
                                <title><?php echo esc_html__( 'Incoming POs', 'lpr-backorder-allocator' ); ?></title>
                                <style>
                                        :root { color-scheme: light dark; }
                                        body { margin:0; padding:0; font-family:-apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; background:#0b1120; color:#e2e8f0; }
                                        body.lpr-modal-open { overflow:hidden; }
                                        .lpr-shell { padding:18px 14px 80px; max-width:1080px; margin:0 auto; }
                                        .lpr-top { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:14px; }
                                        .lpr-user { font-size:14px; color:#cbd5e1; }
                                        h1 { margin:0; font-size:22px; }
                                        .lpr-stats { display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:10px; margin-bottom:14px; }
                                        .lpr-stat { padding:14px; border-radius:14px; background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.08); }
                                        .lpr-stat .label { display:block; color:#cbd5e1; font-size:13px; }
                                        .lpr-stat .value { font-size:22px; font-weight:700; }
                                        .lpr-po-card { background:#0f172a; border:1px solid rgba(255,255,255,0.08); border-radius:16px; margin-bottom:12px; padding:14px; box-shadow:0 14px 30px rgba(0,0,0,0.24); }
                                        .lpr-po-head { display:flex; justify-content:space-between; align-items:flex-start; gap:10px; }
                                        .lpr-po-meta { color:#cbd5e1; font-size:13px; margin:6px 0; display:flex; gap:10px; flex-wrap:wrap; }
                                        .lpr-eta { padding:6px 10px; border-radius:999px; background:rgba(56,189,248,0.12); color:#e0f2fe; font-weight:600; font-size:13px; }
                                        .lpr-badges { display:flex; gap:6px; flex-wrap:wrap; }
                                        .lpr-badge { padding:4px 8px; border-radius:10px; font-size:12px; background:rgba(255,255,255,0.08); color:#cbd5e1; }
                                        .lpr-lines { margin:10px 0; padding:0; list-style:none; }
                                        .lpr-lines li { display:flex; justify-content:space-between; gap:8px; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.06); }
                                        .lpr-lines li:last-child { border-bottom:0; }
                                        .lpr-line-label { flex:1; }
                                        .lpr-actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; }
                                        .lpr-btn { appearance:none; border:none; border-radius:12px; padding:12px 14px; font-weight:700; cursor:pointer; font-size:14px; box-shadow:0 10px 26px rgba(99,102,241,0.28); }
                                        .lpr-btn.primary { background:linear-gradient(120deg,#22d3ee,#6366f1); color:#0f172a; }
                                        .lpr-btn.secondary { background:rgba(255,255,255,0.08); color:#e2e8f0; border:1px solid rgba(255,255,255,0.08); }
                                        .lpr-empty { text-align:center; padding:60px 10px; color:#cbd5e1; }
                                        .lpr-modal { position:fixed; inset:0; display:none; justify-content:center; align-items:flex-start; background:rgba(0,0,0,0.45); z-index:9999; overflow-y:auto; padding:20px 10px; }
                                        .lpr-modal.open { display:flex; }
                                        .lpr-sheet { width:100%; max-width:700px; background:#0b1224; border-radius:18px 18px 0 0; padding:16px; box-shadow:0 -8px 30px rgba(0,0,0,0.35); animation:slideUp .2s ease; max-height:calc(100vh - 40px); overflow-y:auto; margin:auto; }
                                        .lpr-sheet h2 { margin:0 0 8px; font-size:18px; }
                                        .lpr-sheet table { width:100%; border-collapse:collapse; }
                                        .lpr-sheet th, .lpr-sheet td { padding:10px 6px; text-align:left; font-size:13px; color:#e2e8f0; border-bottom:1px solid rgba(255,255,255,0.06); }
                                        .lpr-sheet th.num, .lpr-sheet td.num { text-align:right; white-space:nowrap; }
                                        .lpr-sheet input { width:80px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0f172a; color:#fff; }
                                        .lpr-note { display:none; margin-top:10px; }
                                        .lpr-note.show { display:block; }
                                        .lpr-note label { display:block; margin-bottom:6px; color:#cbd5e1; font-size:13px; }
                                        .lpr-note textarea { width:100%; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:#0f172a; color:#e2e8f0; padding:10px; font-family:inherit; }
                                        .lpr-sheet .status { margin-top:8px; color:#fbbf24; font-size:13px; min-height:20px; }
                                        @keyframes slideUp { from { transform:translateY(30px); opacity:0; } to { transform:translateY(0); opacity:1; } }
                                </style>
                        </head>
                        <body>
                                <div class="lpr-shell" data-token="<?php echo esc_attr( $token ); ?>" data-ajax="<?php echo esc_url( $ajax_url ); ?>">
                                        <div class="lpr-top">
                                                <h1><?php echo esc_html__( 'Incoming POs', 'lpr-backorder-allocator' ); ?></h1>
                                                <span class="lpr-user"><?php echo esc_html( sprintf( __( 'Signed in as %s', 'lpr-backorder-allocator' ), $user ) ); ?></span>
                                        </div>
                                        <div class="lpr-stats">
                                                <div class="lpr-stat"><span class="label"><?php echo esc_html__( 'Open arrivals', 'lpr-backorder-allocator' ); ?></span><span class="value"><?php echo esc_html( self::format_stat( $count ) ); ?></span></div>
                                                <div class="lpr-stat"><span class="label"><?php echo esc_html__( 'Lines to receive', 'lpr-backorder-allocator' ); ?></span><span class="value"><?php echo esc_html( self::format_stat( $line_sum ) ); ?></span></div>
                                                <div class="lpr-stat"><span class="label"><?php echo esc_html__( 'Soonest ETA', 'lpr-backorder-allocator' ); ?></span><span class="value"><?php echo esc_html( $soonest ? self::format_eta_label( $soonest ) : __( 'â€”', 'lpr-backorder-allocator' ) ); ?></span></div>
                                        </div>

                                        <?php if ( empty( $rows ) ) : ?>
                                                <div class="lpr-empty"><?php echo esc_html__( 'No open incoming POs to receive.', 'lpr-backorder-allocator' ); ?></div>
                                        <?php endif; ?>

                                        <?php foreach ( $rows as $row ) :
                                                $totals = $row['totals'] ?? array();
                                                $po_id  = (int) ( $row['po_id'] ?? 0 );
                                                $po_num = (string) ( $row['po_number'] ?? $po_id );
                                                $eta    = isset( $row['eta'] ) ? (string) $row['eta'] : '';
                                                $lines  = (array) ( $row['lines'] ?? array() );
                                                ?>
                                                <div class="lpr-po-card" data-po="<?php echo esc_attr( (string) $po_id ); ?>">
                                                        <div class="lpr-po-head">
                                                                <div>
                                                                        <div class="lpr-badges">
                                                                                <span class="lpr-eta"><?php echo esc_html( sprintf( __( 'ETA %s', 'lpr-backorder-allocator' ), self::format_eta_label( $eta ) ) ); ?></span>
                                                                                <span class="lpr-badge"><?php echo esc_html( sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_num ) ); ?></span>
                                                                        </div>
                                                                        <div class="lpr-po-meta">
                                                                                <?php if ( ! empty( $row['supplier'] ) ) : ?>
                                                                                        <span><?php echo esc_html( sprintf( __( 'Supplier: %s', 'lpr-backorder-allocator' ), (string) $row['supplier'] ) ); ?></span>
                                                                                <?php endif; ?>
                                                                                <?php if ( ! empty( $row['status'] ) ) : ?>
                                                                                        <span><?php echo esc_html( sprintf( __( 'Status: %s', 'lpr-backorder-allocator' ), (string) $row['status'] ) ); ?></span>
                                                                                <?php endif; ?>
                                                                        </div>
                                                                </div>
                                                                <div class="lpr-po-meta" style="text-align:right; flex-direction:column; align-items:flex-end;">
                                                                        <span><?php echo esc_html__( 'Ordered', 'lpr-backorder-allocator' ); ?>: <?php echo esc_html( self::format_stat( (int) ( $totals['ordered'] ?? 0 ) ) ); ?></span>
                                                                        <span><?php echo esc_html__( 'Received', 'lpr-backorder-allocator' ); ?>: <?php echo esc_html( self::format_stat( (int) ( $totals['received'] ?? 0 ) ) ); ?></span>
                                                                        <span><?php echo esc_html__( 'Free', 'lpr-backorder-allocator' ); ?>: <?php echo esc_html( self::format_stat( (int) ( $totals['free'] ?? 0 ) ) ); ?></span>
                                                                </div>
                                                        </div>
                                                        <ul class="lpr-lines">
                                                                <?php foreach ( array_slice( $lines, 0, 4 ) as $line ) : ?>
                                                                        <li>
                                                                                <span class="lpr-line-label"><?php echo esc_html( (string) ( $line['product_label'] ?? '' ) ); ?></span>
                                                                                <span class="num"><?php echo esc_html( sprintf( '%s/%s', self::format_stat( (int) ( $line['received'] ?? 0 ) ), self::format_stat( (int) ( $line['ordered'] ?? 0 ) ) ) ); ?></span>
                                                                        </li>
                                                                <?php endforeach; ?>
                                                        </ul>
                                                        <div class="lpr-actions">
                                                                <button class="lpr-btn primary" data-action="receive" data-po="<?php echo esc_attr( (string) $po_id ); ?>" data-label="<?php echo esc_attr( sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_num ) ); ?>"><?php echo esc_html__( 'Receive', 'lpr-backorder-allocator' ); ?></button>
                                                                <a class="lpr-btn secondary" href="<?php echo esc_url( self::allocation_url( $po_id, $token ) ); ?>"><?php echo esc_html__( 'Allocations', 'lpr-backorder-allocator' ); ?></a>
                                                        </div>
                                                </div>
                                        <?php endforeach; ?>
                                </div>

                                <div class="lpr-modal" id="lpr-receive-modal">
                                        <div class="lpr-sheet">
                                                <h2 id="lpr-receive-title"></h2>
                                                <table>
                                                        <thead>
                                                                <tr>
                                                                        <th><?php echo esc_html__( 'Product', 'lpr-backorder-allocator' ); ?></th>
                                                                        <th class="num"><?php echo esc_html__( 'Ordered', 'lpr-backorder-allocator' ); ?></th>
                                                                        <th class="num"><?php echo esc_html__( 'Received', 'lpr-backorder-allocator' ); ?></th>
                                                                        <th class="num"><?php echo esc_html__( 'Receive', 'lpr-backorder-allocator' ); ?></th>
                                                                </tr>
                                                        </thead>
                                                        <tbody id="lpr-receive-rows"></tbody>
                                                </table>
                                                <div class="status" id="lpr-receive-status"></div>
                                                <div class="lpr-note" id="lpr-receive-note">
                                                        <label for="lpr-receive-note-input"><?php echo esc_html__( 'Optional note', 'lpr-backorder-allocator' ); ?></label>
                                                        <textarea id="lpr-receive-note-input" rows="3" placeholder="<?php echo esc_attr__( 'Add context for this receipt (optional)', 'lpr-backorder-allocator' ); ?>"></textarea>
                                                </div>
                                                <div class="lpr-actions">
                                                        <button class="lpr-btn secondary" id="lpr-cancel-modal"><?php echo esc_html__( 'Cancel', 'lpr-backorder-allocator' ); ?></button>
                                                        <button class="lpr-btn primary" id="lpr-submit-receive" data-label-apply="<?php echo esc_attr__( 'Apply receipt', 'lpr-backorder-allocator' ); ?>" data-label-confirm="<?php echo esc_attr__( 'Confirm and send', 'lpr-backorder-allocator' ); ?>"><?php echo esc_html__( 'Apply receipt', 'lpr-backorder-allocator' ); ?></button>
                                                </div>
                                        </div>
                                </div>

                                <script>
                                (function(){
                                        var shell = document.querySelector('.lpr-shell');
                                        if(!shell){ return; }
                                        var token = shell.getAttribute('data-token') || '';
                                        var ajaxUrl = shell.getAttribute('data-ajax');
                                        var modal = document.getElementById('lpr-receive-modal');
                                        var rowsEl = document.getElementById('lpr-receive-rows');
                                        var statusEl = document.getElementById('lpr-receive-status');
                                        var titleEl = document.getElementById('lpr-receive-title');
                                        var submitBtn = document.getElementById('lpr-submit-receive');
                                        var noteWrap = document.getElementById('lpr-receive-note');
                                        var noteInput = document.getElementById('lpr-receive-note-input');
                                        var activePo = null;
                                        var confirmingSubmit = false;

                                        function openModal(poId, label){
                                                activePo = poId;
                                                titleEl.textContent = label;
                                                statusEl.textContent = '';
                                                confirmingSubmit = false;
                                                if(noteWrap){ noteWrap.classList.remove('show'); }
                                                if(noteInput){ noteInput.value = ''; }
                                                if(submitBtn && submitBtn.getAttribute('data-label-apply')){
                                                        submitBtn.textContent = submitBtn.getAttribute('data-label-apply');
                                                }
                                                rowsEl.innerHTML = '<tr><td colspan="4"><?php echo esc_js( __( 'Loadingâ€¦', 'lpr-backorder-allocator' ) ); ?></td></tr>';
                                                modal.classList.add('open');
                                                document.body.classList.add('lpr-modal-open');

                                                var body = new URLSearchParams();
                                                body.append('action','lpr_po_receive_lines');
                                                body.append('po_id', poId);
                                                body.append('incoming_token', token);

                                                fetch(ajaxUrl,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:body.toString()})
                                                        .then(function(r){ return r.json(); })
                                                        .then(function(resp){
                                                                if(!resp || !resp.success){
                                                                        statusEl.textContent = (resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to load lines.', 'lpr-backorder-allocator' ) ); ?>';
                                                                        return;
                                                                }
                                                                var lines = (resp.data && resp.data.lines) ? resp.data.lines : [];
                                                                if(!lines.length){
                                                                        rowsEl.innerHTML = '<tr><td colspan="4"><?php echo esc_js( __( 'All lines received.', 'lpr-backorder-allocator' ) ); ?></td></tr>';
                                                                        return;
                                                                }
                                                                rowsEl.innerHTML = '';
                                                                lines.forEach(function(line){
                                                                        var tr = document.createElement('tr');
                                                                        tr.innerHTML = '<td>'+line.product+'</td>' +
                                                                                '<td class="num">'+line.ordered+'</td>' +
                                                                                '<td class="num">'+line.received+'</td>' +
                                                                                '<td class="num"><input type="number" min="0" max="'+line.remaining+'" value="'+line.remaining+'" data-idx="'+line.idx+'" /></td>';
                                                                        rowsEl.appendChild(tr);
                                                                });
                                                        }).catch(function(){ statusEl.textContent = '<?php echo esc_js( __( 'Unable to load lines.', 'lpr-backorder-allocator' ) ); ?>'; });
                                        }

                                        function closeModal(){
                                                modal.classList.remove('open');
                                                document.body.classList.remove('lpr-modal-open');
                                                activePo = null;
                                                confirmingSubmit = false;
                                                if(noteWrap){ noteWrap.classList.remove('show'); }
                                                if(submitBtn && submitBtn.getAttribute('data-label-apply')){
                                                        submitBtn.textContent = submitBtn.getAttribute('data-label-apply');
                                                }
                                        }

                                        document.querySelectorAll('[data-action="receive"]').forEach(function(btn){
                                                btn.addEventListener('click', function(){
                                                        openModal(this.getAttribute('data-po'), this.getAttribute('data-label'));
                                                });
                                        });

                                        document.getElementById('lpr-cancel-modal').addEventListener('click', closeModal);
                                        modal.addEventListener('click', function(e){ if(e.target === modal){ closeModal(); } });

                                        document.getElementById('lpr-submit-receive').addEventListener('click', function(){
                                                if(!activePo){ return; }
                                                if(!confirmingSubmit){
                                                        confirmingSubmit = true;
                                                        if(noteWrap){ noteWrap.classList.add('show'); }
                                                        if(submitBtn && submitBtn.getAttribute('data-label-confirm')){
                                                                submitBtn.textContent = submitBtn.getAttribute('data-label-confirm');
                                                        }
                                                        statusEl.textContent = '<?php echo esc_js( __( 'Add an optional note, then confirm to queue the receipt.', 'lpr-backorder-allocator' ) ); ?>';
                                                        if(noteInput){ noteInput.focus(); }
                                                        return;
                                                }
                                                statusEl.textContent = '<?php echo esc_js( __( 'Savingâ€¦', 'lpr-backorder-allocator' ) ); ?>';
                                                var payload = new URLSearchParams();
                                                payload.append('action','lpr_po_receive_apply');
                                                payload.append('po_id', activePo);
                                                payload.append('incoming_token', token);

                                                rowsEl.querySelectorAll('input[data-idx]').forEach(function(input){
                                                        var val = parseInt(input.value,10);
                                                        if(isNaN(val) || val <= 0){ return; }
                                                        payload.append('lines['+input.getAttribute('data-idx')+']', val);
                                                });

                                                if(noteInput && noteInput.value){
                                                        payload.append('note', noteInput.value);
                                                }

                                                fetch(ajaxUrl,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:payload.toString()})
                                                        .then(function(r){ return r.json(); })
                                                        .then(function(resp){
                                                                if(!resp || !resp.success){
                                                                        statusEl.textContent = (resp && resp.data && resp.data.message) ? resp.data.message : '<?php echo esc_js( __( 'Unable to apply receipt.', 'lpr-backorder-allocator' ) ); ?>';
                                                                        return;
                                                                }
                                                                if(resp.data && resp.data.redirect){
                                                                        window.location = resp.data.redirect;
                                                                        return;
                                                                }
                                                                statusEl.textContent = resp.data && resp.data.message ? resp.data.message : '<?php echo esc_js( __( 'Receipt queued.', 'lpr-backorder-allocator' ) ); ?>';
                                                                closeModal();
                                                                window.location.reload();
                                                        }).catch(function(){ statusEl.textContent = '<?php echo esc_js( __( 'Unable to apply receipt.', 'lpr-backorder-allocator' ) ); ?>'; });
                                        });
                                })();
                                </script>
                        </body>
                        </html>
                        <?php
                }

                protected static function render_product_lookup( string $user, string $token ): void {
                        $ajax_url = admin_url( 'admin-ajax.php' );
                        ?>
                        <!DOCTYPE html>
                        <html <?php language_attributes(); ?>>
                        <head>
                                <meta charset="<?php bloginfo( 'charset' ); ?>" />
                                <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
                                <title><?php echo esc_html__( 'Product lookup', 'lpr-backorder-allocator' ); ?></title>
                                <style>
                                        body { margin:0; padding:0; font-family:-apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; background:#0b1120; color:#e2e8f0; }
                                        .lpr-shell { padding:18px 14px 60px; max-width:1100px; margin:0 auto; }
                                        .lpr-top { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px; }
                                        .lpr-back { color:#cbd5e1; text-decoration:none; font-weight:600; }
                                        h1 { margin:6px 0 14px; font-size:22px; }
                                        .lpr-user { font-size:14px; color:#cbd5e1; }
                                        .lpr-search { position:sticky; top:0; padding:6px 0 12px; background:#0b1120; z-index:2; }
                                        .lpr-search input { width:100%; padding:14px 16px; border-radius:14px; border:1px solid rgba(255,255,255,0.08); background:#0f172a; color:#e2e8f0; font-size:16px; box-shadow:0 12px 30px rgba(0,0,0,0.25); }
                                        .lpr-search input:focus { outline:2px solid #38bdf8; border-color:#38bdf8; }
                                        .lpr-product-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(190px,1fr)); gap:10px; margin:10px 0 16px; }
                                        .lpr-product-card { background:#0f172a; border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:10px; text-align:left; color:#e2e8f0; display:flex; flex-direction:column; gap:8px; box-shadow:0 14px 28px rgba(0,0,0,0.22); cursor:pointer; transition:transform .08s ease, border-color .08s ease; }
                                        .lpr-product-card:hover { transform:translateY(-2px); border-color:#38bdf8; }
                                        .lpr-product-card img { width:100%; aspect-ratio:4/3; object-fit:cover; border-radius:10px; background:#111827; }
                                        .lpr-product-name { font-weight:700; font-size:15px; }
                                        .lpr-product-sku { color:#94a3b8; font-size:12px; }
                                        .lpr-product-meta { display:flex; justify-content:space-between; align-items:center; font-size:12px; color:#cbd5e1; }
                                        .lpr-pill { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:10px; background:rgba(56,189,248,0.14); color:#e0f2fe; font-size:12px; }
                                        .lpr-detail { background:#0f172a; border:1px solid rgba(255,255,255,0.08); border-radius:16px; padding:16px; box-shadow:0 16px 34px rgba(0,0,0,0.26); }
                                        .lpr-detail h2 { margin:0 0 6px; font-size:18px; }
                                        .lpr-detail .sku { color:#94a3b8; font-size:13px; margin-bottom:10px; }
                                        .lpr-detail-stats { display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:10px; margin:12px 0; }
                                        .lpr-stat { padding:12px; border-radius:12px; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); }
                                        .lpr-stat .label { display:block; color:#94a3b8; font-size:12px; }
                                        .lpr-stat .value { font-size:18px; font-weight:700; }
                                        .lpr-incoming-list { list-style:none; margin:12px 0 0; padding:0; display:flex; flex-direction:column; gap:10px; }
                                        .lpr-incoming-row { border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px 12px; background:rgba(255,255,255,0.02); display:flex; justify-content:space-between; gap:10px; align-items:center; }
                                        .lpr-incoming-meta { display:flex; flex-direction:column; gap:4px; }
                                        .lpr-incoming-meta .eta { color:#cbd5e1; font-size:13px; }
                                        .lpr-incoming-meta .po { color:#94a3b8; font-size:12px; }
                                        .lpr-incoming-qty { text-align:right; }
                                        .lpr-empty { text-align:center; padding:32px 10px; color:#94a3b8; }
                                        .lpr-note { color:#cbd5e1; font-size:13px; margin-top:8px; }
                                        @media (max-width:560px) {
                                                .lpr-product-grid { grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); }
                                        }
                                </style>
                        </head>
                        <body>
                                <div class="lpr-shell" data-token="<?php echo esc_attr( $token ); ?>" data-ajax="<?php echo esc_url( $ajax_url ); ?>">
                                        <div class="lpr-top">
                                                <a class="lpr-back" href="<?php echo esc_url( home_url( '/incoming' ) ); ?>">&larr; <?php echo esc_html__( 'Start', 'lpr-backorder-allocator' ); ?></a>
                                                <span class="lpr-user"><?php echo esc_html( sprintf( __( 'Signed in as %s', 'lpr-backorder-allocator' ), $user ) ); ?></span>
                                        </div>
                                        <h1><?php echo esc_html__( 'Product lookup', 'lpr-backorder-allocator' ); ?></h1>
                                        <div class="lpr-search">
                                                <label class="screen-reader-text" for="lpr-product-search"><?php echo esc_html__( 'Search products', 'lpr-backorder-allocator' ); ?></label>
                                                <input id="lpr-product-search" type="search" placeholder="<?php echo esc_attr__( 'Search SKU or nameâ€¦', 'lpr-backorder-allocator' ); ?>" autocomplete="off" />
                                        </div>
                                        <div id="lpr-product-results" class="lpr-product-grid" aria-live="polite"></div>
                                        <div id="lpr-product-empty" class="lpr-empty" style="display:none;"><?php echo esc_html__( 'No products found.', 'lpr-backorder-allocator' ); ?></div>
                                        <div id="lpr-product-detail" class="lpr-detail" aria-live="polite" role="status"></div>
                                </div>

                                <script>
                                (function(){
                                        var shell = document.querySelector('.lpr-shell');
                                        if(!shell){ return; }
                                        var ajaxUrl = shell.getAttribute('data-ajax');
                                        var token = shell.getAttribute('data-token') || '';
                                        var searchInput = document.getElementById('lpr-product-search');
                                        var resultsEl = document.getElementById('lpr-product-results');
                                        var emptyEl = document.getElementById('lpr-product-empty');
                                        var detailEl = document.getElementById('lpr-product-detail');
                                        var searchTimer = null;
                                        var controller = null;

                                        function numberFmt(val){
                                                return new Intl.NumberFormat().format(val || 0);
                                        }

                                        function renderResults(items){
                                                resultsEl.innerHTML = '';
                                                if(!items.length){
                                                        emptyEl.style.display = 'block';
                                                        return;
                                                }
                                                emptyEl.style.display = 'none';
                                                items.forEach(function(item){
                                                        var btn = document.createElement('button');
                                                        btn.type = 'button';
                                                        btn.className = 'lpr-product-card';
                                                        btn.setAttribute('data-id', item.id);
                                                        btn.innerHTML = '<img src="'+(item.image || '')+'" alt="" loading="lazy" />' +
                                                                '<div class="lpr-product-name">'+item.name+'</div>' +
                                                                '<div class="lpr-product-sku">'+(item.sku || '<?php echo esc_js( __( 'No SKU', 'lpr-backorder-allocator' ) ); ?>')+'</div>' +
                                                                '<div class="lpr-product-meta">'+
                                                                        '<span class="lpr-pill">'+(item.next_eta || '<?php echo esc_js( __( 'No ETA', 'lpr-backorder-allocator' ) ); ?>')+'</span>'+
                                                                        '<span>'+numberFmt(item.incoming_total || 0)+' <?php echo esc_js( __( 'incoming', 'lpr-backorder-allocator' ) ); ?></span>'+
                                                                '</div>';
                                                        btn.addEventListener('click', function(){ loadDetail(item.id); });
                                                        resultsEl.appendChild(btn);
                                                });
                                        }

                                        function renderDetail(data){
                                                if(!data){
                                                        detailEl.innerHTML = '';
                                                        return;
                                                }
                                                var incomingRows = '';
                                                if(data.incoming_pos && data.incoming_pos.length){
                                                        data.incoming_pos.forEach(function(row){
                                                                incomingRows += '<li class="lpr-incoming-row">' +
                                                                        '<div class="lpr-incoming-meta">'+
                                                                                '<span class="eta">'+(row.eta_label || '<?php echo esc_js( __( 'No ETA', 'lpr-backorder-allocator' ) ); ?>')+'</span>'+
                                                                                '<span class="po">'+(row.po_label || '')+'</span>'+
                                                                        '</div>'+
                                                                        '<div class="lpr-incoming-qty">'+
                                                                                '<div class="label">'+numberFmt(row.qty_free)+' <?php echo esc_js( __( 'free', 'lpr-backorder-allocator' ) ); ?></div>'+
                                                                                '<div class="label" style="color:#94a3b8;font-size:12px;">'+numberFmt(row.qty_ordered)+' <?php echo esc_js( __( 'ordered', 'lpr-backorder-allocator' ) ); ?></div>'+
                                                                        '</div>'+
                                                                '</li>';
                                                        });
                                                } else {
                                                        incomingRows = '<li class="lpr-empty" style="padding:14px 0;"><?php echo esc_js( __( 'No open incoming POs for this product.', 'lpr-backorder-allocator' ) ); ?></li>';
                                                }

                                                var nextNote = '';
                                                if(data.next_free_eta && data.next_free_qty){
                                                        nextNote = '<div class="lpr-note">'+ '<?php echo esc_js( __( 'Next free stock arrives', 'lpr-backorder-allocator' ) ); ?>' + ' ' + data.next_free_eta + ' Â· ' + numberFmt(data.next_free_qty) + '</div>';
                                                }

                                                detailEl.innerHTML = '<div class="lpr-detail-card">'+
                                                        '<h2>'+data.name+'</h2>'+
                                                        '<div class="sku">'+(data.sku || '<?php echo esc_js( __( 'No SKU available', 'lpr-backorder-allocator' ) ); ?>')+'</div>'+
                                                        '<div class="lpr-detail-stats">'+
                                                                '<div class="lpr-stat"><span class="label"><?php echo esc_js( __( 'On hand', 'lpr-backorder-allocator' ) ); ?></span><span class="value">'+numberFmt(data.stock)+'</span></div>'+
                                                                '<div class="lpr-stat"><span class="label"><?php echo esc_js( __( 'Total incoming', 'lpr-backorder-allocator' ) ); ?></span><span class="value">'+numberFmt(data.incoming_total)+'</span></div>'+
                                                                '<div class="lpr-stat"><span class="label"><?php echo esc_js( __( 'Allocated', 'lpr-backorder-allocator' ) ); ?></span><span class="value">'+numberFmt(data.allocated_total)+'</span></div>'+
                                                        '</div>'+
                                                        nextNote +
                                                        '<ul class="lpr-incoming-list">'+incomingRows+'</ul>'+
                                                '</div>';
                                        }

                                        function loadDetail(id){
                                                if(!ajaxUrl){ return; }
                                                var body = new URLSearchParams();
                                                body.append('action','lpr_incoming_product_details');
                                                body.append('product_id', id);
                                                body.append('incoming_token', token);
                                                fetch(ajaxUrl,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:body.toString()})
                                                        .then(function(r){ return r.json(); })
                                                        .then(function(resp){
                                                                if(!resp || !resp.success){ return; }
                                                                renderDetail(resp.data);
                                                        }).catch(function(){});
                                        }

                                        function performSearch(term){
                                                if(!ajaxUrl){ return; }
                                                if(controller){ controller.abort(); }
                                                controller = new AbortController();
                                                var body = new URLSearchParams();
                                                body.append('action','lpr_incoming_product_search');
                                                body.append('term', term || '');
                                                body.append('incoming_token', token);
                                                fetch(ajaxUrl,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:body.toString(),signal:controller.signal})
                                                        .then(function(r){ return r.json(); })
                                                        .then(function(resp){
                                                                if(!resp || !resp.success){ return; }
                                                                renderResults(resp.data && resp.data.results ? resp.data.results : []);
                                                        }).catch(function(err){ if(err && err.name === 'AbortError'){ return; } });
                                        }

                                        if(searchInput){
                                                searchInput.addEventListener('input', function(){
                                                        var term = this.value || '';
                                                        if(searchTimer){ window.clearTimeout(searchTimer); }
                                                        searchTimer = window.setTimeout(function(){ performSearch(term); }, 120);
                                                });
                                                performSearch('');
                                        }
                                })();
                                </script>
                        </body>
                        </html>
                        <?php
                }

                protected static function product_image_url( \WC_Product $product ): string {
                        $image_id = $product->get_image_id();
                        if ( $product->is_type( 'variation' ) && ! $image_id ) {
                                $parent = wc_get_product( $product->get_parent_id() );
                                $image_id = $parent instanceof \WC_Product ? $parent->get_image_id() : 0;
                        }

                        $src = $image_id ? wp_get_attachment_image_url( $image_id, 'medium' ) : '';
                        if ( ! $src ) {
                                $src = wc_placeholder_img_src();
                        }

                        return (string) $src;
                }

                protected static function next_eta_for_product( int $product_id ): string {
                        $details = class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ? Incoming_Stock_Indexer::get_product_details( $product_id ) : array();
                        foreach ( $details as $row ) {
                                $eta = isset( $row['eta'] ) ? (string) $row['eta'] : '';
                                if ( '' !== $eta ) {
                                        return self::format_eta_label( $eta );
                                }
                        }

                        return __( 'No ETA', 'lpr-backorder-allocator' );
                }

                public static function ajax_product_search(): void {
                        if ( ! self::authorize_token_request() ) {
                                wp_send_json_error( array( 'message' => __( 'Unauthorized.', 'lpr-backorder-allocator' ) ) );
                        }

                        $term = isset( $_POST['term'] ) ? sanitize_text_field( wp_unslash( $_POST['term'] ) ) : '';

                        $args = array(
                                'status'   => array( 'publish', 'private' ),
                                'limit'    => 24,
                                'paginate' => false,
                                'return'   => 'ids',
                                'orderby'  => 'title',
                                'order'    => 'ASC',
                        );

                        if ( '' !== $term ) {
                                $args['s']   = $term;
                                $args['sku'] = $term;
                        }

                        $products = function_exists( 'wc_get_products' ) ? wc_get_products( $args ) : array();
                        $results  = array();

                        foreach ( $products as $product_id ) {
                                $product = function_exists( 'wc_get_product' ) ? wc_get_product( $product_id ) : null;
                                if ( ! ( $product instanceof \WC_Product ) ) {
                                        continue;
                                }

                                $incoming_total = (int) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL' ) ? PRODUCT_META_INCOMING_TOTAL : '_lpr_incoming_po_total', true );

                                $results[] = array(
                                        'id'             => (int) $product_id,
                                        'name'           => $product->get_name(),
                                        'sku'            => (string) $product->get_sku(),
                                        'image'          => self::product_image_url( $product ),
                                        'incoming_total' => $incoming_total,
                                        'next_eta'       => self::next_eta_for_product( (int) $product_id ),
                                );
                        }

                        wp_send_json_success( array( 'results' => $results ) );
                }

                public static function ajax_product_details(): void {
                        if ( ! self::authorize_token_request() ) {
                                wp_send_json_error( array( 'message' => __( 'Unauthorized.', 'lpr-backorder-allocator' ) ) );
                        }

                        $product_id = isset( $_POST['product_id'] ) ? absint( $_POST['product_id'] ) : 0;
                        if ( $product_id <= 0 ) {
                                wp_send_json_error( array( 'message' => __( 'Product not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        $product = function_exists( 'wc_get_product' ) ? wc_get_product( $product_id ) : null;
                        if ( ! ( $product instanceof \WC_Product ) ) {
                                wp_send_json_error( array( 'message' => __( 'Product not found.', 'lpr-backorder-allocator' ) ) );
                        }

                        $incoming_total = (int) get_post_meta( $product_id, defined( __NAMESPACE__ . '\PRODUCT_META_INCOMING_TOTAL' ) ? PRODUCT_META_INCOMING_TOTAL : '_lpr_incoming_po_total', true );
                        $details        = class_exists( __NAMESPACE__ . '\Incoming_Stock_Indexer' ) ? Incoming_Stock_Indexer::get_product_details( $product_id ) : array();

                        $incoming_pos   = array();
                        $total_free     = 0;
                        $next_free_eta  = '';
                        $next_free_qty  = 0;

                        foreach ( $details as $row ) {
                                $eta        = isset( $row['eta'] ) ? (string) $row['eta'] : '';
                                $qty_free   = max( 0, (int) ( $row['qty_free'] ?? 0 ) );
                                $qty_order  = max( 0, (int) ( $row['qty_ordered'] ?? 0 ) );
                                $po_number  = isset( $row['po_number'] ) && '' !== (string) $row['po_number'] ? (string) $row['po_number'] : (string) ( $row['po_id'] ?? '' );

                                $incoming_pos[] = array(
                                        'po_id'       => (int) ( $row['po_id'] ?? 0 ),
                                        'po_label'    => sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_number ),
                                        'eta'         => $eta,
                                        'eta_label'   => $eta ? self::format_eta_label( $eta ) : __( 'No ETA', 'lpr-backorder-allocator' ),
                                        'qty_free'    => $qty_free,
                                        'qty_ordered' => $qty_order,
                                );

                                $total_free += $qty_free;
                                if ( $qty_free > 0 && ( '' === $next_free_eta || ( $eta && lpr_allocator_compare_dates( $eta, $next_free_eta ) < 0 ) ) ) {
                                        $next_free_eta = $eta;
                                        $next_free_qty = $qty_free;
                                }
                        }

                        $allocated_total = max( 0, $incoming_total - $total_free );
                        $stock_qty       = $product->get_stock_quantity();

                        wp_send_json_success(
                                array(
                                        'product_id'      => $product_id,
                                        'name'            => $product->get_name(),
                                        'sku'             => (string) $product->get_sku(),
                                        'image'           => self::product_image_url( $product ),
                                        'stock'           => function_exists( 'wc_stock_amount' ) ? wc_stock_amount( $stock_qty ) : (int) $stock_qty,
                                        'stock_status'    => (string) $product->get_stock_status(),
                                        'incoming_total'  => $incoming_total,
                                        'allocated_total' => $allocated_total,
                                        'incoming_pos'    => $incoming_pos,
                                        'next_free_eta'   => $next_free_eta ? self::format_eta_label( $next_free_eta ) : '',
                                        'next_free_qty'   => (int) $next_free_qty,
                                )
                        );
                }


                protected static function render_allocations_page( string $user, string $token, int $po_id ): void {
                        $raw_rows = class_exists( __NAMESPACE__ . '\PO_Allocation_Overview' ) ? PO_Allocation_Overview::collect_rows( $po_id ) : array();

                        $grouped = array();

                        foreach ( $raw_rows as $row ) {
                                $order_id = isset( $row['order_id'] ) ? absint( $row['order_id'] ) : 0;
                                $key      = $order_id ? 'order-' . $order_id : md5( maybe_serialize( $row ) );

                                if ( ! isset( $grouped[ $key ] ) ) {
                                        $grouped[ $key ] = array(
                                                'order_id'     => $order_id,
                                                'order_number' => (string) ( $row['order_number'] ?? '' ),
                                                'order_url'    => (string) ( $row['order_url'] ?? '' ),
                                                'customer'     => (string) ( $row['customer'] ?? '' ),
                                                'status'       => (string) ( $row['status'] ?? '' ),
                                                'lines'        => array(),
                                                'ready_flags'  => array(),
                                        );
                                }

                                $grouped[ $key ]['lines'][] = array(
                                        'product' => (string) ( $row['product'] ?? '' ),
                                        'qty'     => (int) ( $row['qty'] ?? 0 ),
                                        'eta'     => (string) ( $row['eta'] ?? '' ),
                                );

                                $grouped[ $key ]['ready_flags'][] = $row['ready'] ?? null;
                        }

                        $rows    = array_values( $grouped );
                        foreach ( $rows as &$row ) {
                                $flags = (array) ( $row['ready_flags'] ?? array() );
                                $ready = null;

                                foreach ( $flags as $flag ) {
                                        if ( false === $flag ) {
                                                $ready = false;
                                                break;
                                        }

                                        if ( true === $flag && null === $ready ) {
                                                $ready = true;
                                        }

                                        if ( null === $flag && true === $ready ) {
                                                $ready = null;
                                        }
                                }

                                $row['ready'] = $ready;
                                unset( $row['ready_flags'] );
                        }
                        unset( $row );
                        $po_label = sprintf( __( 'PO #%s', 'lpr-backorder-allocator' ), $po_id );
                        $eta      = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
                        $eta_lbl  = $eta ? self::format_eta_label( $eta ) : __( 'No ETA', 'lpr-backorder-allocator' );
                        ?>
                        <!DOCTYPE html>
                        <html <?php language_attributes(); ?>>
                        <head>
                                <meta charset="<?php bloginfo( 'charset' ); ?>" />
                                <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
                                <title><?php echo esc_html__( 'PO Allocations', 'lpr-backorder-allocator' ); ?></title>
                                <style>
                                        body { margin:0; padding:0; font-family:-apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; background:#0b1120; color:#e2e8f0; }
                                        .lpr-shell { padding:18px 14px 40px; max-width:960px; margin:0 auto; }
                                        h1 { margin:0 0 6px; font-size:22px; }
                                        .lpr-user { color:#cbd5e1; font-size:13px; }
                                        .lpr-meta { margin:6px 0 14px; color:#cbd5e1; font-size:14px; display:flex; gap:10px; flex-wrap:wrap; }
                                        .lpr-card { background:#0f172a; border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:14px; margin-bottom:12px; box-shadow:0 10px 26px rgba(0,0,0,0.24); }
                                        .lpr-card h3 { margin:0 0 6px; font-size:16px; }
                                        .lpr-card .meta { color:#cbd5e1; font-size:13px; margin-bottom:8px; }
                                        .lpr-badge { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; }
                                        .lpr-badge.ready { background:rgba(74,222,128,0.16); color:#bbf7d0; border:1px solid rgba(74,222,128,0.28); }
                                        .lpr-badge.not-ready { background:rgba(248,113,113,0.16); color:#fecdd3; border:1px solid rgba(248,113,113,0.28); }
                                        .lpr-badge.unknown { background:rgba(148,163,184,0.16); color:#e2e8f0; border:1px solid rgba(148,163,184,0.28); }
                                        .lpr-card table { width:100%; border-collapse:collapse; }
                                        .lpr-card th, .lpr-card td { padding:8px 6px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.06); font-size:13px; }
                                        .lpr-card th.num, .lpr-card td.num { text-align:right; white-space:nowrap; }
                                        .lpr-actions { display:flex; gap:10px; margin-top:12px; }
                                        .lpr-btn { appearance:none; border:none; border-radius:12px; padding:10px 12px; font-weight:700; cursor:pointer; font-size:14px; }
                                        .lpr-btn.primary { background:linear-gradient(120deg,#22d3ee,#6366f1); color:#0f172a; }
                                        .lpr-btn.secondary { background:rgba(255,255,255,0.08); color:#e2e8f0; border:1px solid rgba(255,255,255,0.08); text-decoration:none; display:inline-block; }
                                </style>
                        </head>
                        <body>
                                <div class="lpr-shell">
                                        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
                                                <div>
                                                        <h1><?php echo esc_html( $po_label ); ?></h1>
                                                        <div class="lpr-meta">
                                                                <span><?php echo esc_html( sprintf( __( 'ETA %s', 'lpr-backorder-allocator' ), $eta_lbl ) ); ?></span>
                                                                <span class="lpr-user"><?php echo esc_html( sprintf( __( 'Signed in as %s', 'lpr-backorder-allocator' ), $user ) ); ?></span>
                                                        </div>
                                                </div>
                                                <a class="lpr-btn secondary" href="<?php echo esc_url( home_url( '/incoming' ) ); ?>">&larr; <?php echo esc_html__( 'Incoming', 'lpr-backorder-allocator' ); ?></a>
                                        </div>

                                        <?php if ( empty( $rows ) ) : ?>
                                                <div class="lpr-card"><?php echo esc_html__( 'No allocations found for this PO yet.', 'lpr-backorder-allocator' ); ?></div>
                                        <?php endif; ?>

                                        <?php foreach ( $rows as $row ) :
                                                $order_number = (string) ( $row['order_number'] ?? '' );
                                                $customer     = (string) ( $row['customer'] ?? '' );
                                                $order_label  = $order_number ? sprintf( __( 'Order #%s', 'lpr-backorder-allocator' ), $order_number ) : __( 'Order', 'lpr-backorder-allocator' );
                                                if ( $customer ) {
                                                        $order_label .= ' â€” ' . $customer;
                                                }

                                                $order_link = ! empty( $row['order_url'] ) ? '<a href="' . esc_url( (string) $row['order_url'] ) . '">' . esc_html( $order_label ) . '</a>' : esc_html( $order_label );
                                                $status     = (string) ( $row['status'] ?? '' );
                                                $ready      = $row['ready'] ?? null;
                                                ?>
                                                <div class="lpr-card">
                                                        <h3><?php echo wp_kses_post( $order_link ); ?></h3>
                                                        <div class="meta">
                                                                <span><?php echo esc_html( $status ); ?></span>
                                                                <?php if ( true === $ready ) : ?>
                                                                        <span class="lpr-badge ready">âœ… <?php echo esc_html__( 'Ready on arrival', 'lpr-backorder-allocator' ); ?></span>
                                                                <?php elseif ( false === $ready ) : ?>
                                                                        <span class="lpr-badge not-ready">âš ï¸ <?php echo esc_html__( 'Not fully allocated by ETA', 'lpr-backorder-allocator' ); ?></span>
                                                                <?php else : ?>
                                                                        <span class="lpr-badge unknown">âž– <?php echo esc_html__( 'Readiness unknown', 'lpr-backorder-allocator' ); ?></span>
                                                                <?php endif; ?>
                                                        </div>
                                                        <table>
                                                                <thead>
                                                                        <tr>
                                                                                <th><?php echo esc_html__( 'Product', 'lpr-backorder-allocator' ); ?></th>
                                                                                <th class="num"><?php echo esc_html__( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
                                                                                <th class="num"><?php echo esc_html__( 'ETA', 'lpr-backorder-allocator' ); ?></th>
                                                                        </tr>
                                                                </thead>
                                                                <tbody>
                                                                        <?php foreach ( (array) ( $row['lines'] ?? array() ) as $line ) : ?>
                                                                                <tr>
                                                                                        <td><?php echo esc_html( (string) ( $line['product'] ?? '' ) ); ?></td>
                                                                                        <td class="num"><?php echo esc_html( self::format_stat( (int) ( $line['qty'] ?? 0 ) ) ); ?></td>
                                                                                        <td class="num"><?php echo esc_html( ! empty( $line['eta'] ) ? self::format_eta_label( (string) $line['eta'] ) : 'â€”' ); ?></td>
                                                                                </tr>
                                                                        <?php endforeach; ?>
                                                                </tbody>
                                                        </table>
                                                </div>
                                        <?php endforeach; ?>
                                </div>
                        </body>
                        </html>
                        <?php
                }
        }
        Incoming_Mobile_Inbox::init();
}

/**
 * Admin-post handler: quick add a product to the current user's PO draft.
 */
if ( ! class_exists( __NAMESPACE__ . '\Quick_PO_Add_Handler' ) ) {
	class Quick_PO_Add_Handler {

		public static function init(): void {
			add_action( 'admin_post_lpr_quick_add_to_po', array( __CLASS__, 'handle' ) );
		}

		public static function handle(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			if ( ! isset( $_POST['lpr_quick_nonce'] ) || ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_quick_nonce'] ) ), 'lpr_quick_add_to_po' ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}

			$product_id = isset( $_POST['product_id'] ) ? absint( $_POST['product_id'] ) : 0;
			$qty        = isset( $_POST['qty'] ) ? max( 1, (int) $_POST['qty'] ) : 1;
			$supplier   = isset( $_POST['supplier_name'] ) ? sanitize_text_field( wp_unslash( $_POST['supplier_name'] ) ) : '';
			$eta_raw    = isset( $_POST['eta_ymd'] ) ? (string) wp_unslash( $_POST['eta_ymd'] ) : '';
			$eta_ymd    = lpr_allocator_sanitize_ymd( $eta_raw );
			$redirect   = isset( $_POST['redirect'] ) ? esc_url_raw( wp_unslash( $_POST['redirect'] ) ) : admin_url( 'admin.php?page=lpr-backordered-products' );

			if ( $product_id <= 0 || ! lpr_allocator_product_exists( $product_id ) ) {
				wp_safe_redirect( add_query_arg( array( 'lpr_added' => '0' ), $redirect ) );
				exit;
			}

			$po_id = lpr_allocator_get_or_create_quick_po_for_user( $supplier, $eta_ymd, '' );
			if ( $po_id <= 0 ) {
				wp_safe_redirect( add_query_arg( array( 'lpr_added' => '0' ), $redirect ) );
				exit;
			}

			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) ) {
				$lines = array();
			}

			// Determine whether the product is a variation.
			$is_variation = false;
			if ( function_exists( 'wc_get_product' ) ) {
				$p = wc_get_product( $product_id );
				$is_variation = ( $p instanceof \WC_Product ) ? $p->is_type( 'variation' ) : false;
			}

			// Try to merge with an existing line of the same product/variation.
			$merged = false;
			foreach ( $lines as &$line ) {
				$line_vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
				$line_pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;

				if ( $is_variation ) {
					if ( $line_vid === $product_id ) {
						$line['qty_ordered']   = max( 0, (int) ( $line['qty_ordered'] ?? 0 ) ) + $qty;
						$line['qty_allocated'] = max( 0, (int) ( $line['qty_allocated'] ?? 0 ) );
						if ( $eta_ymd ) {
							$line['eta_override'] = $eta_ymd;
						}
						$line['qty_received']  = max( 0, (int) ( $line['qty_received'] ?? 0 ) );
						$merged = true;
						break;
					}
				} else {
					if ( $line_vid === 0 && $line_pid === $product_id ) {
						$line['qty_ordered']   = max( 0, (int) ( $line['qty_ordered'] ?? 0 ) ) + $qty;
						$line['qty_allocated'] = max( 0, (int) ( $line['qty_allocated'] ?? 0 ) );
						if ( $eta_ymd ) {
							$line['eta_override'] = $eta_ymd;
						}
						$line['qty_received']  = max( 0, (int) ( $line['qty_received'] ?? 0 ) );
						$merged = true;
						break;
					}
				}
			}
			unset( $line );

			if ( ! $merged ) {
				$new = array(
					'qty_ordered'   => (int) $qty,
					'qty_allocated' => 0,
					'eta_override'  => $eta_ymd,
					'qty_received'  => 0,
				);
				if ( $is_variation ) {
					$new['variation_id'] = (int) $product_id;
				} else {
					$new['product_id'] = (int) $product_id;
				}
				$lines[] = $new;
			}

			update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );

			wp_safe_redirect( add_query_arg( array( 'lpr_added' => '1', 'po_id' => (int) $po_id ), $redirect ) );
			exit;
		}
	}
	Quick_PO_Add_Handler::init();
}

/* SELF-CHECK:
- Added: helper functions lpr_allocator_calc_backorder_desired(), lpr_allocator_get_item_allocated_active(), lpr_allocator_get_or_create_quick_po_for_user() â€” all guarded; no re-declarations.
- Added classes (guarded): Backorder_Indexer (async Action Scheduler snapshot builder, option autoload=no), Backordered_Products_Page (admin submenu + report UI + dropdown filter showing unallocated/all/allocated), Quick_PO_Add_Handler (admin-post) to quick-add lines to a Supplier PO draft.
- Hooks: admin_init (ensure index), admin_menu (page), admin_post (build index + quick add), AS action 'lpr_allocator_build_index'.
- Admin/cron-only load ensured at top; no frontend hooks added.
- CRUD/HPOS APIs only: wc_get_orders / wc_get_order / WC_Order_Item_Product / wc_get_product; PO uses get_post_meta/update_post_meta; no wildcard meta_query; server-side pagination while scanning orders; snapshot cached in option; no stock writes.
- Options saved with autoload=no (lpr_allocator_backorder_index). User meta used for per-user quick draft pointer.
- Included nonces/capability checks and sanitized inputs; Supplier PO lines appended/merged without touching stock.
- The page lists backordered products not fully allocated by default, shows "Backordered", "Allocated", and "Required to Allocate" columns; includes a dropdown to also see all backordered (including fully allocated) or only fully allocated; each row has a "Quick add to Supplier PO draft" mini-form.
*/
